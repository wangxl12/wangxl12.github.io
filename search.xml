<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>小组合作项目使用Git的合理姿势</title>
    <url>/2021/11/14/Git/%E5%B0%8F%E7%BB%84%E5%90%88%E4%BD%9C%E9%A1%B9%E7%9B%AE%E4%BD%BF%E7%94%A8Git%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%A7%BF%E5%8A%BF/</url>
    <content><![CDATA[<p>从远程clone过来的项目默认只有一个分支main:</p>
<span id="more"></span>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git branch</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">*main</span><br></pre></td></tr></table></figure>
<p>尽量在dev分支上进行开发，因为main分支要存放稳定的版本，所以克隆了之后大家首先新建一个dev分支并关联到远程的dev分支：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git switch -c dev origin/dev</span><br><span class="line"><span class="meta">#</span><span class="bash"> switch是切换的意思，即切换分支</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -c 表示没有dev分支就新建一个再切换</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 后面带了一个origin/dev，origin表示远程主机名，即origin/dev表示远程主机的dev分支，即github上的dev分支。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 其实直接git switch -c dev是有含义的，而且通常用的更多，表示新建一个名为dev的本地分支并且切换到dev分支下。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 这里多了一个远程分支在后面表示将本地分支dev和远程分支origin/dev关联起来。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果这里没有关联远程分支origin/dev，也可以通过git branch --set-upstream-to=origin/dev dev来关联。</span></span><br></pre></td></tr></table></figure>
<p><img src="/2021/11/14/Git/%E5%B0%8F%E7%BB%84%E5%90%88%E4%BD%9C%E9%A1%B9%E7%9B%AE%E4%BD%BF%E7%94%A8Git%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%A7%BF%E5%8A%BF/%E5%85%B3%E8%81%94%E8%BF%9C%E7%A8%8B%E5%88%86%E6%94%AF.png" alt="关联远程分支"></p>
<p>这个dev分支就是大家可以进行提交的分支，main分支是稳定版本分支，我来合并，大家可以不用管。但是每一次打开这个git bash的时候都会默认是main分支，使用git switch dev就可以切换到dev分支。那么基本的分支弄好了大家如何修bug、提交代码呢？</p>
<p>需要大家再创建一个分支，刚刚不是创建了一个dev然后关联到远程仓库了吗？现在创建的分支不用关联，只有你自己知道，比如我创建一个feature1分支并切换过去：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git switch -c feature1</span><br></pre></td></tr></table></figure>
<p>下面比如我将readme.txt文件添加了一行：</p>
<p><img src="/2021/11/14/Git/%E5%B0%8F%E7%BB%84%E5%90%88%E4%BD%9C%E9%A1%B9%E7%9B%AE%E4%BD%BF%E7%94%A8Git%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%A7%BF%E5%8A%BF/%E6%B7%BB%E5%8A%A0%E4%BA%86%E4%B8%80%E8%A1%8C.png" alt="添加了一行"></p>
<p>然后添加到暂存区：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git add readme.txt</span><br></pre></td></tr></table></figure>
<p>然后切换到feature1分支，再将修改提交到本地仓库：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git switch feature1</span><br><span class="line">git commit -m &quot;add a line&quot;</span><br></pre></td></tr></table></figure>
<p>为什么需要切换到feature1分支呢？暂存区和工作区（BigDataProject文件夹）都是所有分支共享的，所以在哪里进行add操作都可以，但是commit操作会将暂存区里的修改一次性合并到本地仓库的对应分支上，所以需要切换到你想合并的分支下，我们不直接对dev分支进行操作，我们的思路是：直接对feature1分支进行操作，dev分支留在后面的修改全部弄完之后，将feature1合并到dev分支。</p>
<p>刚刚是进行了一个修改，当你将需要修改的内容全部修改完之后，需要提交到远程仓库之前，需要将feature1提交的修改合并到dev分支上：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 先切换到dev分支上：</span></span><br><span class="line">git switch dev</span><br><span class="line"><span class="meta">#</span><span class="bash"> 合并修改：</span></span><br><span class="line">git merge --no-ff feature1</span><br></pre></td></tr></table></figure>
<p>如果你对于feature1没有其他的使用价值了，就可以将这个分支删除了：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git branch -d feature1</span><br></pre></td></tr></table></figure>
<p>好了，刚刚将修改提交到本地仓库dev了，下面提交到远程仓库github上：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git push origin dev  </span><br></pre></td></tr></table></figure>
<p>提交之后可以去github上查看一下：</p>
<p><img src="/2021/11/14/Git/%E5%B0%8F%E7%BB%84%E5%90%88%E4%BD%9C%E9%A1%B9%E7%9B%AE%E4%BD%BF%E7%94%A8Git%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%A7%BF%E5%8A%BF/%E5%9C%A8github%E6%9F%A5%E7%9C%8B.png" alt="在github查看"></p>
<p>？没变啊？</p>
<p>别急，这个是main分支下的状态，我们刚刚提交的是dev分支，所以切换一下：</p>
<p><img src="/2021/11/14/Git/%E5%B0%8F%E7%BB%84%E5%90%88%E4%BD%9C%E9%A1%B9%E7%9B%AE%E4%BD%BF%E7%94%A8Git%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%A7%BF%E5%8A%BF/dev%E5%88%86%E6%94%AF.png" alt="dev分支"></p>
<p>这就是我们理想中的流程，即成员需要做的就是自己创建分支，在里面“大闹天宫”，提交到本地仓库，然后合并到dev分支中，最后将这个dev分支的内容提交到远程的dev分支，而main分支的内容不需要弄，组长来解决就行。</p>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Git版本控制与常见操作</title>
    <url>/2021/11/14/Git/Git%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E4%B8%8E%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<p>为什么我们要用git来提交代码？</p>
<span id="more"></span>
<p>我们平常在自己电脑上写一个简单的实验题目的时候，比如我实现了可视化功能，代码以及没有bug了，接下来想要同步数据库，但是又害怕接下来的代码会误改之前完整的代码，于是我就将当前没有Bug的代码压缩打包，命名为v1.0，然后就可以肆无忌惮的编写后面的代码了，等到后面的某一个功能实现之后，我重新将新版的代码压缩打包，命名为v1.1，继续后面的工作，如果后面某一个环节没做好导致所有代码都崩了，想回到v1.0，直接解压v1.0压缩包重新开始编写即可。</p>
<p>相信大家遇到一个复杂的项目的时候会有上述的操作，但是操作比较繁杂，特别是多个人来合作一个项目开发的时候，大家的代码共享、修改都会遇到很多的问题。使用git可以很好的解决上述问题，大家可以在自己的电脑上写好代码，然后上传到github 上，也可以将别人写的代码从github上下载过来，这个功能解决了开发人员之间的代码交互问题。</p>
<p>GitHub支持多个版本分支，如下图：</p>
<p><img src="/2021/11/14/Git/Git%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E4%B8%8E%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="版本控制意图"></p>
<p>上图中每一个节点表示一个版本号的代码，假设左边分支名字为dev，表示我们进行开发的分支，也就是可能有bug，正在维护的版本分支；右边分支假设是main 分支，表示我们发布的版本分支，比如我们最终可以拿出来发布的版本。</p>
<p><code>main</code>分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活；那在哪干活呢？干活都在<code>dev</code>分支上，也就是说，<code>dev</code>分支是不稳定的，到某个时候，比如1.0版本发布时，再把<code>dev</code>分支合并到<code>main</code>上，在<code>main</code>分支发布1.0版本.团队合作的分支看起来就像这样：</p>
<p><img src="/2021/11/14/Git/Git%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E4%B8%8E%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C/%E5%A4%8D%E6%9D%82%E5%9B%BE.png" alt="复杂图"></p>
<p>我首先在我的账号上创建了一个仓库<code>BigData</code>，然后拉其他人过来就可以协同完成这个项目，首先将项目从远程拉取过来：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone git@github.com:wangxl12/BigDataProject.git</span><br></pre></td></tr></table></figure>
<p>注意要把SSH Key添加到GitHub，如果提示电脑没有安装ssh，就需要安装一下.</p>
<p>查看目前有哪些分支：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git branch</span><br></pre></td></tr></table></figure>
<p>默认只有main分支：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch</span></span><br><span class="line">* main</span><br></pre></td></tr></table></figure>
<p>注意，要在dev分支上开发，就必须创建远程origin（远程主机名）的dev分支到本地，使用如下命令创建本地dev分支：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git switch -c dev origin/dev</span><br></pre></td></tr></table></figure>
<p>然后就可以在dev分支上修改，并时不时将dev分支push到远程：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m &quot;changed something&quot;</span><br><span class="line">git push origin dev</span><br></pre></td></tr></table></figure>
<p>我一开始创建仓库的时候只有main分支，这个分支作为稳定版本发布的分支，尽量少用，而dev分支我们作为开发分支，可以上传代码到这里。可能对于本地仓库、远程仓库的概念有不理解的地方，可以参看下面这张图：</p>
<p><img src="/2021/11/14/Git/Git%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E4%B8%8E%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C/%E4%BB%93%E5%BA%93%E5%9B%BE.png" alt="仓库图"></p>
<p>workspace就是我们的本地工作区，即BigData文件夹，index是暂存区，也在本地，repository是本地仓库，就是BigData目录下的.git目录（这是一个隐藏目录，如果看不见的话可能隐藏了，可以设置文件夹中的隐藏项为可见就可以看到了），而Remote就是远程仓库，即Github或者Gitee。有向线段之间的单词表示操作，经过这些操作之后文件会被传到不同的仓库。</p>
<h1>廖雪峰教程</h1>
<p>工作区（BigData）目录下有一个隐藏目录.git，这个是Git的版本库，版本库里有很多东西，其中最重要的就是称为stage（或者叫index)的暂存区，还有Git为我们自动创建的第一个分支master，以及指向master的一个指针叫HEAD.</p>
<p><img src="/2021/11/14/Git/Git%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E4%B8%8E%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C/%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93.png" alt="本地仓库"></p>
<p>往Git版本库里添加的时候分为两步：</p>
<p>第一步是用<code>git add</code>将文件添加进去，实际上就是将文件中的修改添加到暂存区；</p>
<p>第二步是用<code>git commit</code>提交修改，实际上是将暂存区中的所有内容提交到当前分支；</p>
<p>因为我们创建Git版本库时，Git自动为我们创建了唯一一个<code>master</code>分支，所以，现在，<code>git commit</code>就是往<code>master</code>分支上提交更改。可以简单理解为，需要提交的文件修改通通放到暂存区，然后，一次性提交暂存区的所有修改。</p>
<p>比如现在创建了一个test.txt文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">touch test.txt</span><br></pre></td></tr></table></figure>
<p>先加到暂存区：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git add test.txt</span><br></pre></td></tr></table></figure>
<p>然后提交到当前分支：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git commit -m &quot;我创建了一个test.txt文件&quot;</span><br></pre></td></tr></table></figure>
<p>注意，<code>git commit</code>只会将暂存区里的修改提交到当前的分支，如果有修改没有提交到暂存区，那么<code>commit</code>无法将这个修改提交到当前分支。此时，使用<code>git status</code>查看当前的状态的时候，可以看见类似下面的内容：</p>
<p><img src="/2021/11/14/Git/Git%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E4%B8%8E%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C/nostaged.png" alt="nostaged"></p>
<p>这就说明有一个read.txt文件在暂存区内，该文件有修改没有提交到版本库。可以使用如下指令<strong>查看工作区内的这个文件和版本库（本地）之间的区别</strong>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git diff HEAD -- readme.txt</span><br></pre></td></tr></table></figure>
<p><img src="/2021/11/14/Git/Git%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E4%B8%8E%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C/diff.png" alt="diff"></p>
<p>白色是工作区和版本库之间相同的部分，红色是工作区删掉的，绿色则是工作区添加的内容。</p>
<h1>丢弃修改</h1>
<ul>
<li><strong>假设此时修改了工作区的内容，但是还没有提交到暂存区，可以通过如下的方式丢弃修改：</strong></li>
</ul>
<p><strong>丢弃工作区的修改：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git restore readme.txt  # 不用背，使用git status查看状态的时候有提示</span><br></pre></td></tr></table></figure>
<p>修改之后查看工作区和版本库之间的区别：</p>
<p><img src="/2021/11/14/Git/Git%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E4%B8%8E%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C/nodiff.png" alt="nodiff"></p>
<p>发现回到了修改工作区之前的状态。就是让这个文件回到最近一次<code>git commit</code>或<code>git add</code>时的状态。<code>git checkout -- file</code>命令中的<code>--</code>很重要，没有<code>--</code>，就变成了“切换到另一个分支”的命令。</p>
<ul>
<li><strong>假设此时修改了工作区的内容，还通过add添加到了暂存区，可以通过如下的方式丢弃修改：</strong></li>
</ul>
<p>首先输入<code>git restore --staged &lt;file&gt;</code>将暂存区中的文件恢复到提交到暂存区之前，即在工作区修改了没有进行add操作。</p>
<p>然后使用<code>git restore &lt;file&gt;</code>将工作区的文件修改抛弃，即恢复到没有修改的状态。期间可以使用git status查看文件的状态，<strong>如果是绿色字体的modified，表示提交到了暂存区，没有commit，如果是红色的modified，表示修改了没有add。</strong></p>
<ul>
<li><strong>如果不但add交到了暂存区，还commit到了版本库，可以使用版本回退来回到上一个版本，不过这个要求你还没有将本地的版本库推送到远程版本库。</strong></li>
</ul>
<p>然后将本地仓库的内容上传到远程仓库：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git push</span><br></pre></td></tr></table></figure>
<p>查看历史记录：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git log  # 确定要回到之前的哪个版本</span><br><span class="line"><span class="meta">#</span><span class="bash"> 或者</span></span><br><span class="line">git log --pretty=oneline</span><br></pre></td></tr></table></figure>
<p>版本回退：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git reset --hard HEAD^  # 回退一个版本</span><br><span class="line">git reset --hard HEAD^^^ # 回退3个版本</span><br><span class="line">git reset --hard HEAD~100 # 回退100个版本</span><br></pre></td></tr></table></figure>
<p>版本前进：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git reset --hard 版本号  # 版本号可以通过git log查看，不需要完全输入，可以通过输入4~5个字符自动找到</span><br></pre></td></tr></table></figure>
<p>查看记录的每一次命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git reflog  # 确定要回到未来的哪个版本</span><br></pre></td></tr></table></figure>
<h1>删除文件</h1>
<p>将readme.txt删除：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rm readme.txt</span><br></pre></td></tr></table></figure>
<p>然后查看状态：<code>git status</code></p>
<p><img src="/2021/11/14/Git/Git%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E4%B8%8E%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C/deletestatus.png" alt="deletestatus"></p>
<p>根据提示，可以使用<code>git restore &lt;file&gt;</code>来恢复工作区的修改：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git restore readme.txt</span><br></pre></td></tr></table></figure>
<p>重新查看状态：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure>
<p><img src="/2021/11/14/Git/Git%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E4%B8%8E%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C/newstatus.png" alt="newstatus"></p>
<p>但是如果真的想删掉呢？我们创建一个test.txt文件试一下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">touch test.txt</span><br><span class="line">git add .</span><br><span class="line">git commit -m &quot;commit test.txt&quot;</span><br><span class="line">rm test.txt</span><br><span class="line">git status</span><br></pre></td></tr></table></figure>
<p><img src="/2021/11/14/Git/Git%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E4%B8%8E%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C/result1.png" alt="result1"></p>
<p>接下来将暂存区中的文件删掉，然后commit即可：</p>
<p><img src="/2021/11/14/Git/Git%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E4%B8%8E%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C/delete.png" alt="delete"></p>
<p><img src="/2021/11/14/Git/Git%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E4%B8%8E%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C/commit.png" alt="commit"></p>
<h1>创建远程仓库</h1>
<p>如果一开始只是在本地仓库中操作的，可以将本地仓库关联远程 仓库，然后将本地仓库的内容推送到GitHub仓库，在本地仓库下执行如下指令即可关联：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git remote add origin git@github.com:wangxl12/learngit.git</span><br></pre></td></tr></table></figure>
<p>这里的origin是远程仓库，这是Git默认的叫法，也可以改成别的，但是<code>origin</code>这个名字一看就知道是远程库。</p>
<p>下一步可以将本地库中的所有内容推送到远程库上：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure>
<p>把本地库的内容推送到远程，用<code>git push</code>命令，实际上是把当前分支<code>master</code>推送到远程。</p>
<p>由于远程库是空的，我们第一次推送<code>master</code>分支时，加上了<code>-u</code>参数，Git不但会把本地的<code>master</code>分支内容推送的远程新的<code>master</code>分支，还会把本地的<code>master</code>分支和远程的<code>master</code>分支关联起来，在以后的推送或者拉取时就可以简化命令。</p>
<p>从现在起，只要本地作了提交，就可以通过命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git push origin master</span><br></pre></td></tr></table></figure>
<p>把本地<code>master</code>分支的最新修改推送至GitHub，现在，你就拥有了真正的分布式版本库！</p>
<h1>删除远程库</h1>
<p>如果添加的时候地址写错了，或者就是想删除远程库，可以用<code>git remote rm &lt;name&gt;</code>命令。使用前，建议先用<code>git remote -v</code>查看远程库信息：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git remote -v</span></span><br><span class="line">origin  git@github.com:wangxl12/BigDataProject.git (fetch)</span><br><span class="line">origin  git@github.com:wangxl12/BigDataProject.git (push)</span><br></pre></td></tr></table></figure>
<p>然后，根据名字删除，比如删除<code>origin</code>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git remote rm origin</span><br></pre></td></tr></table></figure>
<p>此处的“删除”其实是解除了本地和远程的绑定关系，并不是物理上删除了远程库。远程库本身并没有任何改动。要真正删除远程库，需要登录到GitHub，在后台页面找到删除按钮再删除。</p>
<h1>从远程库克隆</h1>
<p>上面将的是先创建本地库，然后关联远程库，现在是先创建远程库，然后从远程库克隆。</p>
<p>如果有多个人协作开发，那么每个人各自从远程克隆一份就可以了。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone git@github.com:michaelliao/gitskills.git</span><br></pre></td></tr></table></figure>
<h1>分支管理</h1>
<h2 id="创建与合并分支">创建与合并分支</h2>
<p>强烈建议先学廖雪峰的Git教程：<a href="https://www.liaoxuefeng.com/wiki/896043488029600/900003767775424">https://www.liaoxuefeng.com/wiki/896043488029600/900003767775424</a></p>
<p><strong>创建分支并切换分支：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git checkout -b dev</span><br><span class="line"><span class="meta">#</span><span class="bash"> 相当于下面的两句：</span></span><br><span class="line">git branch dev</span><br><span class="line">git checkout dev</span><br></pre></td></tr></table></figure>
<p>如果希望将分支推送到远程库可以使用如下指令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git push origin dev</span><br></pre></td></tr></table></figure>
<p>使用<code>git branch</code>查看分支：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git branch</span><br></pre></td></tr></table></figure>
<p>然后我们可以在dev分支上正常提交，比如对readme.txt添加了一行内容：</p>
<p><img src="/2021/11/14/Git/Git%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E4%B8%8E%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C/%E6%B7%BB%E5%8A%A0%E4%BA%86%E4%B8%80%E8%A1%8C.png" alt="添加了一行"></p>
<p>绿色部分就是添加的内容，然后提交：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git add readme.txt</span><br><span class="line">git commit -m &quot;branch dev test&quot;</span><br></pre></td></tr></table></figure>
<p>通过git status也可以查看状态信息。</p>
<p>然后dev分支的工作完成之后，可以切回到main分支并查看添加的内容：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git checkout main</span><br><span class="line">cat readme.txt</span><br></pre></td></tr></table></figure>
<p>发现刚刚添加的内容不见了:</p>
<p><img src="/2021/11/14/Git/Git%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E4%B8%8E%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C/%E4%BF%AE%E6%94%B9%E6%B6%88%E5%A4%B1.png" alt="修改消失"></p>
<p>因为刚刚提交的是在dev 分支上，而main 分支此时的提交点并没有发生改变：</p>
<p><img src="/2021/11/14/Git/Git%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E4%B8%8E%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C/%E7%8A%B6%E6%80%811.png" alt="状态1"></p>
<p>现在，我们将dev分支的工作成果合并到main上：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git merge dev</span><br></pre></td></tr></table></figure>
<p><img src="/2021/11/14/Git/Git%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E4%B8%8E%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C/%E5%90%88%E5%B9%B6.png" alt="合并"></p>
<p>再查看readme.txt内容发现和dev分支的内容一致了：</p>
<p><img src="/2021/11/14/Git/Git%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E4%B8%8E%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C/%E7%BB%93%E6%9E%9C2.png" alt="结果2"></p>
<p>注意到上面的<code>Fast-forward</code>信息，Git告诉我们，这次合并是“快进模式”，也就是直接把<code>master</code>指向<code>dev</code>的当前提交，所以合并速度非常快。</p>
<p>当然，也不是每次合并都能<code>Fast-forward</code>，我们后面会讲其他方式的合并。</p>
<p>合并完成后，就可以放心地删除<code>dev</code>分支了：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git branch -d dev</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看分支：</span></span><br><span class="line">git branch</span><br></pre></td></tr></table></figure>
<p>因为创建、合并和删除分支非常快，所以Git鼓励你使用分支完成某个任务，合并后再删掉分支，这和直接在<code>master</code>分支上工作效果是一样的，但过程更安全。</p>
<p>切换分支还可以使用switch：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建并切换分支</span></span><br><span class="line">git switch -c dev</span><br><span class="line"><span class="meta">#</span><span class="bash"> 切换到已有分支</span></span><br><span class="line">git switch dev</span><br></pre></td></tr></table></figure>
<p>查看分支：<code>git branch</code></p>
<p>创建分支：<code>git branch &lt;name&gt;</code></p>
<p>切换分支：<code>git checkout &lt;name&gt;</code>或者<code>git switch &lt;name&gt;</code></p>
<p>创建+切换分支：<code>git checkout -b &lt;name&gt;</code>或者<code>git switch -c &lt;name&gt;</code></p>
<p>合并某分支到当前分支（快速合并）：<code>git merge &lt;name&gt;</code></p>
<p>删除分支：<code>git branch -d &lt;name&gt;</code></p>
<h2 id="解决冲突">解决冲突</h2>
<p>现在只有main分支，创建一个文件test，add、commit，然后创建一个新的分支feature1，add到暂存区，切换到这个分支下commit到本地仓库中：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">touch test</span><br><span class="line">git add .</span><br><span class="line"><span class="meta">#</span><span class="bash"> 先将<span class="built_in">test</span>创建的这一个修改提交到本地仓库</span></span><br><span class="line">git commit -m &quot;create test file&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建并切换到feature1分支</span></span><br><span class="line">git switch -c feature1</span><br><span class="line"><span class="meta">#</span><span class="bash"> *********向<span class="built_in">test</span>文件中添加一行内容，比如我添加branch main**************</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> vi <span class="built_in">test</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> i</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> branch main</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> :wq!</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> *****************************************************************</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> .表示将所有修改提交到暂存区</span></span><br><span class="line">git add .</span><br><span class="line"><span class="meta">#</span><span class="bash"> 暂存区和工作区都是所有分支共享的，即修改和add操作在哪个分支下进行都可</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 但是commit需要切换到想要提交的分支，这里我想提交到main分支</span></span><br><span class="line">git switch main</span><br><span class="line">git commit -m &quot;add a main branch line&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 至此，main分支已经比feature1分支多一个版本节点了，下面继续让二者程并列的状态</span></span><br><span class="line">git switch feature1</span><br><span class="line"><span class="meta">#</span><span class="bash"> *********向<span class="built_in">test</span>文件中添加一行内容，比如我添加的是branch feature1*******</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> vi <span class="built_in">test</span>  <span class="comment"># 打开会发现test是空的，因为之前的修改已经提交到main分支上了</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> i</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> line2 branch dev</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> :wq!</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> *****************************************************************</span></span><br><span class="line">git add .</span><br><span class="line">git commit -m &quot;add a feature1 branch line&quot;</span><br><span class="line">git switch main</span><br></pre></td></tr></table></figure>
<p>至此，分支的状态到达了下图所示：</p>
<p><img src="/2021/11/14/Git/Git%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E4%B8%8E%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C/%E5%B9%B6%E8%A1%8C%E7%8A%B6%E6%80%81.png" alt="并行状态"></p>
<p>这种情况下，Git无法执行“快速合并”，只能试图把各自的修改合并起来，但这种合并就可能会有冲突，我们试试看：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git merge feature1</span></span><br><span class="line">Auto-merging test</span><br><span class="line">CONFLICT (content): Merge conflict in test</span><br><span class="line">Automatic merge failed; fix conflicts and then commit the result.</span><br></pre></td></tr></table></figure>
<p>因为我们对一个文件进行了两种修改，这两种修改谁覆盖谁都说不通，所以会发生冲突。我们查看冲突的文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git status</span></span><br><span class="line">On branch main</span><br><span class="line">Your branch is ahead of &#x27;origin/main&#x27; by 11 commits.</span><br><span class="line">  (use &quot;git push&quot; to publish your local commits)</span><br><span class="line"></span><br><span class="line">You have unmerged paths.</span><br><span class="line">  (fix conflicts and run &quot;git commit&quot;)</span><br><span class="line">  (use &quot;git merge --abort&quot; to abort the merge)</span><br><span class="line"></span><br><span class="line">Unmerged paths:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to mark resolution)</span><br><span class="line">        both modified:   test</span><br><span class="line"></span><br><span class="line">no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们直接查看test的内容：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat <span class="built_in">test</span></span></span><br><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span><br><span class="line">branch main</span><br><span class="line">=======</span><br><span class="line">line2 branch dev</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt;&gt;&gt;&gt;&gt; feature1</span></span><br></pre></td></tr></table></figure>
<p>我们直接手动修改test文件为如下内容，从而解决冲突：</p>
<p><img src="/2021/11/14/Git/Git%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E4%B8%8E%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C/solveconflict.png" alt="solveconflict"></p>
<p>然后重新提交：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git add test</span><br><span class="line">git commit -m &quot;conflict fixed&quot;</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git commit -m <span class="string">&quot;conflict fixed&quot;</span></span></span><br><span class="line">[main d7c72cc] conflict fixed</span><br></pre></td></tr></table></figure>
<p>现在main和feature1分支变成了下图所示：</p>
<p><img src="/2021/11/14/Git/Git%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E4%B8%8E%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C/%E7%8A%B6%E6%80%812.png" alt="状态2"></p>
<p>用带参数的<code>git log</code>也可以看到分支的合并情况：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> --graph --pretty=oneline --abbrev-commit</span></span><br><span class="line">*   d7c72cc (HEAD -&gt; main) conflict fixed</span><br><span class="line">|\</span><br><span class="line">| * 7fb2bc5 (feature1) add a branch feature1 line</span><br><span class="line">* | f68248d add a main branch line</span><br><span class="line">|/</span><br><span class="line">*   69e37a8 Merge branch &#x27;dev&#x27; into main</span><br><span class="line">|\</span><br><span class="line">| * d441a47 test</span><br><span class="line">* | 4e52e8e test-main</span><br><span class="line">|/</span><br><span class="line">* 9bea0ff branch dev test</span><br><span class="line">* 53a40b8 delete test.txt</span><br><span class="line">* a66d7e5 commit test.txt</span><br><span class="line">* 4b238b8 test</span><br><span class="line">* b5353dc two lines changed</span><br><span class="line">* 80c715c add line 2</span><br><span class="line">* 87cf69b create readme.txt</span><br><span class="line">* ed46945 (origin/main) delete README.md</span><br><span class="line">* f650647 (origin/origin/dev, origin/dev) wxl commit readme.md</span><br></pre></td></tr></table></figure>
<p>合并完成之后，我们就可以删除feature1分支了：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git branch -d feature1</span><br></pre></td></tr></table></figure>
<p>当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。</p>
<p>解决冲突就是把Git合并失败的文件手动编辑为我们希望的内容，再提交。</p>
<p>用<code>git log --graph</code>命令可以看到分支合并图。</p>
<p><strong>上面举的例子是对同一个文件进行修改，所以无法自动合并，如果是两个分支同时创建一个文件的话，还是可以使用merge合并的，下面的内容就是举的这个例子：</strong></p>
<p>然后再新建一个文件，add,切换到main分支下commit：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">touch test-main</span><br><span class="line">git add .</span><br><span class="line">git switch main</span><br><span class="line">git commit -m &quot;test-main&quot;</span><br></pre></td></tr></table></figure>
<p>注意这里的创建文件、add在哪个分支下进行都可以，因为工作区和暂存区是所有分支共享的，但是commit需要在想提交的那个分支下进行，因为commit的本质就是同步工作区里的相应的分支。</p>
<p>现在可以切换到dev和main分支中查看，分别有一个test文件和test-main文件。现在各自的状态如下（将feature1分支改为dev，master分支改为main)：</p>
<p><img src="/2021/11/14/Git/Git%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E4%B8%8E%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C/%E7%8A%B6%E6%80%813.png" alt="状态3"></p>
<p>这种情况下如果进行快速合并的话：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git switch main</span><br><span class="line">git merge dev</span><br></pre></td></tr></table></figure>
<p>会调到一个类似文本文件的界面，输入:q退出。出来之后发现main分支有test文件了：</p>
<p><img src="/2021/11/14/Git/Git%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E4%B8%8E%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C/test%E6%96%87%E4%BB%B6%E5%8F%88%E6%9C%89%E4%BA%86.png" alt="test文件又有了"></p>
<h2 id="分支管理策略">分支管理策略</h2>
<p>通常，合并分支时，如果可能，Git会用<code>Fast forward</code>模式，但这种模式下，删除分支后，会丢掉分支信息。</p>
<p>如果要强制禁用<code>Fast forward</code>模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。</p>
<p>合并分支时，加上<code>--no-ff</code>参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而<code>fast forward</code>合并就看不出来曾经做过合并。</p>
<p>切换到dev分支，修改一下test里的内容，然后add, commit提交：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git switch -c dev</span><br><span class="line">vi test</span><br><span class="line">git add .</span><br><span class="line">git commit -m &quot;add merge&quot;</span><br></pre></td></tr></table></figure>
<p>然后切换回main：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git switch main</span><br></pre></td></tr></table></figure>
<p>准备合并dev分支，请注意–no-ff参数，表示禁用Fast forward:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git switch main</span><br><span class="line">git merge --no-ff -m &quot;merge with no-ff&quot; dev</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git merge --no-ff -m <span class="string">&quot;merge with no-ff&quot;</span> dev  <span class="comment"># 因为本次合并要创建一个新的commit，所以加上-m参数，把commit描述写进去。</span></span></span><br><span class="line">Merge made by the &#x27;recursive&#x27; strategy.</span><br><span class="line"> test | 3 +--</span><br><span class="line"> 1 file changed, 1 insertion(+), 2 deletions(-)</span><br></pre></td></tr></table></figure>
<p>合并后，我们用<code>git log</code>看看分支历史：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> --graph --pretty=oneline --abbrev-commit</span></span><br><span class="line">*   fecae9f (HEAD -&gt; main) merge with no-ff</span><br><span class="line">|\</span><br><span class="line">| * 39ba997 (dev) add merge</span><br><span class="line">|/</span><br><span class="line">*   d7c72cc (origin/main) conflict fixed</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以看到，不使用<code>Fast forward</code>模式，merge后就像这样:</p>
<p><img src="/2021/11/14/Git/Git%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E4%B8%8E%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C/%E7%8A%B6%E6%80%814.png" alt="状态4"></p>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Git安装+账户注册+SourceTree</title>
    <url>/2021/11/14/Git/Git%E5%AE%89%E8%A3%85+%E8%B4%A6%E6%88%B7%E6%B3%A8%E5%86%8C+SourceTree/</url>
    <content><![CDATA[<h1>下载并安装typora</h1>
<span id="more"></span>
<p>Typora是一个写markdown的非常好用的工具，必不可少。</p>
<p><a href="https://typora.io/#download">https://typora.io/#download</a></p>
<h1>下载并安装git</h1>
<p><a href="https://git-scm.com/">https://git-scm.com/</a></p>
<p>直接点这个</p>
<p><img src="/2021/11/14/Git/Git%E5%AE%89%E8%A3%85+%E8%B4%A6%E6%88%B7%E6%B3%A8%E5%86%8C+SourceTree/%E4%B8%8B%E8%BD%BDGit.png" alt="下载Git"></p>
<p>安装完成之后随意进入一个文件夹右键，可以看到下面框里的内容：</p>
<p>![git bush](git bush.png)</p>
<h1>配置Git</h1>
<p>新建一个文件夹，如learngit,然后进入文件夹，右键，点击<code>Git Bash Here</code>，弹出如下界面：</p>
<p><img src="/2021/11/14/Git/Git%E5%AE%89%E8%A3%85+%E8%B4%A6%E6%88%B7%E6%B3%A8%E5%86%8C+SourceTree/shell.png" alt="shell"></p>
<p>这个界面中可以执行常见的linux系统中的命令，比如ls，cd等。</p>
<p>然后开始配置：</p>
<ol>
<li>配置用户名：<code>git config -global user.name &quot;xxx&quot;</code>，将xxx替换为你想设置的用户名。</li>
<li>配置邮箱：<code>git config -global user.email &quot;xxx&quot;</code>，将xxx替换为邮箱</li>
<li>配置大小写敏感：<code>git config -global core.ignorecase false</code>，直接输入这个指令即可。</li>
<li>查看配置信息：<code>git config --list</code>。</li>
</ol>
<h1>关联远程仓库</h1>
<p>创建一个文件夹，命名为BigDataProject，这个文件夹将存放课设的代码的，可以自己考虑放在哪。输入如下指令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git init  # 初始化文件夹，即将该文件夹设为本地仓库，执行之后会多一个.git文件夹</span><br><span class="line">git branch -M main  # 重命名master分支为main</span><br><span class="line">git remote add origin git@github.com:wangxl12/BigDataProject.git  # 关联github上的这个仓库</span><br><span class="line">git push -u origin main  # 将修改推送到GitHub的main分支上</span><br></pre></td></tr></table></figure>
<h1>SourceTree使用</h1>
<p><img src="/2021/11/14/Git/Git%E5%AE%89%E8%A3%85+%E8%B4%A6%E6%88%B7%E6%B3%A8%E5%86%8C+SourceTree/%E6%89%93%E5%BC%80%E9%A1%B9%E7%9B%AE.png" alt="打开项目"></p>
<p>等待一会儿就有了如下所示界面：</p>
<p><img src="/2021/11/14/Git/Git%E5%AE%89%E8%A3%85+%E8%B4%A6%E6%88%B7%E6%B3%A8%E5%86%8C+SourceTree/%E9%A1%B9%E7%9B%AE%E7%95%8C%E9%9D%A2.png" alt="项目界面"></p>
<p>找到你的BigDataProject目录，有如下内容：</p>
<p><img src="/2021/11/14/Git/Git%E5%AE%89%E8%A3%85+%E8%B4%A6%E6%88%B7%E6%B3%A8%E5%86%8C+SourceTree/%E9%A1%B9%E7%9B%AE%E5%86%85%E5%AE%B9.png" alt="项目内容"></p>
<p>接下来自学Git教程，进行上传代码、拉取代码、创建分支等等操作。</p>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>一台主机生成多个ssh_key，无冲突提交代码至远程仓库</title>
    <url>/2021/11/14/Git/%E4%B8%80%E5%8F%B0%E4%B8%BB%E6%9C%BA%E5%A4%9A%E4%B8%AAssh_key%E6%8F%90%E4%BA%A4%E4%BB%A3%E7%A0%81%E8%87%B3%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/</url>
    <content><![CDATA[<h1>我的情况</h1>
<p>我之前创建了一个github账号wangxl12，当时也按照教程生成了ssh key，并且将公钥放在了github中保存了。现在我又创建了一个github账号wxltop，并新建了一个仓库，我想将仓库clone到本地，编辑之后上传代码。但是，我遇到了如下的问题：</p>
<span id="more"></span>
<ul>
<li>在没有向wxltop账号里存放ssh key的情况下，使用ssh协议克隆可以成功？</li>
<li>克隆成功之后，进行修改代码，然后上传，即<code>git push -u origin main</code>报错，说用户<code>wangxl12</code>没有权限，为什么可以克隆但是不能上传？为什么用户是<code>wangxl12</code>？我没有显示指定呀？</li>
</ul>
<p>我的系统是windows 10，下面解决这个问题。</p>
<h1>解决问题</h1>
<ol>
<li>
<p>打开Git Bush，然后输入如下指令重新生成一个ssh key（<strong>注意new_id_rsa可以换成你喜欢的名字</strong>）：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &#x27;xxxxx@youremail.com&#x27; -f ~/.ssh/new_id_rsa</span><br></pre></td></tr></table></figure>
<p>切换到<code>C:\Users\name\.ssh</code>(<strong>注意将name换成自己的windows用户名</strong>)目录下，可以发现新增了如下2个文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">new_id_rsa</span><br><span class="line">new_id_rsa.pub</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>查看系统ssh-key代理，执行如下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh-add -l</span><br></pre></td></tr></table></figure>
<p>如果报错<code>Could not open a connection to your authentication agent.</code>则需要先执行以下如下的指令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh-agent bash</span><br></pre></td></tr></table></figure>
<p>重新执行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh-add -l</span><br></pre></td></tr></table></figure>
<p>以上命令如果输出 <code>The agent has no identities</code>. 则表示没有代理。如果系统有代理，可以执行下面的命令清除代理:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh-add -D</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>然后依次将不同的ssh添加代理，执行命令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh-add ~/.ssh/id_rsa</span><br><span class="line">ssh-add ~/.ssh/new_id_rsa</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>配置~/.ssh/config文件：</p>
<p>为什么之前不配置也可以呢？因为之前只有一个ssh key，github使用SSH与客户端连接。如果是单用户（first），生成密钥对后，将公钥保存至 GitHub ，每次连接时SSH客户端发送本地私钥（默认~/.ssh/id_rsa）到服务端验证。单用户情况下，连接的服务器上保存的公钥和发送的私钥自然是配对的。但是如果是 <strong>多用户</strong> （first，second），我们在连接到second的帐号时，second保存的是自己的公钥，但是SSH客户端依然发送默认私钥，即first的私钥，那么这个验证自然无法通过。</p>
<p>创建一个config文件，然后添加如下内容：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Default github user(first@mail.com)</span></span><br><span class="line">Host github.com</span><br><span class="line">HostName github.com</span><br><span class="line">User git</span><br><span class="line">IdentityFile C:/Users/username/.ssh/id_rsa</span><br><span class="line"><span class="meta"> </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> new account (second_email@mail.com)</span></span><br><span class="line">Host github-new</span><br><span class="line">HostName github.com</span><br><span class="line">User git</span><br><span class="line">IdentityFile C:/Users/username/.ssh/new_id_rsa</span><br></pre></td></tr></table></figure>
<p>其中参数含义如下：</p>
<p><strong>Host</strong> ：  相当于一个别名，远程仓库地址的域名别名它涵盖了下面一个段的配置，我们可以通过他来替代将要连接的服务器地址。这里可以使用任意字段或通配符。访问ssh的时候如果服务器地址能匹配上这里Host指定的值，则Host下面指定的HostName将被作为最终的服务器地址使用，并且将使用该Host字段下面配置的所有自定义配置来覆盖默认的~/.ssh/config配置信息。</p>
<p><strong>HostName</strong> ：真正连接的服务器地址</p>
<p><strong>User</strong>：自定义的用户名  （直接用git就行）</p>
<p><strong>PreferredAuthentications</strong> ：指定优先使用哪种方式验证，支持密码和秘钥验证方式</p>
<p><strong>IdentityFile</strong>：指定本次连接使用的密钥文件</p>
<p><strong>在连接非默认账号的github仓库时，远程库的地址要对应的做一些修改</strong>，比如现在添加second账号下的一个仓库，则需要这样添加：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git remote add wxltop git@github-new:wxltop/wxltop.git</span><br></pre></td></tr></table></figure>
<p>如果是下面这样的话就会添加默认账号下的仓库：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git remote add wxltop git@github.com:wxltop/wxltop.git</span><br></pre></td></tr></table></figure>
<p>从这里我们看出，一开始就算没有将第二个账号的秘钥生成并放入GitHub中，我们直接clone下来是可以成功的，因为我们默认用的是第一个账户：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 这里的github.com对应的就是config文件中的Host github.com</span></span><br><span class="line">git clone git@github.com:wxltop/wxltop.git</span><br></pre></td></tr></table></figure>
<p>如果我们要用第二个账号的秘钥克隆，就需要修改为下面这样，当然需要提前将new_id_rsa中的内容放入github中，添加新的ssh key。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 这里的github-new对应的就是config文件中的Host github-new</span></span><br><span class="line">git clone git@github-new:wxltop/wxltop.git</span><br></pre></td></tr></table></figure>
<p>这样就是基于第二个账号下载过来的。克隆过来了之后弄几个配置（<strong>特别是用户名和邮箱，必须配置，不然提交修改之后去github查看还是默认用户提交的修改</strong>）：</p>
<ol>
<li>配置用户名：<code>git config -global user.name &quot;xxx&quot;</code>，将xxx替换为你想设置的用户名。</li>
<li>配置邮箱：<code>git config -global user.email &quot;xxx&quot;</code>，将xxx替换为邮箱</li>
<li>配置大小写敏感：<code>git config -global core.ignorecase false</code>，直接输入这个指令即可。</li>
<li>查看配置信息：<code>git config --list</code>。</li>
</ol>
<p><strong>这里的用户名和邮箱建议和第二个账号的用户名和邮箱一致，我原本以为这个并不影响，所以一开始克隆过来之后没有配置，但是后面的代码修改在GitHub上查看都是以第一个账号为名义修改的，查了很多教程都无法解决这个问题。然后抱着尝试的心态将用户名和邮箱改成第二个账号的用户名和邮箱之后，重新修改代码、提交代码，在GitHub上查看是以第二个账号为名义修改的。</strong></p>
</li>
<li>
<p>测试ssh</p>
<p>测试第一个账号：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Hi wangxl12! You&#x27;ve successfully authenticated, but GitHub does not provide shell access.</span><br></pre></td></tr></table></figure>
<p>测试第二个账号：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh -T git@github-new</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Hi wxltop! You&#x27;ve successfully authenticated, but GitHub does not provide shell access.</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>修改代码并上传</p>
<p>经过add、commit可以push一下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git push -u origin main</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>有一个问题</p>
<p>比如我刚刚打开一个Git Bash shell之后，将上述步骤都走了一遍，然后关掉了当前的Git Bash shell（会提示当前有一个进程正在进行，是否继续关掉），等到下一次打开Git Bash shell的时候，需要重新执行一下<code>ssh-agent bash</code>，然后再次测试一下看看是否连接成功：<code>ssh -T git@wxltop</code>，连接成功之后才可以确认是在wxltop账号下。</p>
</li>
</ol>
<p><strong>Reference</strong></p>
<p><a href="https://www.cnblogs.com/ayseeing/p/4445194.html">https://www.cnblogs.com/ayseeing/p/4445194.html</a></p>
<p><a href="https://www.zhihu.com/people/wxl-59-25">https://www.zhihu.com/people/wxl-59-25</a></p>
<p><a href="http://167.86.101.119/lV5mrUYsucU/how-to-fix-github-permission-denied-publickey-fatal-could-not-read-from-remote-repository">http://167.86.101.119/lV5mrUYsucU/how-to-fix-github-permission-denied-publickey-fatal-could-not-read-from-remote-repository</a></p>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>GNN-数据集</title>
    <url>/2021/10/31/GNN/GNN-%E6%95%B0%E6%8D%AE%E9%9B%86/</url>
    <content><![CDATA[<p>本文介绍一些可以用于GNN的数据集</p>
<span id="more"></span>
<h1 id="github"><a href="#github" class="headerlink" title="github"></a>github</h1><p><a href="https://github.com/graphdeeplearning/benchmarking-gnns/blob/master/docs/02_download_datasets.md">https://github.com/graphdeeplearning/benchmarking-gnns/blob/master/docs/02_download_datasets.md</a></p>
<p>这个github中介绍了如下几个数据集：</p>
<ol>
<li><p>MNIST/CIFAR10</p>
<p>这两个数据集很常见，就不多说了。最重要的是，这里使用到了<code>super pixel</code>技术，将图片转换成图。加载CIFAR10数据集的脚本参见<a href="https://github.com/graphdeeplearning/benchmarking-gnns/blob/master/data/superpixels/prepare_superpixels_CIFAR.ipynb">这里</a></p>
</li>
<li><p>ZINC molecular</p>
<p>这个数据集是化学分子数据集，比较新颖，点击<a href="https://paperswithcode.com/dataset/zinc">这里</a>查看数据集。</p>
<p><img src="/2021/10/31/GNN/GNN-%E6%95%B0%E6%8D%AE%E9%9B%86/ZINC数据集.png" alt="ZINC"></p>
</li>
<li><p>PATTERN/CLUSTER SBM datasets</p>
</li>
</ol>
]]></content>
      <categories>
        <category>数据集</category>
      </categories>
      <tags>
        <tag>GNN</tag>
        <tag>数据集</tag>
      </tags>
  </entry>
  <entry>
    <title>基本概念</title>
    <url>/2021/10/29/GNN/%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<p>除了一些常见的图的基本概念，如：连通图、度数、连通子图、强连通图、有向图、无向图、有向图连通性等之外，还有一些之前没有接触过的概念在此补充一下：</p>
<span id="more"></span>
<h1 id="图直径："><a href="#图直径：" class="headerlink" title="图直径："></a>图直径：</h1><p>图中两两结点之间的距离值的最大值。</p>
<h1 id="度中心性："><a href="#度中心性：" class="headerlink" title="度中心性："></a>度中心性：</h1><script type="math/tex; mode=display">
\text{度中心性}=\frac{N_{degree}}{n-1}</script><h1 id="特征向量中心性："><a href="#特征向量中心性：" class="headerlink" title="特征向量中心性："></a>特征向量中心性：</h1><p><img src="/2021/10/29/GNN/%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/特征向量中心性.png" alt="特征向量中心性"></p>
<p>图对应一个邻接矩阵，求这个邻接矩阵的特征值和特征向量，最大特征值对应的特征向量就是特征向量中心性。比如上面例子中，求出来的特征值最大的是第一个，对应的特征向量是第一列，将第一列求负数（没影响），得到特征向量中心性。</p>
<p>下面观察一下“特征向量中心性”到底可以表征何种信息。</p>
<p>看节点1和节点5，其特征向量中心性的值是最大的，在图中可以看出来，两节点的度数也是最大的。2,3,4节点的特征向量中心性没有节点1和5大，从图中看出来是因为它们的度数为2&lt;3。但是2,3,4之间也有大小关系，可以看到2,3,4虽然度数相同，但是所连接的结点的度数不同，具体来说是：4结点邻接点是1,5，它们都是读数为3的结点；2结点和3结点读数都为2，所连接的两个结点都是一个读数为2，一个读数为3，所以二者的度数相同。</p>
<p>从上述分析可以看出来，特征向量中心性不仅表征了一个节点的度数，还表征了其相邻节点的度数。</p>
<h1 id="中介中心性"><a href="#中介中心性" class="headerlink" title="中介中心性"></a>中介中心性</h1><p>计算公式：</p>
<script type="math/tex; mode=display">
Betweenness=\frac{\text{经过该结点的最短路径}}{\text{其余两两结点的最短路径}}</script><p>比如下面的关系图中：</p>
<p><img src="/2021/10/29/GNN/%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/中介中心性.png" alt="中介中心性"></p>
<p>假设每一条边的权值为1。曹操的中介中心性计算如下：</p>
<script type="math/tex; mode=display">
\text{曹操}_{betweenness}=\frac{(0+1+1+0.5) + (0+0+1+1)+(0+1+1+0.5)+4+4}{4*5}</script><p>这表示什么含义呢？</p>
<p>首先蔡文姬结点，到达甄姬的最短路径为1，但是没有经过曹操，所以第一项的第一个值为0；蔡文姬到达夏侯惇的最短路径为</p>
<h1 id="连接中心性"><a href="#连接中心性" class="headerlink" title="连接中心性"></a>连接中心性</h1><script type="math/tex; mode=display">
Closeness=\frac{n-1}{\text{结点到其他结点最短路径之和}}</script><p>还是上面的王者的图，</p>
<script type="math/tex; mode=display">
\text{曹操}_{closeness}=\frac{6-1}{5}=1</script><h1 id="PageRank-网页排序算法"><a href="#PageRank-网页排序算法" class="headerlink" title="PageRank(网页排序算法)"></a>PageRank(网页排序算法)</h1><h1 id="HITS"><a href="#HITS" class="headerlink" title="HITS"></a>HITS</h1><p><img src="/2021/10/29/GNN/%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/例子.png" alt="例子"></p>
]]></content>
      <categories>
        <category>GNN</category>
      </categories>
      <tags>
        <tag>GNN</tag>
      </tags>
  </entry>
  <entry>
    <title>线性回归从零开始实现</title>
    <url>/2021/10/25/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>本文代码取自李沐的《动手学习深度学习》，里面有些代码细节让我觉得非常值得斟酌，特记录。</p>
<span id="more"></span>
<h1 id="生成、可视化数据集"><a href="#生成、可视化数据集" class="headerlink" title="生成、可视化数据集"></a>生成、可视化数据集</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> utils <span class="keyword">import</span> d2l</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">synthetic_data</span>(<span class="params">w, b, num_examples</span>):</span> </span><br><span class="line">    <span class="string">&quot;&quot;&quot;生成 y = Xw + b + 噪声。&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 为x添加均值为0，方差为1的正态噪声</span></span><br><span class="line">    X = torch.normal(<span class="number">0</span>, <span class="number">1</span>, (num_examples, <span class="built_in">len</span>(w)))</span><br><span class="line">    y = torch.matmul(X, w) + b</span><br><span class="line">    <span class="comment"># 为y添加均值为0，方差为0.01的正态噪声</span></span><br><span class="line">    y += torch.normal(<span class="number">0</span>, <span class="number">0.01</span>, y.shape)</span><br><span class="line">    <span class="keyword">return</span> X, y.reshape((-<span class="number">1</span>, <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># true_w和true_b都是真实的w、b，现在根据两参数</span></span><br><span class="line"><span class="comment"># 添加噪声来构建数据集</span></span><br><span class="line">true_w = torch.tensor([<span class="number">2</span>, -<span class="number">3.4</span>])</span><br><span class="line">true_b = <span class="number">4.2</span></span><br><span class="line">features, labels = synthetic_data(true_w, true_b, <span class="number">1000</span>)</span><br><span class="line">d2l.set_figsize()</span><br><span class="line">d2l.plt.scatter(features[:, (<span class="number">1</span>)].detach().numpy(), labels.detach().numpy(), <span class="number">1</span>)</span><br><span class="line">d2l.plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="/2021/10/25/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AE%9E%E7%8E%B0/数据集可视化.png" alt="数据集可视化"></p>
<h1 id="读取数据"><a href="#读取数据" class="headerlink" title="读取数据"></a>读取数据</h1><p>使用迭代器生成数据集</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">data_iter</span>(<span class="params">batch_size, features, labels</span>):</span></span><br><span class="line">    num_examples = features.shape[<span class="number">0</span>]</span><br><span class="line">    indices = <span class="built_in">list</span>(<span class="built_in">range</span>(num_examples))</span><br><span class="line">    <span class="comment"># 打乱样本序号</span></span><br><span class="line">    random.shuffle(indices)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, num_examples, batch_size):</span><br><span class="line">        <span class="comment"># 从随机数表indices中抽取batch_size个数，</span></span><br><span class="line">        <span class="comment"># 然后将这几个数传入features中</span></span><br><span class="line">        <span class="comment"># 在保证抽取的数量为batch_size的前提下，达到随机挑选样本的目的</span></span><br><span class="line">        batch_indices = torch.tensor(</span><br><span class="line">            indices[i: <span class="built_in">min</span>(i + batch_size, num_examples)]</span><br><span class="line">        )</span><br><span class="line">        <span class="keyword">yield</span> features[batch_indices], labels[batch_indices]</span><br></pre></td></tr></table></figure>
<p>这里有一个问题，即如果样本数量不能整除batch_size，就导致有一些样本始终取不到，为了防止这个问题发生，可以每一次取完之后重新打乱样本序号。</p>
<p>从中取出一个样本数据：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">batch_size = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> X, Y <span class="keyword">in</span> data_iter(batch_size, features, labels):</span><br><span class="line">    <span class="built_in">print</span>(X, <span class="string">&quot;\n&quot;</span>, Y)</span><br><span class="line">    <span class="keyword">break</span></span><br></pre></td></tr></table></figure>
<h1 id="初始化模型参数"><a href="#初始化模型参数" class="headerlink" title="初始化模型参数"></a>初始化模型参数</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">w = torch.normal(<span class="number">0</span>, <span class="number">0.01</span>, size=(<span class="number">2</span>, <span class="number">1</span>), requires_grad=<span class="literal">True</span>)</span><br><span class="line"><span class="comment"># w = torch.zeros((2, 1), requires_grad=True)</span></span><br><span class="line">b = torch.zeros(<span class="number">1</span>, requires_grad=<span class="literal">True</span>)</span><br><span class="line"><span class="built_in">print</span>(w)</span><br><span class="line"><span class="built_in">print</span>(b)</span><br></pre></td></tr></table></figure>
<h1 id="定义模型-损失函数-优化算法"><a href="#定义模型-损失函数-优化算法" class="headerlink" title="定义模型/损失函数/优化算法"></a>定义模型/损失函数/优化算法</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">linreg</span>(<span class="params">X, w, b</span>):</span></span><br><span class="line">    <span class="keyword">return</span> torch.mm(X, w) + b</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">squared_loss</span>(<span class="params">y_hat, y</span>):</span>  <span class="comment">#@save</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;均方损失。&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> (y_hat - y.reshape(y_hat.shape)) ** <span class="number">2</span> / <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sgd</span>(<span class="params">params, lr, batch_size</span>):</span></span><br><span class="line">    <span class="keyword">with</span> torch.no_grad():  </span><br><span class="line">        <span class="keyword">for</span> param <span class="keyword">in</span> params:</span><br><span class="line">            param -= lr * param.grad / batch_size </span><br><span class="line">            <span class="comment"># 当前的梯度只是上一次epoch计算出来的梯度</span></span><br><span class="line">            <span class="comment"># 更新权重之后需要消掉这次梯度，防止和下一次的梯度叠加</span></span><br><span class="line">            <span class="comment"># 下一次的梯度只能从下一次的epoch中计算而来</span></span><br><span class="line">            param.grad.zero_()</span><br></pre></td></tr></table></figure>
<p>这里的sgd函数有几个问题：</p>
<ol>
<li><p>为什么这里需要加一个with torch.no_grad()？</p>
<p>因为w和b的requires_grad是True，所有关于他们的运算都会自动构建计算图（用于累积梯度），这里不需要构建静态图、跟踪计算日志，因为我们需要的、和w，b有关的计算图应该仅仅是正向传播的计算图，如果这里不加限制，会自动创建关于权重更新运算的计算图。可以将存储梯度的内存节省下来，这样也可以让代码执行速度更快。</p>
</li>
<li><p>这里如何更新权重的，问答区有两个回复非常好，需要记录一下</p>
<blockquote>
<p>当某一变量var在函数外面已经声明时 （如var=v0），函数内部默认var为全局变量且可以访问该变量，除非在函数内部有修改变量var的行为（如重新赋值 var=v1 或者代数运算 var=var+v1 等）。在这种修改变量的情况下，变量var会被定义为局部变量并被重新分配内存，它在函数内部的变化不会影响到外部的全局变量var的值（即var=v0保持不变）。</p>
<p>特殊之处在于本节sgd中使用的运算符（-=）会执行原地操作（in-place operation），也就是运算结果会赋给同一块内存。由于params本身就是全局变量，修改后的结果仍然赋给它的内存，所以变化的也就是全局变量了。如修改为 param = param - … 结果就不对了</p>
<p>造成你困惑的最主要原因的核心是“可变对象与不可变对象”。<br>对于函数中的for循环，param得到的是列表中元素的引用，这没有问题。<br>但是呢，会不会就地改变（直接作用到变量）这得看具体的实现。<br>“-=”操作符会调用<strong>isub</strong>函数，而”-“操作符会调用<strong>sub</strong>函数，一般对于可变对象来说“-=”操作符会直接改变self自身。对于pytorch来说，应该会调用sub_函数.</p>
<p>举个例子</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line">x1 = <span class="number">1</span></span><br><span class="line">x2 = <span class="number">2</span></span><br><span class="line">params = [x1, x2]</span><br><span class="line"><span class="keyword">for</span> p <span class="keyword">in</span> params:</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">id</span>(p), <span class="built_in">id</span>(x1), <span class="built_in">id</span>(x2))</span><br><span class="line">    p -= <span class="number">4</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">id</span>(p), <span class="built_in">id</span>(x1), <span class="built_in">id</span>(x2))</span><br><span class="line"><span class="built_in">print</span>(params)</span><br><span class="line"></span><br><span class="line">x1 = torch.Tensor([<span class="number">1</span>])</span><br><span class="line">x2 = torch.Tensor([<span class="number">2</span>])</span><br><span class="line">params = [x1, x2]</span><br><span class="line"><span class="keyword">for</span> p <span class="keyword">in</span> params:</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">id</span>(p), <span class="built_in">id</span>(x1), <span class="built_in">id</span>(x2))</span><br><span class="line">    p -= <span class="number">4</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">id</span>(p), <span class="built_in">id</span>(x1), <span class="built_in">id</span>(x2))</span><br><span class="line"><span class="built_in">print</span>(params)</span><br></pre></td></tr></table></figure>
<p>你会得到(你自己运行的话，id得到的地址会不一样)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">9784896</span> <span class="number">9784896</span> <span class="number">9784928</span></span><br><span class="line"><span class="number">9784768</span> <span class="number">9784896</span> <span class="number">9784928</span></span><br><span class="line"><span class="number">9784928</span> <span class="number">9784896</span> <span class="number">9784928</span></span><br><span class="line"><span class="number">9784800</span> <span class="number">9784896</span> <span class="number">9784928</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"><span class="number">139752445458112</span> <span class="number">139752445458112</span> <span class="number">139752445458176</span></span><br><span class="line"><span class="number">139752445458112</span> <span class="number">139752445458112</span> <span class="number">139752445458176</span></span><br><span class="line"><span class="number">139752445458176</span> <span class="number">139752445458112</span> <span class="number">139752445458176</span></span><br><span class="line"><span class="number">139752445458176</span> <span class="number">139752445458112</span> <span class="number">139752445458176</span></span><br><span class="line">[tensor([-<span class="number">3.</span>]), tensor([-<span class="number">2.</span>])]</span><br></pre></td></tr></table></figure>
<p>可以看到对于int类型，地址变换了，而torch类型，地址却没有变化。<br>p -= 4等价于p.sub_(4)。这个可变对象改变了自身。而若如vin100提到的写成p = p - 4则会调用构造函数，并返回一个新的变量，也就不可能作用到原先的“可变对象”。<br>int类没有发生就地变化是因为它是一个不可变对象。</p>
</blockquote>
<p>从两条评论来看，能让权重顺利更新的原因有两个：（1）python函数形参地址和实参地址相同；（2）传入的列表中的元素是tensor(可变对象)。</p>
<p>首先第（1）条保证了函数内外的列表对应的地址一致，如下测试代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>]]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span>(<span class="params">a</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;函数内：id(a[0]) = <span class="subst">&#123;<span class="built_in">id</span>(a[<span class="number">0</span>])&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;函数外：id(a[0]) = <span class="subst">&#123;<span class="built_in">id</span>(a[<span class="number">0</span>])&#125;</span>&quot;</span>)</span><br><span class="line">f(a)</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">函数外：<span class="built_in">id</span>(a) = <span class="number">1875349520968</span></span><br><span class="line">函数内：<span class="built_in">id</span>(a) = <span class="number">1875349520968</span></span><br></pre></td></tr></table></figure>
<p>如果对列表中的第一个元素改变一下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>]]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span>(<span class="params">a</span>):</span></span><br><span class="line">    a[<span class="number">0</span>] -= <span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;函数内：id(a[0]) = <span class="subst">&#123;<span class="built_in">id</span>(a[<span class="number">0</span>])&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;函数外：id(a[0]) = <span class="subst">&#123;<span class="built_in">id</span>(a[<span class="number">0</span>])&#125;</span>&quot;</span>)</span><br><span class="line">f(a)</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">函数外：<span class="built_in">id</span>(a[<span class="number">0</span>]) = <span class="number">140713631654288</span></span><br><span class="line">函数内：<span class="built_in">id</span>(a[<span class="number">0</span>]) = <span class="number">140713631654256</span></span><br></pre></td></tr></table></figure>
<p>不可变对象（int）的地址发生了变化。</p>
<p>如果改变的是列表里的列表呢（可变对象）？</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>]]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span>(<span class="params">a</span>):</span></span><br><span class="line">    a[<span class="number">2</span>][<span class="number">0</span>] -= <span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;函数内：id(a[2]) = <span class="subst">&#123;<span class="built_in">id</span>(a[<span class="number">2</span>])&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;函数外：id(a[2]) = <span class="subst">&#123;<span class="built_in">id</span>(a[<span class="number">2</span>])&#125;</span>&quot;</span>)</span><br><span class="line">f(a)</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">函数外：<span class="built_in">id</span>(a[<span class="number">2</span>]) = <span class="number">1875349520456</span></span><br><span class="line">函数内：<span class="built_in">id</span>(a[<span class="number">2</span>]) = <span class="number">1875349520456</span></span><br></pre></td></tr></table></figure>
<p>发现可变对象的地址没有发生变化。</p>
<p>将列表里的元素全部换成tensor测试一下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>]]</span><br><span class="line">a = [torch.tensor(elem) <span class="keyword">for</span> elem <span class="keyword">in</span> a]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span>(<span class="params">a</span>):</span></span><br><span class="line">    a[<span class="number">0</span>] -= <span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;函数内：id(a[0]) = <span class="subst">&#123;<span class="built_in">id</span>(a[<span class="number">0</span>])&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;函数外：id(a[0]) = <span class="subst">&#123;<span class="built_in">id</span>(a[<span class="number">0</span>])&#125;</span>&quot;</span>)</span><br><span class="line">f(a)</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">函数外：<span class="built_in">id</span>(a[<span class="number">0</span>]) = <span class="number">1875366498040</span></span><br><span class="line">函数内：<span class="built_in">id</span>(a[<span class="number">0</span>]) = <span class="number">1875366498040</span></span><br></pre></td></tr></table></figure>
<p>地址没有改变，这就印证了上面的说法。</p>
</li>
<li><p>这里更新权重，为什么需要除以batch_size</p>
<p>计算出来的梯度只是本次batch得到的，并不是所有的数据集，如果不除以batch_size可能导致下降的太快，导致进入局部极小值。</p>
</li>
<li><p>为什么需要使用grad.zero_()</p>
<p>当前的梯度只是上一次epoch计算出来的梯度，更新权重之后需要消掉这次梯度，防止和下一次的梯度叠加，下一次的梯度只能从下一次的epoch中计算而来。</p>
</li>
<li><p>如果我们使用官方的损失函数来代替我们自己实现的损失函数，而且用<code>nn.MSELoss(reduction=‘sum’)</code>替换 <code>nn.MSELoss（）</code>为了使代码的行为相同，需要怎么更改学习速率？为什么？</p>
<p>​    参考官方文档中，这个函数的实现细节：<a href="https://pytorch.org/docs/stable/generated/torch.nn.CrossEntropyLoss.html">https://pytorch.org/docs/stable/generated/torch.nn.CrossEntropyLoss.html</a></p>
<p>​    应该把学习率除以batch_size，因为默认参数是’mean’，换成’sum’需要除以批量数，一般会采用默认，因为这样学习率可以跟batch_size解耦。我们测试一下，修改前：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">loss = nn.MSELoss()</span><br><span class="line">trainer = torch.optim.SGD(net.parameters(), lr=<span class="number">0.03</span>)</span><br><span class="line"></span><br><span class="line">num_epochs = <span class="number">3</span></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(num_epochs):</span><br><span class="line">    <span class="keyword">for</span> X, y <span class="keyword">in</span> data_iter:</span><br><span class="line">        l = loss(net(X), y)</span><br><span class="line">        <span class="comment"># 这里和前面自己实现的不同</span></span><br><span class="line">        <span class="comment"># 这个API没有自动清零梯度</span></span><br><span class="line">        <span class="comment"># 需要利用传入优化算法的API来手动清零</span></span><br><span class="line">        trainer.zero_grad()</span><br><span class="line">        l.backward()</span><br><span class="line">        <span class="comment"># 优化过程：</span></span><br><span class="line">        trainer.step()</span><br><span class="line">    <span class="comment"># 优化完成之后，需要手动计算所有的features和labels之间的损失值</span></span><br><span class="line">    l = loss(net(features), labels)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;epoch <span class="subst">&#123;epoch + <span class="number">1</span>&#125;</span>, loss <span class="subst">&#123;l:f&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">epoch <span class="number">1</span>, loss <span class="number">0.000103</span></span><br><span class="line">epoch <span class="number">2</span>, loss <span class="number">0.000102</span></span><br><span class="line">epoch <span class="number">3</span>, loss <span class="number">0.000101</span></span><br></pre></td></tr></table></figure>
<p>修改后：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">loss = nn.MSELoss(reduction=<span class="string">&#x27;sum&#x27;</span>)</span><br><span class="line">trainer = torch.optim.SGD(net.parameters(), lr=<span class="number">0.03</span>/batch_size)</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">epoch <span class="number">1</span>, loss <span class="number">0.102505</span></span><br><span class="line">epoch <span class="number">2</span>, loss <span class="number">0.101427</span></span><br><span class="line">epoch <span class="number">3</span>, loss <span class="number">0.101685</span></span><br></pre></td></tr></table></figure>
<p>发现取sum的损失值显著大于默认的mean损失值，为什么？</p>
<p>mean意味着所有样本损失的平均值，即loss会除以样本数，sum没有除这个样本数，所以会放大1000倍（这里样本数为1000），可以试着将样本数改成10000，会发现两种方式确实损失值相差1w倍。</p>
</li>
</ol>
<h1 id="训练"><a href="#训练" class="headerlink" title="训练"></a>训练</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">lr = <span class="number">0.03</span></span><br><span class="line">num_epochs = <span class="number">3</span></span><br><span class="line">net = linreg</span><br><span class="line">loss = squared_loss</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(num_epochs):</span><br><span class="line">    <span class="keyword">for</span> X, y, <span class="keyword">in</span> data_iter(batch_size, features, labels):</span><br><span class="line">        l = loss(net(X, w, b), y) <span class="comment"># X和Y的小批量损失</span></span><br><span class="line">        <span class="comment"># 因为l的形状是（batch_size, 1)，而不是一个标量，&#x27;l&#x27;中所有元素被加到一起来计算梯度</span></span><br><span class="line">        l.<span class="built_in">sum</span>().backward()</span><br><span class="line">        sgd([w, b], lr, batch_size) <span class="comment"># 使用参数的梯度进行更新</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 在经过一个epoch更新之后，重新计算此时的预测损失值为多少</span></span><br><span class="line">    <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">        train_l = loss(net(features, w, b), labels)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;epoch <span class="subst">&#123;epoch + <span class="number">1</span>&#125;</span>, loss <span class="subst">&#123;<span class="built_in">float</span>(train_l.mean())&#125;</span>&#x27;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;w的估计误差: <span class="subst">&#123;true_w - w.reshape(true_w.shape)&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;b的估计误差: <span class="subst">&#123;true_b - b&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>训练的基本步骤是进行多个epoch，每一个epoch都会将所有的数据遍历一遍，但是每一次遍历不是一次性将所有的数据加载入内存，而是使用迭代器的方式多个batch加载。</p>
<p>加载完数据需要投入模型计算，计算估计值和真实值之间的损失函数，利用损失函数进行反向传播，从而计算需要优化的参数的梯度。</p>
<p>使用参数的梯度更新参数，更新完成之后计算此时预测的结果和真实值之间的损失值并输出。</p>
<p>反复执行上述步骤，直至退出循环。</p>
<p><strong>有两个问题</strong>：</p>
<ol>
<li><p>为什么需要计算得到损失值，然后才对进行更新，而不是直接根据表达式更新，因为我觉得参数的梯度和损失值无关，而是求偏导之后和X有关。</p>
<p>有这个疑问其实是对于pytorch的静态图没有理解，凡是有关于grad needed变量的运算，pytorch都会记录其操作符，并构建反向传播图，如果不计算loss，那么这一步构建反向传播图就无法进行，求偏导确实和损失值本身无关。</p>
</li>
<li><p>为什么每一次计算一个batch的损失之后，就需要马上进行反向传播，我可否将每一个batch计算得到的损失拼接起来，最后进行更新？或者每一个batch都更新一次，然后将损失值拼接起来，后面每个batch都会将以前的batch的损失值拼接起来一起更新权重？</p>
<p>​    首先说第一种，基于这一思想，改写代码逻辑如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">lr = <span class="number">0.03</span></span><br><span class="line">num_epochs = <span class="number">300</span></span><br><span class="line">net = linreg</span><br><span class="line">loss = squared_loss</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(num_epochs):</span><br><span class="line">    count = <span class="number">1</span></span><br><span class="line">    l = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">for</span> X, y, <span class="keyword">in</span> data_iter(batch_size, features, labels):</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> l <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            l = loss(net(X, w, b), y) <span class="comment"># X和Y的小批量损失</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            torch.cat((l, loss(net(X, w, b), y)), dim=<span class="number">0</span>)</span><br><span class="line">    <span class="comment"># 退出循环之后（遍历所有样本之后）反向传播，然后更新权重</span></span><br><span class="line">    l.<span class="built_in">sum</span>().backward()</span><br><span class="line">    sgd([w, b], lr, batch_size * count) </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">        train_l = loss(net(features, w, b), labels)</span><br><span class="line">        <span class="keyword">if</span> (epoch + <span class="number">1</span>) % <span class="number">10</span> == <span class="number">0</span>: </span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&#x27;epoch <span class="subst">&#123;epoch + <span class="number">1</span>&#125;</span>, loss <span class="subst">&#123;<span class="built_in">float</span>(train_l.mean())&#125;</span>&#x27;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;w的估计误差: <span class="subst">&#123;true_w - w.reshape(true_w.shape)&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;b的估计误差: <span class="subst">&#123;true_b - b&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>最终效果并不好，最终更新的次数就是epoch次，首先次数大大减少，如果增加epoch数量，之前样本数是1000，batch_size是10，epoch是3，一共会更新300次，所以直接将epoch设置为300进行测试，将最后5个epoch计算得到的损失值列出来：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">epoch <span class="number">260</span>, loss <span class="number">13.599431037902832</span></span><br><span class="line">epoch <span class="number">270</span>, loss <span class="number">13.525508880615234</span></span><br><span class="line">epoch <span class="number">280</span>, loss <span class="number">13.450084686279297</span></span><br><span class="line">epoch <span class="number">290</span>, loss <span class="number">13.36327838897705</span></span><br><span class="line">epoch <span class="number">300</span>, loss <span class="number">13.275373458862305</span></span><br><span class="line">w的估计误差: tensor([ <span class="number">1.7403</span>, -<span class="number">2.9753</span>], grad_fn=&lt;SubBackward0&gt;)</span><br><span class="line">b的估计误差: tensor([<span class="number">3.6783</span>], grad_fn=&lt;RsubBackward1&gt;)</span><br></pre></td></tr></table></figure>
<p>效果还是很差，损失值下降非常缓慢。</p>
<p>第二种思路行不通，首先根据这种思路改写代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">lr = <span class="number">0.03</span></span><br><span class="line">num_epochs = <span class="number">3000</span></span><br><span class="line">net = linreg</span><br><span class="line">loss = squared_loss</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(num_epochs):</span><br><span class="line">    count = <span class="number">1</span></span><br><span class="line">    l = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">for</span> X, y, <span class="keyword">in</span> data_iter(batch_size, features, labels):</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> l <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            l = loss(net(X, w, b), y) <span class="comment"># X和Y的小批量损失</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            torch.cat((l, loss(net(X, w, b), y)), dim=<span class="number">0</span>)</span><br><span class="line">        <span class="comment"># 将前一次的损失cat过来一起反向传播，然后更新权重</span></span><br><span class="line">        l.<span class="built_in">sum</span>().backward()</span><br><span class="line">        sgd([w, b], lr, batch_size * count) </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">        train_l = loss(net(features, w, b), labels)</span><br><span class="line">        <span class="keyword">if</span> (epoch + <span class="number">1</span>) % <span class="number">10</span> == <span class="number">0</span>: </span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&#x27;epoch <span class="subst">&#123;epoch + <span class="number">1</span>&#125;</span>, loss <span class="subst">&#123;<span class="built_in">float</span>(train_l.mean())&#125;</span>&#x27;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;w的估计误差: <span class="subst">&#123;true_w - w.reshape(true_w.shape)&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;b的估计误差: <span class="subst">&#123;true_b - b&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>代码执行会报错：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">RuntimeError: Trying to backward through the graph a second time, but the saved intermediate results have already been freed. Specify retain_graph=<span class="literal">True</span> when calling backward the first time.</span><br></pre></td></tr></table></figure>
<p>因为每一次正向传播的过程中，在requires_grad=True的情况下会构建反向梯度计算图，在反向传播之后都会释放掉，因为模型过大时一直占用很容易爆内存，释放之后下一个循环就无法计算被释放部分的变量的梯度。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
        <tag>torch</tag>
      </tags>
  </entry>
  <entry>
    <title>pytorch的自动求导</title>
    <url>/2021/10/24/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/pytorch%E7%9A%84%E8%87%AA%E5%8A%A8%E6%B1%82%E5%AF%BC/</url>
    <content><![CDATA[<h1>使用pytorch的backward()报错</h1>
<p>使用pytorch的backward函数的时候报错：RuntimeError: grad can be implicitly created only for scalar outputs。</p>
<span id="more"></span>
<p>观察下面这段代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line">x = torch.tensor(<span class="number">2.3</span>, requires_grad=<span class="literal">True</span>)</span><br><span class="line">y = <span class="number">2</span> * x</span><br><span class="line">y.backward()</span><br><span class="line"><span class="built_in">print</span>(x.grad)</span><br></pre></td></tr></table></figure>
<p>输出结果为：2.0</p>
<p>x是一个标量，当调用它的backward方法后会根据链式法则自动计算出叶子节点的梯度值，如果将其换成一个矩阵或者向量呢？</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line">x = torch.randn((<span class="number">3</span>, <span class="number">4</span>), requires_grad=<span class="literal">True</span>)</span><br><span class="line">y = <span class="number">2</span> * x</span><br><span class="line">y.backward()</span><br><span class="line"><span class="built_in">print</span>(x.grad)</span><br></pre></td></tr></table></figure>
<p>得到报错：<code>RuntimeError: grad can be implicitly created only for scalar outputs</code></p>
<p><strong>如果 <code>Tensor</code> 是一个标量(即它包含一个元素的数据），则不需要为 <code>backward()</code> 指定任何参数，但是如果它有更多的元素，则需要指定一个 <code>gradient</code> 参数，该参数是形状匹配的张量。</strong></p>
<p>那么为了解决上面代码的问题，需要将第5行改成如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">y.backward(gradient=torch.ones_like(x))</span><br><span class="line"><span class="comment"># 或者改成：y.sum().backward()</span></span><br><span class="line"><span class="comment"># 使用sum的话得到的就是各元素之和，得到的就是一个标量，可以求梯度</span></span><br></pre></td></tr></table></figure>
<p>输出结果如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tensor([[<span class="number">2.</span>, <span class="number">2.</span>, <span class="number">2.</span>, <span class="number">2.</span>],</span><br><span class="line">        [<span class="number">2.</span>, <span class="number">2.</span>, <span class="number">2.</span>, <span class="number">2.</span>],</span><br><span class="line">        [<span class="number">2.</span>, <span class="number">2.</span>, <span class="number">2.</span>, <span class="number">2.</span>]])</span><br></pre></td></tr></table></figure>
<p>当然，最常用的是传入torch.ones_like(x)函数，也可以传入其他的张量给gradient参数，比如下面这段代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = torch.tensor([<span class="number">2.</span>, <span class="number">1.</span>], requires_grad=<span class="literal">True</span>)</span><br><span class="line">y = torch.tensor([[<span class="number">1.</span>, <span class="number">2.</span>], [<span class="number">3.</span>, <span class="number">4.</span>]], requires_grad=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">z = torch.mm(x.view(<span class="number">1</span>, <span class="number">2</span>), y)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;z:<span class="subst">&#123;z&#125;</span>&quot;</span>)</span><br><span class="line">z.backward(torch.Tensor([[<span class="number">1.</span>, <span class="number">0</span>]]), retain_graph=<span class="literal">True</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;x.grad: <span class="subst">&#123;x.grad&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;y.grad: <span class="subst">&#123;y.grad&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>输出结果如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">z:tensor([[<span class="number">5.</span>, <span class="number">8.</span>]], grad_fn=&lt;MmBackward&gt;)</span><br><span class="line">x.grad: tensor([<span class="number">1.</span>, <span class="number">3.</span>])</span><br><span class="line">y.grad: tensor([[<span class="number">2.</span>, <span class="number">0.</span>],</span><br><span class="line">        [<span class="number">1.</span>, <span class="number">0.</span>]])</span><br></pre></td></tr></table></figure>
<p>z容易理解，就是两个矩阵x和y相乘的结果，反向传播的时候，计算流程如下图所示：</p>
<p><img src="/2021/10/24/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/pytorch%E7%9A%84%E8%87%AA%E5%8A%A8%E6%B1%82%E5%AF%BC/%E8%AE%A1%E7%AE%97%E6%8E%A8%E5%AF%BC.png" alt="计算流程"></p>
<p>源代码中backward的接口定义如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">torch.autograd.backward(</span><br><span class="line">		tensors, </span><br><span class="line">		grad_tensors=<span class="literal">None</span>, </span><br><span class="line">		retain_graph=<span class="literal">None</span>, </span><br><span class="line">		create_graph=<span class="literal">False</span>, </span><br><span class="line">		grad_variables=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure>
<p><code>grad_tensors</code>的作用其实可以简单地理解成在求梯度时的权重，因为可能不同值的梯度对结果影响程度不同，所以pytorch弄了个这种接口，而没有固定为全是1。</p>
<h1>PyTorch Basics</h1>
<p><strong>Tensors</strong>：张量在Pytorch中相当于一个高维数组，除了可以加载到CPU，张量还可以加载到GPU从而加速计算。只要将一个张量的参数设置为：<code>requires_grad=True</code>，他们就会自动构建反向传播计算图，并跟踪每一次在该张量上的运算，以便于使用静态计算图（dynamic computation graph）来计算张量。</p>
<p>在早期版本的pytorch中，<code>torch.autograd.Variable</code>类被用来创建支持梯度计算和操作符跟踪的张量，但是Torch v0.4.0中Variable类已经被弃用了。现在在pytorch中，<code>torch.Tensor</code>和<code>torch.autograd.Variable</code>是同一个类，而且前者更适合用于跟踪运算符。</p>
<p>一个权重参数的梯度可以理解为：该权重的一个微小改变导致的损失值的改变。随后该梯度被用于更新权重。</p>
<blockquote>
<p>注意，在pytorch中，只有浮点型的张量才可以计算梯度。可以使用如下的方式快速转换：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line">x = torch.randint(<span class="number">1</span>, <span class="number">5</span>, (<span class="number">2</span>, <span class="number">3</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Int type x: \n<span class="subst">&#123;x&#125;</span>\n&quot;</span>)</span><br><span class="line">x = x.type_as(torch.FloatTensor(x.shape))</span><br><span class="line">x.requires_grad_(<span class="literal">True</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Float type x: \n<span class="subst">&#123;x&#125;</span>\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">y = x ** <span class="number">2</span></span><br><span class="line">y.backward(torch.ones_like(x))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;x.grad: \n<span class="subst">&#123;x.grad&#125;</span>\n&quot;</span>)</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>Autograd</strong>:这个类记录了在一个gradient enabled张量上的所有运算符，并创建了一个静态计算图。这个计算图中，输入结点表示叶子节点，输出结点是根节点。<strong>梯度的计算是通过从根节点走到叶子节点，使用链式法则，将沿途上所有的梯度相乘得到最终叶子节点的梯度。</strong></p>
<h1>静态计算图（Dynamic Computational graph)</h1>
<p>静态计算图由gradient enabled 张量和操作符共同偶见。数据流与在该数据流上的运算符在运行时就定义了，所以静态计算图的构建完全是自动的。一个设置<code>requires_grad=False</code>的简单相加操作的计算图构建如下（图片来自https://towardsdatascience.com/pytorch-autograd-understanding-the-heart-of-pytorchs-magic-2686cd94ec95）：</p>
<p><img src="/2021/10/24/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/pytorch%E7%9A%84%E8%87%AA%E5%8A%A8%E6%B1%82%E5%AF%BC/%E9%9D%99%E6%80%81%E5%9B%BE.png" alt="静态图"></p>
<p>每一个虚线框表示的是图中的一个变量，紫色矩形框是一个操作符。</p>
<p>每一个变量都有如下的属性成员：</p>
<p><strong>Data</strong>:变量的数值。</p>
<p><strong>requires_grad</strong>:这个属性如果设置为True，就开始跟踪所有的操作符然后构建一个反向传播图用于计算梯度，对于任意一个张量，创建之后可以通过<code>a.required_grad_(True)</code>来改变其状态。</p>
<p><strong>grad</strong>:这个属性表示变量的梯度值。如果<code>requires_grad</code>是False，那么grad值就是None，即便<code>requires_grad</code>是True，变量的grad属性也不能立马变成有值的状态，还需要根节点的<code>.backward()</code>函数操作之后才可以有梯度值。</p>
<p><strong>grad_fn</strong>:该属性记录了用于计算梯度的反向传播函数。</p>
<p><strong>is_leaf</strong>:如果一个节点满足以下条件之一就是叶子结点：</p>
<pre><code>1. 该结点变量通过一些函数来显示初始化，比如`x=torch.tensor(1.0)`或者`x=torch.randn(1, 1)`。
2. 在对所有`requires_grad=False`的张量经过运算符操作之后创建的结点。
3. 它是通过一些张量的`.detach()`创建的。
</code></pre>
<p>一旦根节点执行了<code>backward()</code>，梯度只会被填充到<code>requires_grad</code>和<code>is_leaf</code>均为True的结点上。</p>
<p>如果设置<code>requires_grad=True</code>，pytorch会开始追踪操作符，并且将每一步的<code>requires_grad=True</code>的变量的梯度函数存储起来，就像下图一样（图来自https://towardsdatascience.com/pytorch-autograd-understanding-the-heart-of-pytorchs-magic-2686cd94ec95）：</p>
<p><img src="/2021/10/24/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/pytorch%E7%9A%84%E8%87%AA%E5%8A%A8%E6%B1%82%E5%AF%BC/%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD%E5%9B%BE.png" alt="反向传播图"></p>
<p>下面这段代码可以生成上述的计算图：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line"><span class="comment"># Creating the graph</span></span><br><span class="line">x = torch.tensor(<span class="number">1.0</span>, requires_grad = <span class="literal">True</span>)</span><br><span class="line">y = torch.tensor(<span class="number">2.0</span>)</span><br><span class="line">z = x * y</span><br><span class="line"></span><br><span class="line"><span class="comment"># Displaying</span></span><br><span class="line"><span class="keyword">for</span> i, name <span class="keyword">in</span> <span class="built_in">zip</span>([x, y, z], <span class="string">&quot;xyz&quot;</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;name&#125;</span>\ndata: <span class="subst">&#123;i.data&#125;</span>\nrequires_grad: <span class="subst">&#123;i.requires_grad&#125;</span>\n\</span></span><br><span class="line"><span class="string">grad: <span class="subst">&#123;i.grad&#125;</span>\ngrad_fn: <span class="subst">&#123;i.grad_fn&#125;</span>\nis_leaf: <span class="subst">&#123;i.is_leaf&#125;</span>\n&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>如果要防止pytorch追踪运算与创建反向传播图，可以将代码片段包含在<code>with torch.no_grad():</code>里，这可以让代码运行的更快，而且节省内存。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="comment"># Creating the graph</span></span><br><span class="line">x = torch.tensor(<span class="number">1.0</span>, requires_grad = <span class="literal">True</span>)</span><br><span class="line"><span class="comment"># Check if tracking is enabled</span></span><br><span class="line"><span class="built_in">print</span>(x.requires_grad) <span class="comment">#True</span></span><br><span class="line">y = x * <span class="number">2</span></span><br><span class="line"><span class="built_in">print</span>(y.requires_grad) <span class="comment">#True</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> torch.no_grad():</span><br><span class="line">	<span class="comment"># Check if tracking is enabled</span></span><br><span class="line">	y = x * <span class="number">2</span></span><br><span class="line">	<span class="built_in">print</span>(y.requires_grad) <span class="comment">#False</span></span><br></pre></td></tr></table></figure>
<h1>Jacobians and vectors</h1>
<p>雅克比(Jacobians)矩阵：记录两个向量之间的偏导数关系。如一个向量<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>=</mo><mo stretchy="false">[</mo><msub><mi>x</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>x</mi><mn>2</mn></msub><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msub><mi>x</mi><mi>n</mi></msub><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">X=[x_1,x_2...x_n]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span>​，另一个向量<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">[</mo><msub><mi>f</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>f</mi><mn>2</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>f</mi><mi>n</mi></msub><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">f(x)=[f_1,f_2,...,f_n]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span>，那么雅克比矩阵<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>J</mi></mrow><annotation encoding="application/x-tex">J</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.09618em;">J</span></span></span></span>表示如下：</p>
<p><img src="/2021/10/24/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/pytorch%E7%9A%84%E8%87%AA%E5%8A%A8%E6%B1%82%E5%AF%BC/%E9%9B%85%E5%85%8B%E6%AF%94%E7%9F%A9%E9%98%B5.png" alt="雅克比矩阵"></p>
<p>假设一个pytorch的gradient enabled张量<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>=</mo><mo stretchy="false">[</mo><msub><mi>x</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>x</mi><mn>2</mn></msub><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msub><mi>x</mi><mi>n</mi></msub><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">X=[x_1,x_2...x_n]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span>（假设它表示的是一个机器学习模型中的权重），X经过一些操作之后得到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Y</mi><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">[</mo><msub><mi>y</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>y</mi><mn>2</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>y</mi><mi>m</mi></msub><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">Y=f(X)=[y_1, y_2, ...,y_m]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span>。</p>
<p>然后Y被用于计算标量损失<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi></mrow><annotation encoding="application/x-tex">l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span></span></span></span>，假设一个向量<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span></span></span></span>是标量损失<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi></mrow><annotation encoding="application/x-tex">l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span></span></span></span>相对于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span></span></span></span>​的梯度向量：</p>
<p><img src="/2021/10/24/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/pytorch%E7%9A%84%E8%87%AA%E5%8A%A8%E6%B1%82%E5%AF%BC/%E6%A2%AF%E5%BA%A6%E5%90%91%E9%87%8F.png" alt="梯度向量"></p>
<p>为了获得损失<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi></mrow><annotation encoding="application/x-tex">l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span></span></span></span>和权重<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span></span></span>之间的梯度，使用雅克比矩阵与<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span></span></span></span>相乘可以得到：</p>
<p><img src="/2021/10/24/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/pytorch%E7%9A%84%E8%87%AA%E5%8A%A8%E6%B1%82%E5%AF%BC/%E9%9B%85%E5%85%8B%E6%AF%94%E4%B9%98v.png" alt="雅克比乘v"></p>
<h1>pytorch inplace operation</h1>
<p><strong>在pytorch中，有两种情况不能使用inplace operation</strong>：</p>
<ol>
<li>对于requires_grad=True的叶子张量不能使用inplace operation；</li>
<li>对于在<strong>求梯度阶段需要用到的张量</strong>，不能使用Inplace operation。</li>
</ol>
<p><strong>第一种情况: requires_grad=True的leaf tensor</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line">w = torch.FloatTensor(<span class="number">10</span>) <span class="comment"># w 是个 leaf tensor</span></span><br><span class="line">w.requires_grad = <span class="literal">True</span>    <span class="comment"># 将 requires_grad 设置为 True</span></span><br><span class="line">w.normal_()               <span class="comment"># 在执行这句话就会报错</span></span><br></pre></td></tr></table></figure>
<p>报错信息为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">RuntimeError: a leaf Variable that requires grad <span class="keyword">is</span> being used <span class="keyword">in</span> an <span class="keyword">in</span>-place operation.</span><br></pre></td></tr></table></figure>
<p>因为作为叶子结点，在设置requires_grad为True之后，计算图开始构建了，如果要在构建之后初始化权重可以这样：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line">w = torch.FloatTensor(<span class="number">10</span>) <span class="comment"># w 是个 leaf tensor</span></span><br><span class="line">w.requires_grad = <span class="literal">True</span>    <span class="comment"># 将 requires_grad 设置为 True</span></span><br><span class="line"><span class="comment"># w.normal_()      </span></span><br><span class="line">w.data = torch.normal(<span class="number">0</span>, <span class="number">0.01</span>, w.data.shape)</span><br></pre></td></tr></table></figure>
<p><strong>第二种情况：求梯度阶段需要用到的张量</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line">x = torch.randint(<span class="number">1</span>, <span class="number">5</span>, (<span class="number">2</span>, <span class="number">3</span>))</span><br><span class="line">x = x.type_as(torch.FloatTensor(x.shape))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;x = \n<span class="subst">&#123;x&#125;</span>\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">w = torch.randint(<span class="number">1</span>, <span class="number">5</span>, (<span class="number">3</span>, <span class="number">2</span>))</span><br><span class="line">w = w.type_as(torch.FloatTensor(w.shape))</span><br><span class="line">w.requires_grad_(<span class="literal">True</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;w = \n<span class="subst">&#123;w&#125;</span>\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">d = torch.mm(x, w)</span><br><span class="line"><span class="comment"># x -= 1</span></span><br><span class="line"></span><br><span class="line">d.<span class="built_in">sum</span>().backward()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;w.grad = \n<span class="subst">&#123;w.grad&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>将上述代码计算图构建出来如下：</p>
<p><img src="/2021/10/24/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/pytorch%E7%9A%84%E8%87%AA%E5%8A%A8%E6%B1%82%E5%AF%BC/%E7%AE%80%E5%8D%95%E8%AE%A1%E7%AE%97%E5%9B%BE.png" alt="简单计算图"></p>
<p>在计算得到d之后，反向求梯度的计算图就已经构建好了，而且w的梯度值的计算依赖于x的值，如果去掉代码中的注释，重新x -= 1的话，那么在反向传播的时候利用到x的值来求梯度就有误，为了防止这种错误发生，pytorch报错：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">RuntimeError: one of the variables needed <span class="keyword">for</span> gradient computation has been modified by an inplace operation: </span><br><span class="line">        [torch.FloatTensor [<span class="number">2</span>, <span class="number">3</span>]] <span class="keyword">is</span> at version <span class="number">2</span>; expected version <span class="number">1</span> instead. </span><br><span class="line">        Hint: enable anomaly detection to find the operation that failed to compute its gradient, <span class="keyword">with</span> torch.autograd.set_detect_anomaly(<span class="literal">True</span>).</span><br></pre></td></tr></table></figure>
<p>造成错误的主要原因是，<a href="http://%E6%89%A7%E8%A1%8Cd=torch.mm">执行d=torch.mm</a>(x, w)之后，反向求导机制保存了x的引用以便后续的反向求导计算。</p>
<h2 id="x-data和x-detach-的区别">x.data和x.detach()的区别</h2>
<p>二者的相同之处在于：</p>
<ul>
<li>都和x共享一块数据</li>
<li>都和x的计算历史无关</li>
<li>requires_grad=False</li>
</ul>
<p>不同之处在于，x.data在某些情况下不安全，比如上述inplace operation 的第二种情况，将上述代码修改如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line">x = torch.randint(<span class="number">1</span>, <span class="number">5</span>, (<span class="number">2</span>, <span class="number">3</span>))</span><br><span class="line">x = x.type_as(torch.FloatTensor(x.shape))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;x = \n<span class="subst">&#123;x&#125;</span>\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">w = torch.randint(<span class="number">1</span>, <span class="number">5</span>, (<span class="number">3</span>, <span class="number">2</span>))</span><br><span class="line">w = w.type_as(torch.FloatTensor(w.shape))</span><br><span class="line">w.requires_grad_(<span class="literal">True</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;w = \n<span class="subst">&#123;w&#125;</span>\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">d = torch.mm(x, w)</span><br><span class="line">x_ = x.data</span><br><span class="line">x_ -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">d.<span class="built_in">sum</span>().backward()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;w.grad = \n<span class="subst">&#123;w.grad&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>输出结果如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = </span><br><span class="line">tensor([[<span class="number">4.</span>, <span class="number">2.</span>, <span class="number">2.</span>],</span><br><span class="line">        [<span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>]])</span><br><span class="line"></span><br><span class="line">w = </span><br><span class="line">tensor([[<span class="number">3.</span>, <span class="number">2.</span>],</span><br><span class="line">        [<span class="number">2.</span>, <span class="number">1.</span>],</span><br><span class="line">        [<span class="number">4.</span>, <span class="number">2.</span>]], requires_grad=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">w.grad = </span><br><span class="line">tensor([[<span class="number">3.</span>, <span class="number">3.</span>],</span><br><span class="line">        [<span class="number">1.</span>, <span class="number">1.</span>],</span><br><span class="line">        [<span class="number">1.</span>, <span class="number">1.</span>]])</span><br></pre></td></tr></table></figure>
<p>正确的w.grad应该是：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tensor([[<span class="number">5.</span>, <span class="number">5.</span>],</span><br><span class="line">        [<span class="number">3.</span>, <span class="number">3.</span>],</span><br><span class="line">        [<span class="number">3.</span>, <span class="number">3.</span>]])</span><br></pre></td></tr></table></figure>
<p>发现运算真的将原来的x数值变化了然后再求导的（这里是将x矩阵中的所有元素都减一，可以手算一下结果是符合预期的）。</p>
<p>上述代码中，<code>x_</code>和<code>x</code>式共享一块数据空间的，改<code>x_</code>就相当于改<code>x</code>。<strong>release note 中指出, 如果想要 detach 的效果的话, 还是 detach() 安全一些.</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line">x = torch.randint(<span class="number">1</span>, <span class="number">5</span>, (<span class="number">2</span>, <span class="number">3</span>))</span><br><span class="line">x = x.type_as(torch.FloatTensor(x.shape))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;x = \n<span class="subst">&#123;x&#125;</span>\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">w = torch.randint(<span class="number">1</span>, <span class="number">5</span>, (<span class="number">3</span>, <span class="number">2</span>))</span><br><span class="line">w = w.type_as(torch.FloatTensor(w.shape))</span><br><span class="line">w.requires_grad_(<span class="literal">True</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;w = \n<span class="subst">&#123;w&#125;</span>\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">d = torch.mm(x, w)</span><br><span class="line">x_ = x.detach()</span><br><span class="line">x_ -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">d.<span class="built_in">sum</span>().backward()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;w.grad = \n<span class="subst">&#123;w.grad&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>会有报错提示。</p>
<p>参考链接：</p>
<p><a href="https://zhuanlan.zhihu.com/p/38475183">https://zhuanlan.zhihu.com/p/38475183</a></p>
<h1>下面解决《动手学深度学习》的2.5章节的第五题：</h1>
<p><img src="/2021/10/24/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/pytorch%E7%9A%84%E8%87%AA%E5%8A%A8%E6%B1%82%E5%AF%BC/%E9%A2%98%E7%9B%AE.png" alt="题目"></p>
<p>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = torch.linspace(-<span class="number">5</span>, <span class="number">5</span>, <span class="number">100</span>)</span><br><span class="line"><span class="comment"># 为x设置计算梯度</span></span><br><span class="line">x.requires_grad_(<span class="literal">True</span>)</span><br><span class="line">y = torch.sin(x)</span><br><span class="line"><span class="comment"># y反向传播,但是y是一个向量，所以需要传入参数</span></span><br><span class="line">y.backward(torch.ones_like(x))</span><br><span class="line"><span class="comment"># 这里的y.detach和下一步的x.detach</span></span><br><span class="line"><span class="comment"># 是因为里面有步骤需要使用.numpy()的转换，有计算梯度的tensor不能使用.numpy()</span></span><br><span class="line">y = y.detach()</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> utils <span class="keyword">import</span> d2l</span><br><span class="line">d2l.plot(x.detach(), [y, x.grad], <span class="string">&#x27;f(x)&#x27;</span>, <span class="string">&quot;f&#x27;(x)&quot;</span>, legend=[<span class="string">&#x27;f(x)&#x27;</span>, <span class="string">&#x27;Tangent line&#x27;</span>])</span><br><span class="line">d2l.plt.show()</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<p><img src="/2021/10/24/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/pytorch%E7%9A%84%E8%87%AA%E5%8A%A8%E6%B1%82%E5%AF%BC/%E6%9B%B2%E7%BA%BF.png" alt="曲线"></p>
<p><strong>参考</strong>：</p>
<p><a href="https://towardsdatascience.com/pytorch-autograd-understanding-the-heart-of-pytorchs-magic-2686cd94ec95">PyTorch Autograd</a></p>
<p><a href="https://blog.csdn.net/qq_39208832/article/details/117415229">grad can be implicitly created only for scalar outputs</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/83172023">Pytorch autograd,backward详解</a></p>
]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
        <tag>torch</tag>
      </tags>
  </entry>
  <entry>
    <title>python高级编程-part1</title>
    <url>/2021/10/23/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/python%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B-part1/</url>
    <content><![CDATA[<h1>outline</h1>
<p><strong>函数与函数式编程：</strong></p>
<ul>
<li>一等函数</li>
<li>把函数视为对象</li>
<li>高阶函数</li>
<li>列表推导 vs (map/reduce)</li>
<li>函数的参数与返回值</li>
</ul>
<p><strong>方法和装饰器：</strong></p>
<ul>
<li>有用的装饰器</li>
<li>由简单到复杂实现各类装饰器</li>
</ul>
<span id="more"></span>
<h1>一等函数</h1>
<p><strong>特点：</strong></p>
<ol>
<li>可以运行的时候创建；</li>
<li>可以作为变量，传给函数；</li>
<li>可以作为函数的返回结果。</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">factorial</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    return n!</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> <span class="keyword">if</span> n &lt; <span class="number">2</span> <span class="keyword">else</span> factorial(n - <span class="number">1</span>) * n</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(factorial(<span class="number">5</span>))</span><br></pre></td></tr></table></figure>
<p>既然是对象，就有相应的属性，且可以赋值：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 函数对象的属性</span></span><br><span class="line"><span class="built_in">print</span>(factorial.__doc__)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(factorial))</span><br><span class="line"><span class="comment"># 既然是一个函数对象，那么就可以赋值</span></span><br><span class="line">fact = factorial</span><br><span class="line"><span class="built_in">print</span>(fact)</span><br><span class="line"><span class="built_in">print</span>(fact(<span class="number">5</span>))</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">    <span class="keyword">return</span> n!</span><br><span class="line">    </span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">function</span>&#x27;&gt;</span></span><br><span class="line"><span class="class">&lt;<span class="title">function</span> <span class="title">factorial</span> <span class="title">at</span> 0<span class="title">x00000184B923F288</span>&gt;</span></span><br><span class="line"><span class="class">120</span></span><br></pre></td></tr></table></figure>
<p>为了更好的理解函数作为对象的特征，可以看看下面这个例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 嵌套函数返回函数对象</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_averager</span>():</span></span><br><span class="line">    nums = []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">averager</span>(<span class="params">new_value</span>):</span></span><br><span class="line">        nums.append(new_value)</span><br><span class="line">        total = <span class="built_in">sum</span>(nums)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> total / <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="keyword">return</span> averager</span><br></pre></td></tr></table></figure>
<p>外层函数返回的是函数的对象，这样一来经过下面的测试可以得到预期结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">avg = make_averager()</span><br><span class="line"><span class="built_in">print</span>(avg)</span><br><span class="line"><span class="built_in">print</span>(avg(<span class="number">3</span>))</span><br></pre></td></tr></table></figure>
<p>输出结果如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&lt;function make_averager.&lt;<span class="built_in">locals</span>&gt;.averager at <span class="number">0x00000184B923FDC8</span>&gt;</span><br><span class="line"><span class="number">3.0</span></span><br></pre></td></tr></table></figure>
<h1>高阶函数</h1>
<p>**特点：**接受函数作为参数或者函数作为返回结果。eg:map/reduce，sorted。</p>
<p>map/reduce/filter就是典型的高阶函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">num_list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>]</span><br><span class="line"><span class="comment"># map需要传入一个函数对象</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(<span class="built_in">map</span>(factorial, num_list)))</span><br></pre></td></tr></table></figure>
<p>输出：<code>[1, 2, 6, 24, 120, 5040, 362880]</code></p>
<p>reduce和map的区别是，map只允许传入的函数只能接受1个参数，而reduce可以接受两个参数，如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line"></span><br><span class="line">lyst = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> x: x**<span class="number">2</span>, lyst)))</span><br><span class="line"><span class="built_in">print</span>(reduce(<span class="keyword">lambda</span> x, y: x + y, lyst))</span><br></pre></td></tr></table></figure>
<p><strong>注意reduce返回的是一个值，而不是一个可迭代对象。</strong></p>
<p>对于常见的加减乘除，还可以使用这种方式来实现：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> partial</span><br><span class="line"><span class="keyword">from</span> operator <span class="keyword">import</span> add, mul</span><br><span class="line">op_mul = partial(mul, <span class="number">3</span>)</span><br><span class="line">op_mul(<span class="number">9</span>)</span><br></pre></td></tr></table></figure>
<p>这个op_mul就相当于一个乘法运算对象，而且其中有一个值固定为3，现在就传入另外一个值即可。从这里就可以看出来partial的作用：</p>
<p><strong>对于一个函数，如果有几个参数是确定的，但是还有一部分不确定，可以将确定的参数传入，然后借助partial函数，将这个传入了几个确定参数之后的函数作为一个新的函数，接下来只用将剩余的参数传入这个新的函数即可。</strong></p>
<p>字典实现列表推导式：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 字典的列表推导式</span></span><br><span class="line">usernames = [<span class="string">&#x27;sophia&#x27;</span>, <span class="string">&#x27;emma&#x27;</span>, <span class="string">&#x27;olivia&#x27;</span>, <span class="string">&#x27;ava&#x27;</span>]</span><br><span class="line">name_dict = &#123;name: <span class="built_in">len</span>(name) <span class="keyword">for</span> name <span class="keyword">in</span> usernames&#125;</span><br><span class="line"><span class="built_in">print</span>(name_dict)</span><br></pre></td></tr></table></figure>
<p>输出结果如下：</p>
<p><code>&#123;'sophia': 6, 'emma': 4, 'olivia': 6, 'ava': 3&#125;</code></p>
<p>嵌套高阶函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 嵌套高阶函数</span></span><br><span class="line"><span class="comment"># 首先将num_list中的偶数筛选掉</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(<span class="built_in">map</span>(factorial, <span class="built_in">filter</span>(<span class="keyword">lambda</span> n: n % <span class="number">2</span>, num_list))))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用列表推导式实现上述功能</span></span><br><span class="line">result = [factorial(num) <span class="keyword">for</span> num <span class="keyword">in</span> num_list <span class="keyword">if</span> num % <span class="number">2</span>]</span><br><span class="line"><span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<p><code>[1, 6, 120, 5040, 362880]</code></p>
<p><code>[1, 6, 120, 5040, 362880]</code></p>
<h1>python单下划线和双下划的区别</h1>
<p>python下划线有5种：</p>
<table>
<thead>
<tr>
<th>模式</th>
<th>样例</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>单前导下划线</td>
<td><code>_xxx</code></td>
<td>约定俗成，仅供类内使用，外部不调用，但是强制调用还是可以的</td>
</tr>
<tr>
<td>双前导下划线</td>
<td><code>__xxx</code></td>
<td>强制不可外部调用，如果是函数，那么函数所在的类的子类无法轻易重写该函数</td>
</tr>
<tr>
<td>单末尾下划线</td>
<td><code>xxx_</code></td>
<td>防止和python内置关键字冲突</td>
</tr>
<tr>
<td>双前导和末尾下划线</td>
<td><code>__xxx__</code></td>
<td>python语义的特殊方法，尽量避免自己使用</td>
</tr>
<tr>
<td>单下划线</td>
<td><code>_</code></td>
<td>较多的用法是，该变量在下面的作用域内不会使用到</td>
</tr>
</tbody>
</table>
<p>下面就这几种模式来举一下例子：</p>
<p><strong>单前导下划线：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>():</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self._name = <span class="string">&quot;julia&quot;</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">a = A()</span><br><span class="line"><span class="comment"># 约定俗成，仅供类内使用，外部不调用，但是强制调用还是可以的</span></span><br><span class="line"><span class="built_in">print</span>(a._name)</span><br></pre></td></tr></table></figure>
<p>输出：julia</p>
<p><strong>双前导下划线：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>():</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.__name = <span class="string">&quot;julia&quot;</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">a = A()</span><br><span class="line"><span class="comment"># 强制不可外部调用</span></span><br><span class="line"><span class="built_in">print</span>(a.__name)</span><br></pre></td></tr></table></figure>
<p>报错：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">---------------------------------------------------------------------------</span><br><span class="line">AttributeError                            Traceback (most recent call last)</span><br><span class="line">&lt;ipython-<span class="built_in">input</span>-<span class="number">24</span>-a75c7bdbf94f&gt; <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">      <span class="number">4</span>         <span class="keyword">pass</span></span><br><span class="line">      <span class="number">5</span> a = A()</span><br><span class="line">----&gt; <span class="number">6</span> <span class="built_in">print</span>(a.__name)</span><br><span class="line"></span><br><span class="line">AttributeError: <span class="string">&#x27;A&#x27;</span> <span class="built_in">object</span> has no attribute <span class="string">&#x27;__name&#x27;</span></span><br></pre></td></tr></table></figure>
<p>如果是带双前导下划线的函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>():</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.__name = <span class="string">&quot;julia&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getname</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.__name</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>(<span class="params">A</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getname</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">dir</span>(A))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">dir</span>(B))</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[<span class="string">&#x27;_A__getname&#x27;</span>, <span class="string">&#x27;__class__&#x27;</span>, <span class="string">&#x27;__delattr__&#x27;</span>, <span class="string">&#x27;__dict__&#x27;</span>, <span class="string">&#x27;__dir__&#x27;</span>, <span class="string">&#x27;__doc__&#x27;</span>, <span class="string">&#x27;__eq__&#x27;</span>, <span class="string">&#x27;__format__&#x27;</span>, <span class="string">&#x27;__ge__&#x27;</span>, <span class="string">&#x27;__getattribute__&#x27;</span>, <span class="string">&#x27;__gt__&#x27;</span>, <span class="string">&#x27;__hash__&#x27;</span>, <span class="string">&#x27;__init__&#x27;</span>, <span class="string">&#x27;__init_subclass__&#x27;</span>, <span class="string">&#x27;__le__&#x27;</span>, <span class="string">&#x27;__lt__&#x27;</span>, <span class="string">&#x27;__module__&#x27;</span>, <span class="string">&#x27;__ne__&#x27;</span>, <span class="string">&#x27;__new__&#x27;</span>, <span class="string">&#x27;__reduce__&#x27;</span>, <span class="string">&#x27;__reduce_ex__&#x27;</span>, <span class="string">&#x27;__repr__&#x27;</span>, <span class="string">&#x27;__setattr__&#x27;</span>, <span class="string">&#x27;__sizeof__&#x27;</span>, <span class="string">&#x27;__str__&#x27;</span>, <span class="string">&#x27;__subclasshook__&#x27;</span>, <span class="string">&#x27;__weakref__&#x27;</span>]</span><br><span class="line">[<span class="string">&#x27;_A__getname&#x27;</span>, <span class="string">&#x27;_B__getname&#x27;</span>, <span class="string">&#x27;__class__&#x27;</span>, <span class="string">&#x27;__delattr__&#x27;</span>, <span class="string">&#x27;__dict__&#x27;</span>, <span class="string">&#x27;__dir__&#x27;</span>, <span class="string">&#x27;__doc__&#x27;</span>, <span class="string">&#x27;__eq__&#x27;</span>, <span class="string">&#x27;__format__&#x27;</span>, <span class="string">&#x27;__ge__&#x27;</span>, <span class="string">&#x27;__getattribute__&#x27;</span>, <span class="string">&#x27;__gt__&#x27;</span>, <span class="string">&#x27;__hash__&#x27;</span>, <span class="string">&#x27;__init__&#x27;</span>, <span class="string">&#x27;__init_subclass__&#x27;</span>, <span class="string">&#x27;__le__&#x27;</span>, <span class="string">&#x27;__lt__&#x27;</span>, <span class="string">&#x27;__module__&#x27;</span>, <span class="string">&#x27;__ne__&#x27;</span>, <span class="string">&#x27;__new__&#x27;</span>, <span class="string">&#x27;__reduce__&#x27;</span>, <span class="string">&#x27;__reduce_ex__&#x27;</span>, <span class="string">&#x27;__repr__&#x27;</span>, <span class="string">&#x27;__setattr__&#x27;</span>, <span class="string">&#x27;__sizeof__&#x27;</span>, <span class="string">&#x27;__str__&#x27;</span>, <span class="string">&#x27;__subclasshook__&#x27;</span>, <span class="string">&#x27;__weakref__&#x27;</span>]</span><br></pre></td></tr></table></figure>
<p>这里的<code>__getname</code>函数是带前导双下划线的函数，第一个输出的时候，发现<code>__getname</code>的名称前面添加了<code>_A</code>，B类也有一个自己的函数<code>_B__getname</code>，在python中这种用法是为了避免和子类定义的函数名称冲突。</p>
<p><strong>单末尾下划线：</strong></p>
<p>这种用法是为了避免定义的变量和python的关键字冲突，比如<code>class</code>，这个时候可以使用<code>class_</code>来代替。</p>
<p><strong>单下划线：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;000&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>比如这种情况就没有使用到循环变量，可以使用_来代替。</p>
<p>参考：<a href="https://blog.csdn.net/sinat_38682860/article/details/96902828">https://blog.csdn.net/sinat_38682860/article/details/96902828</a></p>
<h1>函数参数的特殊情况</h1>
<p>下面需要实现一个html标签，如<code>&lt;p&gt;hello&lt;/p&gt;</code>，<code>&lt;item class='' size='small'&gt;a&lt;/item&gt;</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_element</span>(<span class="params">name, *contents, cls=<span class="literal">None</span>, **kwargs</span>):</span></span><br><span class="line">    <span class="keyword">if</span> cls:</span><br><span class="line">        kwargs[<span class="string">&#x27;class&#x27;</span>] = cls</span><br><span class="line">    </span><br><span class="line">    pairs = [<span class="string">f&quot;<span class="subst">&#123;attr&#125;</span>=<span class="subst">&#123;value&#125;</span>&quot;</span> <span class="keyword">for</span> attr, value <span class="keyword">in</span> kwargs.items()]</span><br><span class="line">    attr_str = <span class="string">&#x27; &#x27;</span>.join(pairs)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> contents:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;&lt;<span class="subst">&#123;name&#125;</span> <span class="subst">&#123;attr_str&#125;</span>/&gt;&quot;</span></span><br><span class="line">    </span><br><span class="line">    elements = [<span class="string">f&quot;&lt;<span class="subst">&#123;name&#125;</span> <span class="subst">&#123;attr_str&#125;</span>&gt;<span class="subst">&#123;content&#125;</span>&lt;<span class="subst">&#123;name&#125;</span>/&gt;&quot;</span> <span class="keyword">for</span> content <span class="keyword">in</span> contents]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;\n&#x27;</span>.join(elements)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(make_element(<span class="string">&quot;p&quot;</span>, <span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>, cls=<span class="string">&quot;sidebar&quot;</span>, size=<span class="string">&quot;small&quot;</span>))</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&lt;p size=small <span class="class"><span class="keyword">class</span>=<span class="title">sidebar</span>&gt;<span class="title">hello</span>&lt;<span class="title">p</span>/&gt;</span></span><br><span class="line"><span class="class">&lt;<span class="title">p</span> <span class="title">size</span>=<span class="title">small</span> <span class="title">class</span>=<span class="title">sidebar</span>&gt;<span class="title">world</span>&lt;<span class="title">p</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>因为class是python中的关键字，传入函数的话会冲突，所以将cls特意拿出来接受class参数。现在想设计一个专门生成图片标签的函数，可以利用前面说到的partial函数，代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> partial</span><br><span class="line"></span><br><span class="line">image_make = partial(make_element, <span class="string">&quot;img&quot;</span>, cls=<span class="string">&quot;pic-frame&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(image_make(src=<span class="string">&quot;car.png&quot;</span>))</span><br><span class="line"></span><br><span class="line">item_make = partial(make_element, <span class="string">&quot;item&quot;</span>, size=<span class="string">&quot;small&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(item_make(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>))</span><br></pre></td></tr></table></figure>
<p>输出:</p>
<p><code>&lt;img src=car.png class=pic-frame/&gt; </code></p>
<p><code>&lt;item size=small&gt;A&lt;item/&gt; </code></p>
<p><code>&lt;item size=small&gt;B&lt;item/&gt; </code></p>
<p><code>&lt;item size=small&gt;C&lt;item/&gt;</code></p>
<p>这种涉及到的特殊参数是<code>*contents</code>和<code>**kwargs</code>，传入函数之后，contents是一个元组，kwargs是一个字典，如果需要对元组和字典进行解包，可以使用如下的方式：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># *解包元组</span></span><br><span class="line">a = (<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(*a)</span><br><span class="line"><span class="comment"># **解包字典</span></span><br><span class="line">dict_a = &#123;<span class="string">&quot;a&quot;</span>: <span class="number">1</span>, <span class="string">&quot;b&quot;</span>: <span class="number">2</span>&#125;</span><br><span class="line">dict_b = &#123;<span class="string">&quot;c&quot;</span>: <span class="number">3</span>, <span class="string">&quot;d&quot;</span>: <span class="number">4</span>&#125;</span><br><span class="line">new_dict = &#123;**dict_a, **dict_b&#125;</span><br><span class="line"><span class="built_in">print</span>(new_dict)</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<p><code>2 3 4 5 </code></p>
<p><code>&#123;'a': 1, 'b': 2, 'c': 3, 'd': 4&#125;</code></p>
<h1>装饰器</h1>
<p>装饰器的本质：在不改变函数签名、返回值的情况下，增加额外的功能。</p>
<h3 id="带运行时间的装饰器">带运行时间的装饰器</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">build_func_with_time_record</span>(<span class="params">func</span>):</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">        start = time.time()</span><br><span class="line">        result = func(*args, **kwargs)</span><br><span class="line">        end = time.time()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;function <span class="subst">&#123;func.__name__&#125;</span> cost <span class="subst">&#123;end - start&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func_foo</span>(<span class="params">a, b</span>):</span></span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(a + b)</span><br><span class="line"></span><br><span class="line">new_func = build_func_with_time_record(func_foo)</span><br><span class="line">new_func(<span class="number">1</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<p>这段代码实现的就是在<code>func_foo</code>函数的基础上，再“装饰”一下，实现装饰功能的函数是<code>build_func_with_time_record</code>。</p>
<p>python提供了<code>@语法糖</code>来简化上述的“装饰”过程，使用<code>@</code>关键字可以将上述代码简化为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">build_func_with_time_record</span>(<span class="params">func</span>):</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">        start = time.time()</span><br><span class="line">        result = func(*args, **kwargs)</span><br><span class="line">        end = time.time()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;function <span class="subst">&#123;func.__name__&#125;</span> cost <span class="subst">&#123;end - start&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@build_func_with_time_record</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func_foo</span>(<span class="params">a, b</span>):</span></span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(a + b)</span><br><span class="line"></span><br><span class="line">func_foo(<span class="number">1</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<p>通过这种方式可以省去显示的将函数传入、赋值等操作。注意，上述的函数有参数a，b。参数不是通过<code>build_func_with_time_record</code>传入的，而是通过里面的<code>wrapper</code>函数传入的。</p>
<p>这样，可以将这个装饰器加在上述的<code>make_element</code>函数上：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@build_func_with_time_record</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_element</span>(<span class="params">name, *contents, cls=<span class="literal">None</span>, **kwargs</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;make HTML element</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        name (label name): such as p</span></span><br><span class="line"><span class="string">        cls (str, optional): make a distinction with class. Defaults to None.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">        str: the results</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> cls:</span><br><span class="line">        kwargs[<span class="string">&#x27;class&#x27;</span>] = cls</span><br><span class="line">    </span><br><span class="line">    pairs = [<span class="string">f&quot;<span class="subst">&#123;attr&#125;</span>=<span class="subst">&#123;value&#125;</span>&quot;</span> <span class="keyword">for</span> attr, value <span class="keyword">in</span> kwargs.items()]</span><br><span class="line">    attr_str = <span class="string">&#x27; &#x27;</span>.join(pairs)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> contents:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;&lt;<span class="subst">&#123;name&#125;</span> <span class="subst">&#123;attr_str&#125;</span>/&gt;&quot;</span></span><br><span class="line">    </span><br><span class="line">    elements = [<span class="string">f&quot;&lt;<span class="subst">&#123;name&#125;</span> <span class="subst">&#123;attr_str&#125;</span>&gt;<span class="subst">&#123;content&#125;</span>&lt;<span class="subst">&#123;name&#125;</span>/&gt;&quot;</span> <span class="keyword">for</span> content <span class="keyword">in</span> contents]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;\n&#x27;</span>.join(elements)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(make_element(<span class="string">&quot;p&quot;</span>, <span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>, cls=<span class="string">&quot;sidebar&quot;</span>, size=<span class="string">&quot;small&quot;</span>))</span><br></pre></td></tr></table></figure>
<p>输出如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">function make_element cost <span class="number">0.0</span></span><br><span class="line">&lt;p size=small <span class="class"><span class="keyword">class</span>=<span class="title">sidebar</span>&gt;<span class="title">hello</span>&lt;<span class="title">p</span>/&gt;</span></span><br><span class="line"><span class="class">&lt;<span class="title">p</span> <span class="title">size</span>=<span class="title">small</span> <span class="title">class</span>=<span class="title">sidebar</span>&gt;<span class="title">world</span>&lt;<span class="title">p</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>但是，此时我们再输出函数属性：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(make_element.__doc__)</span><br><span class="line"><span class="built_in">print</span>(make_element.__name__)</span><br><span class="line"><span class="comment"># 测试一下函数签名：</span></span><br><span class="line"><span class="keyword">from</span> inspect <span class="keyword">import</span> signature</span><br><span class="line">signature(make_element)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="literal">None</span></span><br><span class="line">wrapper</span><br><span class="line">&lt;Signature (*args, **kwargs)&gt;</span><br></pre></td></tr></table></figure>
<p>发现<strong>函数的属性</strong>和<strong>函数签名</strong>都发生了变化，我们回到不使用<code>@</code>关键字实现装饰器功能的代码上，发现<code>build_func_with_time_record</code>函数返回值就是wrapper函数对象，所以最后我们得到的不再是一开始的<code>make_element</code>函数了，那么有什么方法能解决这个问题呢？</p>
<p>需要将一开始的<code>build_func_with_time_record</code>做一下修改：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">build_func_with_time_record</span>(<span class="params">func</span>):</span></span><br><span class="line">    </span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    wraps在装饰器函数返回之前</span></span><br><span class="line"><span class="string">    通过获取func的属性</span></span><br><span class="line"><span class="string">    并存储在返回的最终函数中设置上述属性。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"><span class="meta">    @wraps(<span class="params">func</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">        start = time.time()</span><br><span class="line">        result = func(*args, **kwargs)</span><br><span class="line">        end = time.time()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;function <span class="subst">&#123;func.__name__&#125;</span> cost <span class="subst">&#123;end - start&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br></pre></td></tr></table></figure>
<p>然后重新尝试一下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(make_element.__doc__)</span><br><span class="line"><span class="built_in">print</span>(make_element.__name__)</span><br><span class="line"><span class="comment"># 测试一下函数签名：</span></span><br><span class="line"><span class="keyword">from</span> inspect <span class="keyword">import</span> signature</span><br><span class="line">signature(make_element)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">make HTML element</span><br><span class="line"></span><br><span class="line">    Args:</span><br><span class="line">        name (label name): such <span class="keyword">as</span> p</span><br><span class="line">        cls (<span class="built_in">str</span>, optional): make a distinction <span class="keyword">with</span> <span class="keyword">class</span>. Defaults to <span class="literal">None</span>.</span><br><span class="line"></span><br><span class="line">    Returns:</span><br><span class="line">        <span class="built_in">str</span>: the results</span><br><span class="line">    </span><br><span class="line">make_element</span><br><span class="line">&lt;Signature (name, *contents, cls=<span class="literal">None</span>, **kwargs)&gt;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>python高级编程</category>
      </categories>
      <tags>
        <tag>python高级编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker入门</title>
    <url>/2021/10/12/Docker/Docker%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h1>Docker学习网站</h1>
<p>推荐狂神的Docker视频：</p>
<p><a href="https://www.bilibili.com/video/BV1og4y1q7M4?p=2">https://www.bilibili.com/video/BV1og4y1q7M4?p=2</a></p>
<p>Docker官网：</p>
<p><a href="https://www.docker.com/">https://www.docker.com/</a></p>
<p>文档地址：</p>
<p><a href="https://docs.docker.com/">https://docs.docker.com/</a></p>
<p>仓库地址：</p>
<p><a href="https://hub.docker.com/">https://hub.docker.com/</a></p>
<h1>Docker为什么会出现</h1>
<p>配置环境十分麻烦，每一个机器都需要部署环境，费时费力，且不能跨平台。</p>
<p>传统开发jar，运维来做；现在开发打包和部署上线，一套流程做完。</p>
<p>Docker解决的问题：发布一个项目（jar+Redis+MySQL+jdk+ES），项目能否带上环境安装打包？</p>
<p>Docker可以通过隔离机制，将服务器利用到极致。</p>
<p>传统的虚拟机模拟一台电脑出来，将操作系统的内核、库包含进去，应用直接运行在其上就行。但是有如下缺点：</p>
<ol>
<li>资源占用多；</li>
<li>冗余步骤多（如开机）；</li>
<li>启动很慢。</li>
</ol>
<p>而容器化技术不是模拟的一个完整的操作系统。</p>
<h1>Docker能干嘛</h1>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>miniconda+tf2.x_gpu+torch_gpu环境配置</title>
    <url>/2021/10/08/%E9%85%8D%E7%8E%AF%E5%A2%83/miniconda+tf2_gpu+torch_gpu%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h1>情况描述</h1>
<p>需要运行联邦学习图神经网络，同时需要torch和tf2.x，运行图神经网络还用到了stellargraph库，这个库依赖于tf，而且要求tf版本&gt;=2.1.0，在代码内部还用到了keras，需要keras和tf版本相匹配。</p>
<span id="more"></span>
<h1>版本适配</h1>
<p>首先弄清需要安装的包：torch, tf2.x, stellargraph, cudatoolkit, cudnn。</p>
<p>为了不让自己所需要的cuda环境影响到服务器中其他用户的使用，我通过conda安装cudatoolkit来解决。</p>
<p>通过查找发现，torch和tf2.x共用同一个版本的cuda而且tf版本&gt;2.1.0的就发现一个：CUDA 10.1</p>
<p>当然我只是通过官方提供的下载指令查找的，如果还是找不到自己需要的版本适配，可以通过<a href="https://download.pytorch.org/whl/torch_stable.html">这个网址</a>自己凑出来torch、torchvision、cuda版本（我没试过，可以尝试一下）。</p>
<p><strong>下面提供官方下载指令，但是不是下载流程，下载流程请继续往下看。</strong></p>
<p>官方下载torch指令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">conda install pytorch==1.7.1 torchvision==0.8.2 torchaudio==0.7.2 cudatoolkit=10.1 -c pytorch</span><br></pre></td></tr></table></figure>
<p>下载tf2.3指令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip install tensorflow-gpu==2.3.1</span><br></pre></td></tr></table></figure>
<h1>安装流程</h1>
<h2 id="安装miniconda：">安装miniconda：</h2>
<p>下载安装包：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget -c https://mirrors.tuna.tsinghua.edu.cn/anaconda/miniconda/Miniconda3-4.6.14-Linux-x86_64.sh</span><br></pre></td></tr></table></figure>
<p>安装miniconda:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bash Miniconda3-4.6.14-Linux-x86_64.sh</span><br></pre></td></tr></table></figure>
<p>安装过程中注意这一步选择yes，不要一直回车给按过去了：</p>
<p><img src="/2021/10/08/%E9%85%8D%E7%8E%AF%E5%A2%83/miniconda+tf2_gpu+torch_gpu%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/miniconda%E5%AE%89%E8%A3%85%E6%B3%A8%E6%84%8F%E7%82%B9.png" alt="miniconda安装注意点"></p>
<p>安装好了之后，可以看到miniconda3的目录路径，比如我的是：/home/me/miniconda3。</p>
<p>输入<code>vi ~/.bashrc</code>，在文件底下插入如下内容：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export PATH=~/home/me/miniconda3/bin:$PATH</span><br></pre></td></tr></table></figure>
<p>然后激活环境变量：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">source ~/.bashrc</span><br></pre></td></tr></table></figure>
<p>即可通过<code>conda --version</code>查看版本。</p>
<h2 id="添加镜像">添加镜像</h2>
<p><strong>添加pip镜像：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir ~/.pip</span><br><span class="line">cd ~/.pip</span><br><span class="line">touch pip.conf</span><br><span class="line">vi ~/.pip/pip.conf</span><br></pre></td></tr></table></figure>
<p>将下面的清华镜像加入该文件并保存：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[global]</span><br><span class="line">timeout = 60000</span><br><span class="line">index-url = https://pypi.tuna.tsinghua.edu.cn/simple</span><br><span class="line">[install]</span><br><span class="line">use-mirrors = true</span><br><span class="line">mirrors = https://pypi.tuna.tsinghua.edu.cn</span><br></pre></td></tr></table></figure>
<p><strong>添加conda镜像：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">conda config --set show_channel_urls yes</span><br><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/</span><br><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/</span><br></pre></td></tr></table></figure>
<h2 id="创建新的虚拟环境">创建新的虚拟环境</h2>
<p>创建名为cuda101，python版本为3.7.5的虚拟环境：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">conda create -n cuda101 python=3.7.5</span><br></pre></td></tr></table></figure>
<h2 id="安装相关包">安装相关包</h2>
<p><strong>安装下面几个包的顺序非常重要。</strong></p>
<p>先安装pytorch，下面的指令会顺带下载cudatoolkit 10.1：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">conda install pytorch==1.7.1 torchvision==0.8.2 torchaudio==0.7.2 cudatoolkit=10.1 -c pytorch</span><br></pre></td></tr></table></figure>
<p>然后下载tf：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip install tensorflow-gpu==2.3.1</span><br></pre></td></tr></table></figure>
<p>安装stellargraph：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip install stellargraph</span><br></pre></td></tr></table></figure>
<p>安装keras：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip install keras==2.4.3</span><br></pre></td></tr></table></figure>
<p>安装cudnn：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">conda install cudnn=7.6.5</span><br></pre></td></tr></table></figure>
<p>然后可以试试导入tf和torch是否成功了。</p>
<p>【参考】</p>
<p><a href="https://blog.csdn.net/weixin_43141320/article/details/107955115">https://blog.csdn.net/weixin_43141320/article/details/107955115</a></p>
<p><a href="https://blog.csdn.net/weixin_43141320/article/details/108343528">https://blog.csdn.net/weixin_43141320/article/details/108343528</a></p>
<p><a href="https://tensorflow.google.cn/install/source">https://tensorflow.google.cn/install/source</a></p>
<p><a href="https://blog.csdn.net/qq_37774098/article/details/109895048">https://blog.csdn.net/qq_37774098/article/details/109895048</a></p>
<p><a href="https://blog.csdn.net/qq_42406643/article/details/109545766?utm_medium=distribute.pc_relevant.none-task-blog-baidulandingword-2&amp;spm=1001.2101.3001.4242">https://blog.csdn.net/qq_42406643/article/details/109545766?utm_medium=distribute.pc_relevant.none-task-blog-baidulandingword-2&amp;spm=1001.2101.3001.4242</a></p>
<p><a href="https://pytorch.org/get-started/previous-versions/">https://pytorch.org/get-started/previous-versions/</a></p>
<p><a href="https://tensorflow.google.cn/install/source_windows#gpu">https://tensorflow.google.cn/install/source_windows#gpu</a></p>
<p><a href="https://pypi.org/project/stellargraph/#install-stellargraph-in-anaconda-python">https://pypi.org/project/stellargraph/#install-stellargraph-in-anaconda-python</a></p>
]]></content>
      <categories>
        <category>环境配置</category>
      </categories>
      <tags>
        <tag>环境配置</tag>
      </tags>
  </entry>
  <entry>
    <title>入门与FedML框架使用</title>
    <url>/2021/10/06/%E8%81%94%E9%82%A6%E5%AD%A6%E4%B9%A0/%E5%85%A5%E9%97%A8%E4%B8%8EFedML%E6%A1%86%E6%9E%B6%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1>Why federated learning?</h1>
<span id="more"></span>
<p>现阶段深度学习大多是集中式训练。多个客户端将数据标注并上传至云服务器，服务器集中训练模型，最后将训练的模型部署到客户端。如下图所示（图来自：<a href="https://blog.csdn.net/lgzlgz3102/article/details/117433511">https://blog.csdn.net/lgzlgz3102/article/details/117433511</a>)。这种中心化的训练模式面临许多困难，<strong>数据隐私方面</strong>：多个客户采集的数据不愿分享的情况，数据的割裂导致只能利用本地的数据进行单点建模，模型效果自然明显下降；<strong>模型更新方面</strong>：传统的处理方式需要将数据集中上传到中心数据库，进行统一的数据处理和模型训练，然后进行模型的评估和部署，由于各个数据院之间的网络性能和设备性能的差异，导致数据同步不一致，整个流程会持续较长的时间，无法满足实时响应的场景。</p>
<p><img src="/2021/10/06/%E8%81%94%E9%82%A6%E5%AD%A6%E4%B9%A0/%E5%85%A5%E9%97%A8%E4%B8%8EFedML%E6%A1%86%E6%9E%B6%E4%BD%BF%E7%94%A8/%E9%9B%86%E4%B8%AD%E5%BC%8F%E8%AE%AD%E7%BB%83.png" alt="集中式训练"></p>
<h1>The work of federated learning?</h1>
<p>各个用户之间，数据不可见，所以各自利用各自的数据进行训练，然后将模型的参数上传至服务器，服务器整合并将更新的模型参数下发给其他的所有节点，再次进行上述步骤，直至拟合。</p>
<p><img src="/2021/10/06/%E8%81%94%E9%82%A6%E5%AD%A6%E4%B9%A0/%E5%85%A5%E9%97%A8%E4%B8%8EFedML%E6%A1%86%E6%9E%B6%E4%BD%BF%E7%94%A8/%E8%81%94%E9%82%A6%E5%AD%A6%E4%B9%A0%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F.png" alt="联邦学习的工作模式"></p>
<h1>联邦学习论文的研究侧重点统计</h1>
<p><img src="/2021/10/06/%E8%81%94%E9%82%A6%E5%AD%A6%E4%B9%A0/%E5%85%A5%E9%97%A8%E4%B8%8EFedML%E6%A1%86%E6%9E%B6%E4%BD%BF%E7%94%A8/%E6%96%B9%E5%90%91%E8%A1%A8%E6%A0%BC%E7%BB%9F%E8%AE%A1.png" alt="方向表格统计"></p>
<h1>Challenges</h1>
<p>客户端的optimizer和server端的optimizer是否能互相配合使用，从而让效果更好；</p>
<p>不同的客户端的计算能力不同，所以设定迭代次数k会导致互相等待，能否根据不同的机器设置不同的迭代次数k，从而让效果较优。这就是k异构下如何优化的问题。</p>
<p>如果有些客户端是手机，需要训练的是ResNet模型，如果直接用手机来训练显然不合适，那么如何解决这个问题。</p>
<p><a href="https://arxiv.org/abs/2007.13518">FedML:A Research Library and Benchmark for Federated Machine Learning</a></p>
<p><a href="https://fedml.ai/files/FedCV.pdf">FedCV: A Federated Learning Framework for Diverse Computer Vision Tasks</a></p>
]]></content>
      <categories>
        <category>联邦学习</category>
      </categories>
      <tags>
        <tag>联邦学习</tag>
        <tag>FedML</tag>
      </tags>
  </entry>
  <entry>
    <title>王争数据结构与算法学习笔记-动态规划</title>
    <url>/2021/09/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%8E%8B%E4%BA%89%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>王争数据结构与算法学习笔记-回溯算法</title>
    <url>/2021/09/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%8E%8B%E4%BA%89%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>2004 年上映了一部非常著名的电影《蝴蝶效应》，讲的就是主人公为了达到自己的目标，一直通过回溯的方法，回到童年，在关键的岔路口，重新做选择。当然，这只是科幻电影，我们的人生是无法倒退的，但是这其中蕴含的思想其实就是回溯算法。</p>
<span id="more"></span>
<p>深度优先搜索算法利用的是回溯算法思想，它除了用来指导像深度优先搜索这种经典的算法设计之外，还可以用在很多实际的软件开发场景中，比如正则表达式匹配、编译原理中的语法分析等。除此之外，很多经典的数学问题都可以用回溯算法解决，比如数独、八皇后、0-1 背包、图的着色、旅行商问题、全排列、正则表达式匹配等等。</p>
<p>回溯的处理思想，有点类似枚举搜索。我们枚举所有的解，找到满足期望的解。为了有规律地枚举所有可能的解，避免遗漏和重复，我们把问题求解的过程分为多个阶段。每个阶段，我们都会面对一个岔路口，我们先随意选一条路走，当发现这条路走不通的时候（不符合期望的解），就回退到上一个岔路口，另选一种走法继续走。</p>
<p>回溯算法非常适合用递归来实现，<strong>在实现的过程中，剪枝操作是提高回溯效率的一种技巧。利用剪枝，我们并不需要穷举搜索所有的情况，从而提高搜索效率。</strong></p>
<h1>回溯算法解决八皇后问题</h1>
<p>有一个8x8的棋盘，希望往里面放8个棋子，每个棋子所在的行、列、对角线都不能有另一个棋子，求满足要求的所有摆放方式。</p>
<p>我们把这个问题划分成 8 个阶段，依次将 8 个棋子放到第一行、第二行、第三行……第八行。在放置的过程中，我们不停地检查当前放法，是否满足要求。如果满足，则跳到下一行继续放置棋子；如果不满足，那就再换一种放法，继续尝试。</p>
<h1>两个回溯算法的经典应用</h1>
<h2 id="0-1背包问题">0-1背包问题</h2>
<p>假设有一个背包，背包的总的承载重量是Wkg，有n个物品，每个物品的重量不等，而且不可分割。现在期望选择几件物品，装在背包中，在不超过背包锁能承载重量的前提下，如何让背包中物品总的重量最大？</p>
<p>在贪心算法中举了一个物品可以分割的背包问题，即可以装某个物体的一部分到背包中，现在的问题是物品不可分割，要么装要么不装，显然这个问题无法通过贪心算法来解决。</p>
<p>对于每个物品都有两种选择，装进背包或者不装进背包，对于n个物品来说，总的装法就有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">2^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span></span></span>种，去掉总重量超过Wkg的，从剩下的装法中选择重量最接近Wkg的。将整个问题分为n个阶段，每个阶段对应一个物品如何选择，先对第一个物品进行处理，选择装进去或者不装进去，然后再递归地处理剩下的物品。</p>
<h2 id="正则表达式">正则表达式</h2>
<p>我们依次考察正则表达式中的每个字符，当是非通配符时，我们就直接跟文本的字符进行匹配，如果相同，则继续往下处理；如果不同，则回溯。</p>
<p>如果遇到特殊字符的时候，我们就有多种处理方式了，也就是所谓的岔路口，比如“*”有多种匹配方案，可以匹配任意个文本串中的字符，我们就先随意的选择一种匹配方案，然后继续考察剩下的字符。如果中途发现无法继续匹配下去了，我们就回到这个岔路口，重新选择一种匹配方案，然后再继续匹配剩下的字符。</p>
<p><strong>思考：</strong></p>
<p>如果对0-1 背包问题稍加改造，如果每个物品不仅重量不同，价值也不同。如何在不超过背包重量的情况下，让背包中的总价值最大？</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>王争数据结构与算法学习笔记-分治算法</title>
    <url>/2021/09/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%8E%8B%E4%BA%89%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>分治算法的核心思想是将原问题划分成 n 个规模较小，并且结构与原问题相似的子问题，递归地解决这些子问题，然后再合并其结果，就得到原问题的解。分治算法是一种处理问题的思想，递归是一种编程技巧。分治算法比较适合使用递归来实现。</p>
<span id="more"></span>
<p>分治算法能解决的问题，一般需要满足下面这几个条件：</p>
<ul>
<li>
<p>原问题与分解成的小问题具有相同的模式；</p>
</li>
<li>
<p>原问题分解成的子问题可以独立求解，子问题之间没有相关性，这一点是分治算法跟动态规划的明显区别；</p>
</li>
<li>
<p>具有分解终止条件，也就是说，当问题足够小时，可以直接求解；</p>
</li>
<li>
<p>可以将子问题合并成原问题，而这个合并操作的复杂度不能太高，否则就起不到减小算法总体复杂度的效果了。</p>
</li>
</ul>
<h1>分治算法应用举例分析</h1>
<p>分析排序时，可以使用<strong>有序度</strong>和<strong>逆序度</strong>来分析排序算法的时间复杂度，计算有序度需要找出序列中有序对个数，现在问题是，如何编程求出一组数据的有序对个数或者逆序对个数？</p>
<p>最简单的方式是穷举，这样操作的时间复杂度是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>​，我们可以使用分治算法来解决。可以将数组分为前后两半A1和A2，分别计算A1和A2的逆序对个数K1和K2，然后再计算A1与A2之间的逆序对个数K3。那么数组A的逆序对个数就等于K1+K2+K3。</p>
<p>使用分治算法的其中一个要求是，子问题合并代价不能太大，否则不能起到降低时间复杂度的效果，那么如何快速计算两个子问题A1和A2之间的逆序对个数？</p>
<p>在归并排序中一个非常关键的步骤是将两个有序的小数组合并成一个有序的数组。其实在合并的过程中，可以计算两个小数组之间的逆序对个数。每次合并操作都可以计算逆序对个数，将这些逆序对个数求和即可得到这个数组的逆序对个数。借用原文的图片来说明：</p>
<p><img src="/2021/09/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%8E%8B%E4%BA%89%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95/%E5%90%88%E5%B9%B6%E6%B1%82%E9%80%86%E5%BA%8F%E5%AF%B9.png" alt="合并求逆序对"></p>
<p>关于分治算法的两个比较经典的问题：</p>
<ul>
<li>二维平面上有n个点，如何快速计算两个距离最近的点对？</li>
<li>有两个n * n的矩阵A，B，如何快速求解两个矩阵的乘积C=A * B。</li>
</ul>
<h1>分治思想在海量数据处理中的应用</h1>
<p>大部分数据结构与算法是基于内存存储与单机处理。但是如果数据量过大将无法一次性放入内存。比如给10TB订单文件按照金额排序这样的需求，看似是一个简单的排序问题，但是由于数据量大，无法一次性将数据加载到内存，也就无法通过单纯的使用快排、归并等基础算法来解决了。</p>
<p>我们可以使用分治思想，将海量的数据集合根据某种方法，划分为几个小的数据集合，每个小的数据集合单独加载到内存来解决，然后再将小数据集合合并成大的数据集合。这种分治处理的思路，不仅能客服内存的限制，还能利用多线程或者多机处理，加快处理的速度。不过需要注意，数据的存储与计算所在的机器是同一个或者在网络中靠的很近（比如一个局域网内，数据存取速度很快），否则就会因为数据访问的速度，导致整个处理过程不但不会变快，反而有可能变慢。</p>
<p>为什么说MapReduce的本质就是分治思想？</p>
<p>对于谷歌搜索引擎来说，网页爬取、清洗、分析、粉刺、计算权重、倒排序等等各个环节中，都会面对海量的数据，所以利用集群并行处理是大势所趋。一台机器过于低效，将任务拆分到多台机器上来处理，如果各个小任务之间不互相干扰，独立计算，最后将结果合并，这就是分治思想。</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>分治</tag>
      </tags>
  </entry>
  <entry>
    <title>王争数据结构与算法学习笔记-贪心算法</title>
    <url>/2021/09/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%8E%8B%E4%BA%89%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>贪心算法有很多经典应用，比如霍夫曼编码、Prim和Kruskal最小生成树算法、Dijkstra单源最短路径算法。</p>
<span id="more"></span>
<h1>理解贪心算法</h1>
<p>举个例子：假设有一个可以容纳100kg 物品的背包，可以装各种物品，有以下 5 种豆子，每种豆子的总量和总价值都各不相同。为了让背包中所装物品的总价值最大，我们如何选择在背包中装哪些豆子？每种豆子又该装多少呢？</p>
<table>
<thead>
<tr>
<th>物品</th>
<th>总量（kg）</th>
<th>总价值（元）</th>
</tr>
</thead>
<tbody>
<tr>
<td>黄豆</td>
<td>100</td>
<td>100</td>
</tr>
<tr>
<td>绿豆</td>
<td>30</td>
<td>90</td>
</tr>
<tr>
<td>红豆</td>
<td>60</td>
<td>120</td>
</tr>
<tr>
<td>黑豆</td>
<td>20</td>
<td>80</td>
</tr>
<tr>
<td>青豆</td>
<td>50</td>
<td>75</td>
</tr>
</tbody>
</table>
<p>我们可以先计算每一种豆子的单价，然后按照单价从高到底一次来装即可。本问题的本质就是贪心算法，接下来总结一下贪心算法的步骤：</p>
<ol>
<li>当看到这类问题的时候，可以联想到贪心：针对一组数据，我们定义了<strong>限制值</strong>和<strong>期望值</strong>，希望从中选出几个数据，在满足限制值的情况下，期望值最大。上述例子中，期望值就是背包装的物品的总价值，限制值就是背包能装的100kg重量。</li>
<li>尝试看看这个问题能否使用贪心解决：每次选择当前情况下，在<strong>对限制值同等贡献量的情况下，对期望值贡献最大的数据</strong>。上述例子中，每次从剩下的豆子中，选择单价最高的，也就是重量相同的情况下，对价值贡献最大的豆子。</li>
<li>贪心产生的结果是否最优：大部分是最优，但是并不是总能给出最优解。例如：求出下面有向带权图中从S点到达T点的最短路径。贪心的思路是每次从中选出当期结点权值最小的边，直到T点。按照这样的思路求出的最短路径是：S-&gt;A-&gt;E-&gt;T，路径长度为1+4+4=9。但是实际上最短路径应该是：S-&gt;B-&gt;D-&gt;T。<strong>贪心算法在这里不工作的主要原因是，前面的选择会影响后面的选择。</strong></li>
</ol>
<p><img src="/2021/09/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%8E%8B%E4%BA%89%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/%E5%B8%A6%E6%9D%83%E5%9B%BE.png" alt="带权图"></p>
<p>其实局部最优并不能代表全局最优这一思想在“最速下降法”方法中有体现，最速下降法每一次下降的方向与梯度的方向相反，即每一次移动都是朝着当前点的下降最快的方法前进的，但是从整体效果来看，这条路线并不一定是最优的路线。</p>
<h1>贪心算法实战分析</h1>
<h2 id="分糖果">分糖果</h2>
<p>我们有 m 个糖果和 n 个孩子。我们现在要把糖果分给这些孩子吃，但是糖果少，孩子多（m&lt;n)，所以糖果只能分配给一部分孩子。</p>
<p>每个糖果的大小不等，这 m 个糖果的大小分别是 s1，s2，s3，……，sm。除此之外，每个孩子对糖果大小的需求也是不一样的，只有糖果的大小大于等于孩子的对糖果大小的需求的时候，孩子才得到满足。假设这 n 个孩子对糖果大小的需求分别是 g1，g2，g3，……，gn。</p>
<p>如何分配糖果，能尽可能满足最多数量的孩子？</p>
<p>这个问题中，<strong>期望值</strong>是满足的孩子个数，<strong>限制值</strong>是糖果的个数。</p>
<p><strong>使用贪心算法来分析</strong>：对于一个孩子来说，如果小的糖果可以满足，我们就没必要用更大的糖果，这样更大的就可以留给其他对糖果大小需求更大的孩子。我们每次从剩下的孩子中，找出对糖果大小需求最小的，然后发给他剩下的糖果中能满足他的最小的糖果，这样得到的分配方案，也就是满足的孩子个数最多的方案。</p>
<h2 id="钱币找零">钱币找零</h2>
<p>假设我们有 1 元、2 元、5 元、10 元、20 元、50 元、100 元这些面额的纸币，它们的张数分别是 c1、c2、c5、c10、c20、c50、c100。我们现在要用这些钱来支付 K 元，最少要用多少张纸币呢？</p>
<p>在生活中，我们肯定是先用面值最大的来支付，如果不够，就继续用更小一点面值的，以此类推，最后剩下的用 1 元来补齐。在贡献相同期望值（纸币数目）的情况下，我们希望多贡献点金额，这样就可以让纸币数更少。</p>
<h2 id="区间覆盖">区间覆盖</h2>
<p>我们有 n 个区间，区间的起始端点和结束端点分别是[l1, r1]，[l2, r2]，[l3, r3]，……，[ln, rn]。我们从这 n 个区间中选出一部分区间，这部分区间满足两两不相交（端点相交的情况不算相交），最多能选出多少个区间呢？</p>
<p>我们每次选择的时候，左端点跟前面的已经覆盖的区间不重合的，右端点又尽量小的，这样可以让剩下的未覆盖区间尽可能的大，就可以放置更多的区间。这实际上就是一种贪心的选择方法。</p>
<h2 id="移除数字">移除数字</h2>
<p>在一个非负整数 a 中，我们希望从中移除 k 个数字，让剩下的数字值最小，如何选择移除哪 k 个数字呢？</p>
<p>限定条件是移除k个数字，扫描两个相邻的数字，如果左边大于右边，删除左边，否则指针右移；如果指针已经到达了最后一个数字，但是仍然没有删除够k个数字，那么直接从最后一个数字开始删除。重复上述步骤直至删除了k个数字。</p>
<h2 id="等待服务">等待服务</h2>
<p>假设有 n 个人等待被服务，但是服务窗口只有一个，每个人需要被服务的时间长度是不同的，如何安排被服务的先后顺序，才能让这 n 个人总的等待时间最短？</p>
<p>期望值是等待时间总和最短，限制条件是窗口只有一个且每次只能服务一个人。每次服务一个人对总的贡献值不同，如果先从时间最短的人开始，那么后面的人等待的时间就是最短的；如果先从时间最长的人开始，那么后面的人等待的时间就是最长的。所以需要最优就得时间最短的人先开始。</p>
<p>贪心算法所产生的一个效果是在局部最优的情况下每次选择剩余数据中最优的数据，那么最后选择的数据可能是最优的(这里不是一定最优，因为局部最优不能确保全局最优)</p>
<h1>如何使用贪心算法实现霍夫曼编码？</h1>
<p>假设我有一个包含 1000 个字符的文件，每个字符占 1 个 byte（1byte=8bits），存储这 1000 个字符就一共需要 8000bits，那有没有更加节省空间的存储方式呢？</p>
<p>假设我们通过统计分析发现，这 1000 个字符中<strong>只包含 6 种不同字符</strong>，假设它们分别是 a、b、c、d、e、f。而 3 个二进制位（bit）就可以表示 8 个不同的字符，所以，为了尽量减少存储空间，<strong>每个字符我们用 3 个二进制位来表示</strong>。那存储这 1000 个字符只需要 3000bits 就可以了，比原来的存储方式节省了很多空间。不过，还有没有更加节省空间的存储方式呢？</p>
<p><strong>霍夫曼编码</strong>是一种十分有效的编码方法，广泛用于数据压缩中，其压缩率通常在 20%～90% 之间。霍夫曼编码不仅会考察文本中有多少个不同字符，还会考察每个字符出现的频率，<strong>根据频率的不同，选择不同长度的编码。<strong>霍夫曼编码试图用这种</strong>不等长的编码方法</strong>，来进一步增加压缩的效率。如何给不同频率的字符选择不同长度的编码呢？根据<strong>贪心的思想</strong>，我们可以<strong>把出现频率比较多的字符，用稍微短一些的编码</strong>；<strong>出现频率比较少的字符，用稍微长一些的编码</strong>。这样，我们就可以<strong>减少整个文件的二进制位数量。</strong></p>
<p>对于等长的编码来说，我们解压缩起来很简单。<strong>霍夫曼编码是不等长的</strong>，每次应该读取 1 位还是 2 位、3 位等等来解压缩呢？这个问题就导致霍夫曼编码解压缩起来比较复杂。为了避免解压缩过程中的歧义，霍夫曼编码要求<strong>各个字符的编码之间，不会出现某个编码是另一个编码前缀的情况。</strong></p>
<p>假设这 6 个字符出现的频率从高到低依次是 a、b、c、d、e、f。我们把它们编码下面这个样子，任何一个字符的编码都不是另一个的前缀，经过这种编码压缩之后，这 1000 个字符只需要 2100bits 就可以了。</p>
<table>
<thead>
<tr>
<th>字符</th>
<th>出现频率</th>
<th>编码</th>
<th>总二进制位数</th>
</tr>
</thead>
<tbody>
<tr>
<td>a</td>
<td>450</td>
<td>1</td>
<td>450</td>
</tr>
<tr>
<td>b</td>
<td>350</td>
<td>01</td>
<td>700</td>
</tr>
<tr>
<td>c</td>
<td>90</td>
<td>001</td>
<td>270</td>
</tr>
<tr>
<td>d</td>
<td>60</td>
<td>0001</td>
<td>240</td>
</tr>
<tr>
<td>e</td>
<td>30</td>
<td>00001</td>
<td>150</td>
</tr>
<tr>
<td>f</td>
<td>20</td>
<td>00000</td>
<td>100</td>
</tr>
</tbody>
</table>
<p>我们把每个字符看作一个节点，并且附带着把频率放到优先级队列中。我们从队列中取出频率最小的两个节点 A、B，然后新建一个节点 C，把频率设置为两个节点的频率之和，并把这个新节点 C 作为节点 A、B 的父节点。最后再把 C 节点放入到优先级队列中。重复这个过程，直到队列中没有数据。</p>
<p>现在，我们给每一条边加上画一个权值，指向左子节点的边我们统统标记为 0，指向右子节点的边，我们统统标记为 1，那从根节点到叶节点的路径就是叶节点对应字符的霍夫曼编码。</p>
<p><img src="/2021/09/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%8E%8B%E4%BA%89%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/%E9%9C%8D%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81.png" alt="霍夫曼编码"></p>
<p>在霍夫曼编码中，<strong>预期值</strong>是<strong>二进制位数总和</strong>，<strong>限定值</strong>虽然没有显示说出，但是英文字母有26位，我们用超过26位的二进制位来表示显然是不合理的，所以我们可以将限定值看作<strong>表示一个字符的二进制位长度最长为26</strong>。那么贪心的思想就体现在：使用最短的二进制位数总和来表示这个文件的所有字符。</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>王争数据结构与算法学习笔记-归并、快排</title>
    <url>/2021/09/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%8E%8B%E4%BA%89%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%BD%92%E5%B9%B6%E3%80%81%E5%BF%AB%E6%8E%92/</url>
    <content><![CDATA[<p>归并排序和快排都使用了分治思想，可以借鉴这种思想来解决非排序问题，比如：如何在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>的时间复杂度内找到一个无序数组中的第k大元素？</p>
<span id="more"></span>
<h1>归并排序原理</h1>
<p>归并排序思想：将数组从中间分为前后两部分，然后对前后两部分分别排序，再将排好序的部分合并。分治，顾名思义，就是分而治之，将一个大问题分解成小的子问题来解决。小的子问题解决了，大问题也就解决了。分治算法一般都是用递归来实现的。</p>
<p>归并排序稳不稳定关键是看merge函数，即将两个有序子序列组合成一个有序序列的函数。我们可以将子序列按照原来的顺序进行合并，这样就可以保证值相同的元素在合并前后的相对顺序不变，所以归并排序是一个<strong>稳定的</strong>排序算法。</p>
<p>归并排序的最好、最坏、平均时间复杂度均为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nlog_2n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>​，非常稳定，与原始数组的有序程度无关。但是归并排序没有像快排那样应用广泛为什么呢？因为归并排序的空间复杂度不是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>。</p>
<p>归并排序需要创建一个临时空间来存放新顺序的序列，尽管每次合并操作都会申请额外的内存空间，但是在合并完成之后，临时开辟的内存空间就被释放了，所以任意时刻CPU只会有一个函数在执行，即只有一个临时的内存空间在使用，所以空间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>。</p>
<h1>快速排序</h1>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>推免</title>
    <url>/2021/09/07/%E9%9D%A2%E7%BB%8F/%E6%8E%A8%E5%85%8D/</url>
    <content><![CDATA[<h1>专业课</h1>
<span id="more"></span>
<h2 id="db">DB</h2>
<h3 id="如何理解关系型数据库的常见设计范式？">如何理解关系型数据库的常见设计范式？</h3>
<p>参考：<a href="https://www.zhihu.com/question/24696366">https://www.zhihu.com/question/24696366</a></p>
<p>范式：<strong>一张数据表的表结构所符合的某种设计标准的级别</strong>。</p>
<p>关系和关系模式：<strong>“关系模式”和“关系”的区别，类似于面向对象程序设计中“类”与“对象”的区别。“关系”是“关系模式”的一个实例，可以把“关系”理解为一张带数据的表，而“关系模式”是这张数据表的表结构。</strong></p>
<p><strong>第一范式</strong>：1NF。符合1NF的关系的每一个属性都不可再分。仅仅符合1NF，会存在数据的大量冗余、插入异常、删除异常、修改异常等问题。比如下图1所示的表：</p>
<p><img src="/2021/09/07/%E9%9D%A2%E7%BB%8F/%E6%8E%A8%E5%85%8D/%E8%A1%A81.png" alt="表1"></p>
<p><code>数据冗余</code>：每一名同学的学号、姓名、系名、系主任重复多次。</p>
<p><code>插入异常</code>：加入学校新建了一个系，但是还没有学生，无法将系和系主任的信息录入系统。因为关系模式要有一个<strong>码</strong>，用于唯一标识每一个元组，仅仅使用学号或者姓名或者系名都无法唯一标识一个元组，所以需要使用多个属性联合标识，这里使用学号+课名来标识。新建一个系之后，还没有学生，此时学号不存在，课名不存在，根据三种关系完整性约束中实体完整性的要求，关系中的码所包含的任意一个属性都不能为空，所有属性的组合也不能重复，故无法将数据录入系统。</p>
<p><code>删除异常</code>：如果将某个系中的所有学生信息删除了，那么这个系和系主任信息也不存在了，但是学生没有了并不能代表系也没有了。</p>
<p><code>修改异常</code>：假如李小明转到法律系，为了保证数据库中的数据一致性，需要修改3条记录中系和系主任的数据。</p>
<p><strong>第二范式</strong>：在1NF的基础上，消除了<strong>非主属性</strong>对码的<strong>部分函数依赖</strong>。就插入异常而言，由于新建的系还没有学生，关系模式中的码的属性还不完全，但是仅仅用码的部分属性如学号，即可确定系和系主任，这就是系和系主任两个属性部分函数依赖于码，而消除了非主属性部分函数依赖于码，即升级到了2NF，消除的方式是模式分解。经过模式分解之后就得到了图2所示的表：</p>
<p><img src="/2021/09/07/%E9%9D%A2%E7%BB%8F/%E6%8E%A8%E5%85%8D/%E8%A1%A82.png" alt="表2"></p>
<p>修改之后，检查一下数据冗余、插入、删除、修改异常是否有解决：</p>
<ul>
<li>李小明转系到法律系：只需要修改一次系和系主任，修改异常有改进。</li>
<li>学生的各个属性的冗余减少，数据冗余有改进。</li>
<li>删除某个系的全部学生信息，系和系主任的信息也消失，删除异常无改进。</li>
<li>插入一个尚无学生的系的信息，无法完成，插入异常无改进。</li>
</ul>
<p>所以<strong>注意</strong>，升级到了2NF不代表可以完全解决1NF遇到的那几个问题：数据冗余、插入、删除、修改异常。</p>
<p><strong>第三范式</strong>：在2NF的基础上，消除了<strong>非主属性</strong>对码的<strong>传递函数依赖</strong>。2NF仍然有问题，主要是非主属性系主任对于码到学号的传递函数依赖（学号-&gt;系，系-&gt;系主任），为了解决问题就需要消除非主属性对码的传递函数依赖。经过模式分解之后得到图3所示的表：</p>
<p><img src="/2021/09/07/%E9%9D%A2%E7%BB%8F/%E6%8E%A8%E5%85%8D/%E8%A1%A83.png" alt="表3"></p>
<p>现在看看之前的问题：</p>
<ul>
<li>删除某个系中所有的学生信息：系和系主任的信息还在，有改进。</li>
<li>插入一个尚无学生的新系：可以插入，有改进。</li>
<li>数据冗余更少：有改进。</li>
</ul>
<p><strong>结论</strong>：由此可见，符合3NF要求的数据库设计，<strong>基本</strong>上解决了数据冗余过大，插入异常，修改异常，删除异常的问题。当然，在实际中，往往为了性能上或者应对扩展的需要，经常 做到2NF或者1NF</p>
<p><strong>BC范式</strong>：在3NF的基础上，解决<strong>主属性</strong>对于码的部分函数依赖和传递函数依赖。</p>
<h2 id="os">OS</h2>
<h3 id="实时系统和分时系统的区别">实时系统和分时系统的区别</h3>
<p>参考：<a href="https://blog.csdn.net/qq_38315190/article/details/80613771">https://blog.csdn.net/qq_38315190/article/details/80613771</a></p>
<p><strong>实时系统</strong>：保证在一定的时间限制内完成特定功能的操作系统。小的嵌入式操作系统经常需要实时操作系统，内核要满足实时操作系统的要求。例如，可以为确保生产线上的机器人能获取某个物体而设计一个操作系统。</p>
<p><strong>分时系统</strong>：使一台计算机同时为几个、几十个甚至几百个用户服务的一种操作系统。</p>
<h3 id="同步和互斥的区别">同步和互斥的区别</h3>
<p>参考：<a href="https://blog.csdn.net/goodluckwhh/article/details/8535775">https://blog.csdn.net/goodluckwhh/article/details/8535775</a></p>
<p><strong>互斥</strong>：互斥是两个任务之间不可以同时运行，他们会相互排斥，必须等待一个线程运行完毕，另一个才能运行。</p>
<p><strong>同步</strong>：同步也是不能同时运行，但他是必须要安照某种次序来运行相应的线程（也是一种互斥）。</p>
<p>互斥具有唯一性和排它性，但互斥并不限制任务的运行顺序，即任务是无序的。而同步的任务之间则有顺序关系。</p>
<h3 id="进程和线程之间的区别">进程和线程之间的区别</h3>
<p><strong>进程</strong>是程序在计算机上的一次执行活动。当你运行一个程序，你就启动了一个进程。凡是用于完成操作系统的各种功能的进程就是系统进程，它们就是处于运行状态下的操作系统本身；其它进程就是用户进程。<strong>线程</strong>是OS调度的基本单位，在基于线程的多任务的环境中，所有进程有至少一个线程，但是它们可以具有多个任务。这意味着单个程序可以并发执行两个或者多个任务。多进程与多线程相比，每个<strong>进程</strong>都有一个<strong>完整的地址空间</strong>和<strong>操作环境状态</strong>。每个进程用于创建和维护大量状态信息的成本，与一个线程相比，无论是在时间上还是空间上代价都更高。此外，进程间所固有的独立性使得程序员需要花费很多精力来处理不同进程间的通信。</p>
<p>进程的资源主要包括：</p>
<ul>
<li>地址空间（涉及到同步互斥的地址段主要是数据段和堆栈段）；</li>
<li>打开的文件句柄。</li>
</ul>
<p>线程中的资源：一个进程中的所有线程共享进程的地址空间（数据段/堆）、打开的文件句柄。由线程独享的资源包括：</p>
<ul>
<li>栈；</li>
<li>线程专有数据区。</li>
</ul>
<h2 id="network">Network</h2>
<h1>英语</h1>
<ol>
<li><strong>Please introduce yourself briefly.</strong></li>
<li><strong>Why do you choose our school?</strong></li>
<li><strong>Could you tell us something about your university?</strong></li>
<li><strong>What is your strengths?</strong></li>
<li><strong>What are the differences between C and C plus plus?</strong></li>
<li><strong>What are the differences between stack and array?</strong></li>
<li><strong>Can you tell me what is link list?</strong></li>
<li><strong>Plans in the postgraduate study?</strong></li>
<li><strong>Please introduce your project.</strong></li>
<li><strong>What social responsibilities should a post-graduate take?</strong></li>
<li><strong>Please Introduce your hometown.</strong></li>
<li><strong>What impressed you most when you were at university?</strong></li>
<li><strong>If you failed this time, what will you do in the near future?</strong></li>
<li><strong>What kinds of opportunities are you looking for?</strong></li>
<li><strong>What is deep learning?</strong></li>
<li><strong>Could you say something about your family?</strong></li>
<li><strong>What do you usually do in your leisure time?</strong></li>
<li><strong>Who is the most important person in your family?</strong></li>
</ol>
]]></content>
      <categories>
        <category>面经</category>
      </categories>
      <tags>
        <tag>面经</tag>
        <tag>推免</tag>
      </tags>
  </entry>
  <entry>
    <title>常见内部排序的分析（面试）</title>
    <url>/2021/09/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B8%B8%E8%A7%81%E5%86%85%E9%83%A8%E6%8E%92%E5%BA%8F%E7%9A%84%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h1>插入排序</h1>
<span id="more"></span>
<h2 id="直接插入排序">直接插入排序</h2>
<p>每一次从无序子序列中取出一个数，插入有序子序列中，并保证有序子序列在放入该数前后保持有序。直接插入排序时间花费在找到插入位置以及移动数据上。</p>
<p>直接插入排序性能受到原序列的有序性影响较大，如果原序列已经有序，那么时间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>；如果原序列与目标顺序完全相反，那么时间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>​。算法的平均时间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msub><mi>n</mi><mn>2</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n_2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，空间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>​。</p>
<p>适用性：直接插入排序适用于顺序存储和链式存储。</p>
<p>稳定性：稳定。</p>
<h2 id="折半插入排序">折半插入排序</h2>
<p>折半插入要保证原序列有序，然后向原序列中插入数据的可以减少比较次数，为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nlog_2n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>​，但是移动次数还是无法优化，故时间复杂度仍然为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，空间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>。</p>
<p>稳定性：稳定。</p>
<h2 id="希尔排序">希尔排序</h2>
<p>希尔排序的想法来自直接插入排序，直接插入排序性能受到原序列的有序性影响较大，希尔排序设定步长d从原序列中选出数据，将选出的数据组成新的序列并排序（不是将选出的数据真正的挑出来，然后用新的内存空间来存储，而是直接在原序列的基础上进行排序），这样对多个子序列重新排序之后，缩小步长d，重复上述过程直至d=1排序之后得到的就是排序完成的序列。</p>
<p>当n在某个特定的范围时，希尔排序的时间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>1.3</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^{1.3})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">.</span><span class="mord mtight">3</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，空间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>，最坏的情况下时间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><msup><mo stretchy="false">(</mo><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen"><span class="mopen">(</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>。</p>
<p>稳定性：不稳定。</p>
<h1>交换排序</h1>
<h2 id="冒泡排序">冒泡排序</h2>
<p>冒泡排序每一趟排序可以确定一个最终元素的位置，就像泡泡一样可以不断的将一个数据“浮”到最顶/尾端。可以使用哨兵位来优化，当某一趟结束之后发现并没有交换数据位置的操作，就表明此时已经有序，结束排序。</p>
<p>最好、最坏的时间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，空间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>。</p>
<p>稳定性：稳定。</p>
<h2 id="快速排序">快速排序</h2>
<p>快速排序每一次也可以确定一个最终元素（枢轴元素）的位置，只不过其位置不一定是在序列的首部或者尾部，也可能在中间的某一个位置。</p>
<p>快速排序使用双指针，假设序列的长度为n，将n-1个数据和1个数据比较（枢轴元素），并划分成大于该数据的部分和小于该数据的部分。然后递归该数据左右两部分，使用上述方式来重新将两个部分进行划分。</p>
<p>容易发现快排最终可以形成一个递归树，所以分析快排的空间复杂度除了额外的内存空间之外，还要考虑递归的深度。最好的情况下递归的深度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(log_2n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>，最坏的情况下为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>，平均情况下为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(log_2n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>。</p>
<p>时间复杂度也和枢轴元素的选取有关，如果枢轴元素选取可以将序列比较均匀的分为两部分，那么时间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nlog_2n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>；如果枢轴元素划分序列很不对称，那么快排将退化为冒泡排序（每一次都从中确定一个最大/最小元素），时间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>。<strong>快排是平均性能最高的内部排序</strong>。</p>
<p>为了缓解枢轴元素选取不恰当而导致快排性能下降的问题，可以随机从序列中选取3个元素，然后取中间元素作为枢轴元素。</p>
<p>稳定性：不稳定。</p>
<h1>选择排序</h1>
<h2 id="简单选择排序">简单选择排序</h2>
<p>简单选择排序每一趟可以从无序序列中选取出来一个最大或者最小值，这就意味着每一趟需要遍历无序序列，所以不论初始序列是否有序，时间复杂度均为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，空间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>。</p>
<p>稳定性：不稳定。</p>
<h2 id="堆排序">堆排序</h2>
<p>堆排序需要考虑两个核心问题：</p>
<ol>
<li>如何将无序的序列构造成初始堆？</li>
<li>输出堆顶元素之后，如何将剩余元素调整成新的堆？</li>
</ol>
<p>堆使用完全二叉树实现，所以存储堆的数据结构应该是顺序表。</p>
<p><strong>堆排序适合关键字较多的情况，比如在1亿个数中选出前100个最大值？</strong></p>
<p>首先使用一个大小为100的数组，读入前100个数，建立小顶堆，然后依次读入余下的数，如果小于小顶堆则舍弃，否则用该数取代堆顶并重新调整堆，待数据读取完毕，堆中100个数即为所求。</p>
<p>空间效率：仅使用了常数个辅助单元，所以空间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>。</p>
<p>时间复杂度：建堆时间为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>，之后有n-1次向下调整操作，每次调整的时间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>h</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(h)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">h</span><span class="mclose">)</span></span></span></span>，故在最好、最坏和平均情况下，堆排序的时间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nlog_2n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>。</p>
<p>稳定性：不稳定。</p>
<h1>其他类别</h1>
<h2 id="归并排序">归并排序</h2>
<p>假定待排序序列含有n个记录，则可以将其视为n个有序的子表，每个子表的长度为1，然后两两归并，得到若干个长度为2或1的有序表，继续两两归并，如此重复，知道合并成一个长度为n的有序表为止，这就是2路归并。</p>
<p>空间效率：在两个表相互合并的过程中，需要使用n个单元来存储，所以算法的空间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>。</p>
<p>时间效率：每趟归并的时间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>，共需要 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(log_2n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>趟归并，所以算法的时间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nlog_2n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>。</p>
<p>稳定性：稳定。</p>
<h2 id="基数排序">基数排序</h2>
<p>假设长度为n的线性表中每个结点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">a_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>的关键字由d元组（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>k</mi><mi>j</mi><mrow><mi>d</mi><mo>−</mo><mn>1</mn></mrow></msubsup><mo separator="true">,</mo><msubsup><mi>k</mi><mi>j</mi><mrow><mi>d</mi><mo>−</mo><mn>2</mn></mrow></msubsup><mo separator="true">,</mo><mo separator="true">⋅</mo><mo separator="true">⋅</mo><mo separator="true">⋅</mo><mo separator="true">,</mo><msubsup><mi>k</mi><mi>j</mi><mn>1</mn></msubsup><mo separator="true">,</mo><msubsup><mi>k</mi><mi>j</mi><mn>0</mn></msubsup></mrow><annotation encoding="application/x-tex">k_j^{d-1},k_j^{d-2},···,k_j^1,k_j^0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.3022109999999998em;vertical-align:-0.412972em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8892389999999999em;"><span style="top:-2.4231360000000004em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span><span style="top:-3.1031310000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">d</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.412972em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8892389999999999em;"><span style="top:-2.4231360000000004em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span><span style="top:-3.1031310000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">d</span><span class="mbin mtight">−</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.412972em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-2.441336em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.394772em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-2.441336em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.394772em;"><span></span></span></span></span></span></span></span></span></span>）组成，比如每一个节点是一个三位数，节点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">a_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>为312，那么关键字<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>k</mi><mi>j</mi><mn>2</mn></msubsup><mo separator="true">,</mo><msubsup><mi>k</mi><mi>j</mi><mn>1</mn></msubsup><mo separator="true">,</mo><msubsup><mi>k</mi><mi>j</mi><mn>0</mn></msubsup></mrow><annotation encoding="application/x-tex">k_j^2,k_j^1,k_j^0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.20888em;vertical-align:-0.394772em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-2.441336em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.394772em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-2.441336em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.394772em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-2.441336em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.394772em;"><span></span></span></span></span></span></span></span></span></span>分别为3，1，2。基数排序就是通过对每个节点中的三位数中的每一位进行比较，最终得到排序结果。为实现多关键字排序，通常使用两种方法：<strong>最高位优先</strong>，<strong>最低位优先</strong>。</p>
<p>在排序的过程中，使用r个队列<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Q</mi><mn>0</mn></msub><mo separator="true">,</mo><msub><mi>Q</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>Q</mi><mn>2</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>Q</mi><mrow><mi>r</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">Q_0,Q_1,Q_2,...,Q_{r-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.891661em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathdefault">Q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">Q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">Q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">Q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span></span>​，针对每一个节点中的每一位依次做一次“分配”和“收集”。如果每个节点中的记录都是一个不大于999的正整数，那么r=10，表示每一个记录的每一位的取值范围长度。</p>
<p>空间效率：一趟排序需要的辅助存储空间为r（r个队列：r个队头指针和r个队尾指针），但是以后的排序中会重复使用这些队列，所以基数排序的空间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>r</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(r)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">)</span></span></span></span>。</p>
<p>时间复杂度：基数排序需要进行d趟分配和收集，假设序列中最大记录由三位数构成，那么这里的d=3。一趟分配需要<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>，一趟收集需要<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>r</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(r)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">)</span></span></span></span>，所以基数排序的时间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>d</mi><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mi>r</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(d(n+r))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span>，它与序列的初始状态无关。</p>
<p>稳定性：稳定。</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>王道-顺序、折半、分块查找</title>
    <url>/2021/09/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%8E%8B%E9%81%93-%E9%A1%BA%E5%BA%8F%E3%80%81%E6%8A%98%E5%8D%8A%E3%80%81%E5%88%86%E5%9D%97%E6%9F%A5%E6%89%BE/</url>
    <content><![CDATA[<h1>基本概念</h1>
<span id="more"></span>
<p><strong>查找表</strong>：查找结构，用于查找的数据集合称为查找表，它由同一类型的数据元素（或记录）组成。</p>
<p><strong>关键字</strong>：数据元素中唯一标识该元素的某个数据项的值，使用基于关键字的查找，查找结果应该是唯一的。</p>
<p><strong>静态查找表</strong>：查找符合条件的数据元素（不会修改表中的数据）。</p>
<p><strong>动态查找表</strong>：插入、删除某个数据元素。除了查找速度，也要关注插/删操作是否方便实现。</p>
<p><strong>查找长度</strong>：在查找运算中，需要对比关键字的次数成为查找长度。</p>
<p><strong>平均查找长度（ASL, Average Search Length)</strong>：所有查找过程中进行关键字的比较次数的平均值。</p>
<p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mi>S</mi><mi>L</mi><mo>=</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><msub><mi>P</mi><mi>i</mi></msub><msub><mi>C</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">ASL=\sum_{i=1}^{n}P_iC_i
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault">L</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.929066em;vertical-align:-1.277669em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6513970000000002em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3000050000000005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p>
<p>其中，n为数据元素的个数，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">P_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>为查找第i个元素的概率，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>C</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">C_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>为查找第i个元素的查找长度。</p>
<p>评价一个查找算法的效率的时候，通常考虑查找成功/查找失败两种情况的ASL。ASL的数量级反映了查找算法的时间复杂度。</p>
<h1>顺序查找</h1>
<p>思路是给定一个需要查找的元素x，遍历查找表直到找到为止。假设查找表的长度为n，那么对于其中的每一个元素i，计算平均查找长度为：</p>
<p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow><mi mathvariant="bold">A</mi><mi mathvariant="bold">S</mi><mi mathvariant="bold">L</mi></mrow><mtext>成功 </mtext></msub><mo>=</mo><mfrac><mrow><mn>1</mn><mo>+</mo><mn>2</mn><mo>+</mo><mn>3</mn><mo>+</mo><mo>…</mo><mo>+</mo><mi>n</mi></mrow><mi>n</mi></mfrac><mo>=</mo><mfrac><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">\mathbf{A S L}_{\text {成功 }}=\frac{1+2+3+\ldots+n}{n}=\frac{n+1}{2}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83611em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord"><span class="mord mathbf">A</span><span class="mord mathbf">S</span><span class="mord mathbf">L</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord cjk_fallback mtight">成功</span><span class="mord mtight"> </span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.00744em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">n</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.00744em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<p>查找的时间复杂度为：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>。</p>
<p>查找失败的ASL为n+1。</p>
<h2 id="顺序查找的优化-有序表">顺序查找的优化（有序表）</h2>
<p>查找表中的元素有序存放（递增/递减）eg:</p>
<p>7、13、19、29、37、43</p>
<p>查找目标：21</p>
<p>如果查找到29，发现29大于21但是仍未找到21，就可以断定查找失败。有序表的查找判定树如下（图来自王道考研）：</p>
<p><img src="/2021/09/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%8E%8B%E9%81%93-%E9%A1%BA%E5%BA%8F%E3%80%81%E6%8A%98%E5%8D%8A%E3%80%81%E5%88%86%E5%9D%97%E6%9F%A5%E6%89%BE/%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91.png" alt="二叉查找树"></p>
<p>查找失败一共有n+1种情况，因为最后一个元素的两边的范围都是查找失败的范围。</p>
<p>我们认为查找失败的概率都是相等的，即给定一个元素，落在这n+1个范围内的概率是相等的，那么得到的查找失败的平均查找长度为：</p>
<p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow><mi mathvariant="bold">A</mi><mi mathvariant="bold">S</mi><mi mathvariant="bold">L</mi></mrow><mtext>失败 </mtext></msub><mo>=</mo><mfrac><mrow><mn>1</mn><mo>+</mo><mn>2</mn><mo>+</mo><mn>3</mn><mo>+</mo><mo>…</mo><mo>+</mo><mi>n</mi><mo>+</mo><mi>n</mi></mrow><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></mfrac><mo>=</mo><mfrac><mi>n</mi><mn>2</mn></mfrac><mo>+</mo><mfrac><mi>n</mi><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></mfrac></mrow><annotation encoding="application/x-tex">\mathbf{A S L}_{\text {失败 }}=\frac{1+2+3+\ldots+n+n}{n+1}=\frac{n}{2}+\frac{n}{n+1}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83611em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord"><span class="mord mathbf">A</span><span class="mord mathbf">S</span><span class="mord mathbf">L</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord cjk_fallback mtight">失败</span><span class="mord mtight"> </span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.09077em;vertical-align:-0.7693300000000001em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.7693300000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.7935600000000003em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.10756em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.8768900000000002em;vertical-align:-0.7693300000000001em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.10756em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.7693300000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<p>注意，查找失败的分子上有两个n，分别表示的是元素43左右两个范围的查找次数。</p>
<p>如果被查找的数据不是等概率的，比如如下的序列：</p>
<p>7、13、19、29、37、43</p>
<p>其中被查找的概率依次为：</p>
<p>15%、5%、10%、40%、28%、2%</p>
<p>实际问题中，根据具体的需要来进行排列这些数据，如果按照概率大的元素排在前，那么最终成功的平均查找次数为：</p>
<p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mi>S</mi><msub><mi>L</mi><mtext>成功</mtext></msub><mo>=</mo><msup><mn>1</mn><mo lspace="0em" rspace="0em">⋆</mo></msup><mn>0.4</mn><mo>+</mo><msup><mn>2</mn><mo lspace="0em" rspace="0em">⋆</mo></msup><mn>0.28</mn><mo>+</mo><msup><mn>3</mn><mo lspace="0em" rspace="0em">⋆</mo></msup><mn>0.15</mn><mo>+</mo><msup><mn>4</mn><mo lspace="0em" rspace="0em">⋆</mo></msup><mn>0.1</mn><mo>+</mo><msup><mn>5</mn><mo lspace="0em" rspace="0em">⋆</mo></msup><mn>0.05</mn><mo>+</mo><msup><mn>6</mn><mo lspace="0em" rspace="0em">⋆</mo></msup><mn>0.02</mn><mo>=</mo><mn>2.18</mn></mrow><annotation encoding="application/x-tex">ASL_{成功}=1^{\star} 0.4+2^{\star} 0.28+3^{\star} 0.15+4^{\star} 0.1+5^{\star} 0.05+6^{\star} 0.02=2.18
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">成</span><span class="mord cjk_fallback mtight">功</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.822026em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">1</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.738696em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">⋆</span></span></span></span></span></span></span></span></span><span class="mord">0</span><span class="mord">.</span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.822026em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.738696em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">⋆</span></span></span></span></span></span></span></span></span><span class="mord">0</span><span class="mord">.</span><span class="mord">2</span><span class="mord">8</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.822026em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">3</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.738696em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">⋆</span></span></span></span></span></span></span></span></span><span class="mord">0</span><span class="mord">.</span><span class="mord">1</span><span class="mord">5</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.822026em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">4</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.738696em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">⋆</span></span></span></span></span></span></span></span></span><span class="mord">0</span><span class="mord">.</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.822026em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">5</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.738696em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">⋆</span></span></span></span></span></span></span></span></span><span class="mord">0</span><span class="mord">.</span><span class="mord">0</span><span class="mord">5</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.738696em;vertical-align:0em;"></span><span class="mord"><span class="mord">6</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.738696em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">⋆</span></span></span></span></span></span></span></span></span><span class="mord">0</span><span class="mord">.</span><span class="mord">0</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">.</span><span class="mord">1</span><span class="mord">8</span></span></span></span></span></p>
<p>但是这样数据又变成了乱序，失败的平均查找次数和原来没有优化的一样，所以具体如何排列还需要考虑实际的应用。</p>
<h2 id="折半查找">折半查找</h2>
<p>分析折半查找的ASL需要画出查找判定树，比如给定有序序列：</p>
<p>7、10、13、16、19、29、32、33、37、41、43</p>
<p>画出查找判定树如下：</p>
<p><img src="/2021/09/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%8E%8B%E9%81%93-%E9%A1%BA%E5%BA%8F%E3%80%81%E6%8A%98%E5%8D%8A%E3%80%81%E5%88%86%E5%9D%97%E6%9F%A5%E6%89%BE/%E6%8A%98%E5%8D%8A%E6%9F%A5%E6%89%BE%E6%A0%91.png" alt="折半查找树"></p>
<p>画出查找判定树然后分析查找成功和失败的ASL就容易了，对于成功ASL，每一层查找的次数为层的序数。那么容易计算：</p>
<p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow><mi mathvariant="normal">A</mi><mi mathvariant="normal">S</mi><mi mathvariant="normal">L</mi></mrow><mtext>成功 </mtext></msub><mo>=</mo><mrow><mo fence="true">(</mo><msup><mn>1</mn><mo lspace="0em" rspace="0em">∗</mo></msup><mn>1</mn><mo>+</mo><msup><mn>2</mn><mo lspace="0em" rspace="0em">⋆</mo></msup><mn>2</mn><mo>+</mo><msup><mn>3</mn><mo lspace="0em" rspace="0em">⋆</mo></msup><mn>4</mn><mo>+</mo><msup><mn>4</mn><mo lspace="0em" rspace="0em">⋆</mo></msup><mn>4</mn><mo fence="true">)</mo></mrow><mi mathvariant="normal">/</mi><mn>11</mn><mo>=</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">\mathrm{ASL}_{\text {成功 }}=\left(1^{*} 1+2^{\star} 2+3^{\star} 4+4^{\star} 4\right) / 11=3
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">A</span><span class="mord mathrm">S</span><span class="mord mathrm">L</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord cjk_fallback mtight">成功</span><span class="mord mtight"> </span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord"><span class="mord">1</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.738696em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">∗</span></span></span></span></span></span></span></span></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.738696em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">⋆</span></span></span></span></span></span></span></span></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord">3</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.738696em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">⋆</span></span></span></span></span></span></span></span></span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord">4</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.738696em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">⋆</span></span></span></span></span></span></span></span></span><span class="mord">4</span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">/</span><span class="mord">1</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span></span></span></span></span></p>
<p>对于失败的ASL，我们认为任意一个元素x落在紫色范围内的概率相等，都为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mn>1</mn><mn>12</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac{1}{12}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>，对于第三层的数，需要查找3次，第4层的数需要查找4次，由此得到：</p>
<p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext> ASL失败 </mtext><mo>=</mo><mrow><mo fence="true">(</mo><msup><mn>3</mn><mo lspace="0em" rspace="0em">∗</mo></msup><mn>4</mn><mo>+</mo><msup><mn>4</mn><mo lspace="0em" rspace="0em">⋆</mo></msup><mn>8</mn><mo fence="true">)</mo></mrow><mi mathvariant="normal">/</mi><mn>12</mn><mo>=</mo><mn>11</mn><mi mathvariant="normal">/</mi><mn>3</mn></mrow><annotation encoding="application/x-tex">\text { ASL失败 }=\left(3^{*} 4+4^{\star} 8\right) / 12=11 / 3
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord text"><span class="mord"> ASL</span><span class="mord cjk_fallback">失败</span><span class="mord"> </span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord"><span class="mord">3</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.738696em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">∗</span></span></span></span></span></span></span></span></span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord">4</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.738696em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">⋆</span></span></span></span></span></span></span></span></span><span class="mord">8</span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">/</span><span class="mord">1</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">1</span><span class="mord">/</span><span class="mord">3</span></span></span></span></span></p>
<p>折半查找的时间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(log_2n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></p>
<h2 id="分块查找">分块查找</h2>
<p>主要思想：将给定的看似无序的序列分为若干个子序列，称为“块”，块间有序，块内无序（这里的块间有序指的是每一个块中的最大值有序），然后使用一个索引表来存放序列的每一个块的最大值在原序列中的索引以及块的范围，比如下面这个示例（图来自王道考研系列课程）：</p>
<p><img src="/2021/09/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%8E%8B%E9%81%93-%E9%A1%BA%E5%BA%8F%E3%80%81%E6%8A%98%E5%8D%8A%E3%80%81%E5%88%86%E5%9D%97%E6%9F%A5%E6%89%BE/%E5%88%86%E5%9D%97%E6%9F%A5%E6%89%BE.png" alt="分块查找"></p>
<p>假设需要查找22，那么将22和每一个分块的最大值进行比较，如果小于某一个分块的最大值，说明该目标可能在该分块内，然后切换到该分块的起始位置进行查找，如果找到了则存在，否则不存在。<strong>这里判断目标在某一个块中，可以使用折半查找的方式而非遍历的方式来查找。</strong></p>
<p>如果需要向满足分块查找要求的序列中插入一个元素，比如向上图中的序列插入元素8，为了维护表的特性，需要移动大量元素，为了解决这个问题，可以使用链式存储来解决，将上图中的表改成如下的链式存储：</p>
<p><img src="/2021/09/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%8E%8B%E9%81%93-%E9%A1%BA%E5%BA%8F%E3%80%81%E6%8A%98%E5%8D%8A%E3%80%81%E5%88%86%E5%9D%97%E6%9F%A5%E6%89%BE/%E5%88%86%E5%9D%97%E6%9F%A5%E6%89%BE-%E9%93%BE%E5%BC%8F.png" alt="分块查找-链式"></p>
<p>分块查找算法对于序列有比较特殊的要求，所以在实际应用中用的较少。</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>numpy广播机制的巧妙使用</title>
    <url>/2021/08/27/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/numpy%E5%B9%BF%E6%92%AD%E6%9C%BA%E5%88%B6%E7%9A%84%E5%B7%A7%E5%A6%99%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1>numpy广播在语义分割上的妙用</h1>
<span id="more"></span>
<p>假设输入的图像大小为：536x559：</p>
<p><img src="/2021/08/27/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/numpy%E5%B9%BF%E6%92%AD%E6%9C%BA%E5%88%B6%E7%9A%84%E5%B7%A7%E5%A6%99%E4%BD%BF%E7%94%A8/%E5%8E%9F%E5%9B%BE%E5%83%8F.png" alt="原图像"></p>
<p>我们还有如下的标签文件：</p>
<p><img src="/2021/08/27/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/numpy%E5%B9%BF%E6%92%AD%E6%9C%BA%E5%88%B6%E7%9A%84%E5%B7%A7%E5%A6%99%E4%BD%BF%E7%94%A8/%E6%A0%87%E7%AD%BE.png" alt="标签"></p>
<p>不同颜色和标签的含义如下：</p>
<p><img src="/2021/08/27/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/numpy%E5%B9%BF%E6%92%AD%E6%9C%BA%E5%88%B6%E7%9A%84%E5%B7%A7%E5%A6%99%E4%BD%BF%E7%94%A8/%E5%90%AB%E4%B9%89.png" alt="含义"></p>
<p>接下来需要对标签文件中的不同物体颜色块进行分离，即达到如下的效果：</p>
<p><img src="/2021/08/27/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/numpy%E5%B9%BF%E6%92%AD%E6%9C%BA%E5%88%B6%E7%9A%84%E5%B7%A7%E5%A6%99%E4%BD%BF%E7%94%A8/%E7%BC%96%E7%A0%81.png" alt="编码"></p>
<p>为了方便输出，我们使用一个小一点的张量来测试。首先读取mask文件：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>mask = np.random.randint(<span class="number">0</span>, <span class="number">4</span>, (<span class="number">5</span>, <span class="number">3</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(mask.shape)</span><br><span class="line">(<span class="number">536</span>, <span class="number">559</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(mask)</span><br><span class="line">[[<span class="number">2</span> <span class="number">3</span> <span class="number">0</span>]</span><br><span class="line"> [<span class="number">2</span> <span class="number">2</span> <span class="number">1</span>]</span><br><span class="line"> [<span class="number">0</span> <span class="number">0</span> <span class="number">3</span>]</span><br><span class="line"> [<span class="number">1</span> <span class="number">2</span> <span class="number">0</span>]</span><br><span class="line"> [<span class="number">3</span> <span class="number">2</span> <span class="number">2</span>]]</span><br></pre></td></tr></table></figure>
<p>使用np.unique()函数去重并将数据排序：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj_ids = np.unique(mask)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj_ids</span><br><span class="line">array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br></pre></td></tr></table></figure>
<p>扩展obj_ids的维度，以便实现广播：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(obj_ids[:, <span class="literal">None</span>, <span class="literal">None</span>])</span><br><span class="line">[[[<span class="number">0</span>]]</span><br><span class="line"> </span><br><span class="line"> [[<span class="number">1</span>]]</span><br><span class="line"> </span><br><span class="line"> [[<span class="number">2</span>]]</span><br><span class="line"> </span><br><span class="line"> [[<span class="number">3</span>]]]</span><br></pre></td></tr></table></figure>
<p>开始分离物体颜色块（需要注意的是，0一般为背景，需要去掉，这里保留是为了增强表达效果，如需去掉，则obj_ids = obj_ids[1: ] ）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>masks = mask == obj[:, <span class="literal">None</span>, <span class="literal">None</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>masks</span><br><span class="line">array([[[<span class="literal">False</span>, <span class="literal">False</span>,  <span class="literal">True</span>],</span><br><span class="line">        [<span class="literal">False</span>, <span class="literal">False</span>, <span class="literal">False</span>],</span><br><span class="line">        [ <span class="literal">True</span>,  <span class="literal">True</span>, <span class="literal">False</span>],</span><br><span class="line">        [<span class="literal">False</span>, <span class="literal">False</span>,  <span class="literal">True</span>],</span><br><span class="line">        [<span class="literal">False</span>, <span class="literal">False</span>, <span class="literal">False</span>]],</span><br><span class="line"></span><br><span class="line">       [[<span class="literal">False</span>, <span class="literal">False</span>, <span class="literal">False</span>],</span><br><span class="line">        [<span class="literal">False</span>, <span class="literal">False</span>,  <span class="literal">True</span>],</span><br><span class="line">        [<span class="literal">False</span>, <span class="literal">False</span>, <span class="literal">False</span>],</span><br><span class="line">        [ <span class="literal">True</span>, <span class="literal">False</span>, <span class="literal">False</span>],</span><br><span class="line">        [<span class="literal">False</span>, <span class="literal">False</span>, <span class="literal">False</span>]],</span><br><span class="line"></span><br><span class="line">       [[ <span class="literal">True</span>, <span class="literal">False</span>, <span class="literal">False</span>],</span><br><span class="line">        [ <span class="literal">True</span>,  <span class="literal">True</span>, <span class="literal">False</span>],</span><br><span class="line">        [<span class="literal">False</span>, <span class="literal">False</span>, <span class="literal">False</span>],</span><br><span class="line">        [<span class="literal">False</span>,  <span class="literal">True</span>, <span class="literal">False</span>],</span><br><span class="line">        [<span class="literal">False</span>,  <span class="literal">True</span>,  <span class="literal">True</span>]],</span><br><span class="line"></span><br><span class="line">       [[<span class="literal">False</span>,  <span class="literal">True</span>, <span class="literal">False</span>],</span><br><span class="line">        [<span class="literal">False</span>, <span class="literal">False</span>, <span class="literal">False</span>],</span><br><span class="line">        [<span class="literal">False</span>, <span class="literal">False</span>,  <span class="literal">True</span>],</span><br><span class="line">        [<span class="literal">False</span>, <span class="literal">False</span>, <span class="literal">False</span>],</span><br><span class="line">        [ <span class="literal">True</span>, <span class="literal">False</span>, <span class="literal">False</span>]]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>masks.shape</span><br><span class="line">(<span class="number">4</span>, <span class="number">5</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<p>最后输出的masks的形状表示4个物体（0， 1， 2， 3）各自提取出来的掩膜形状为（5， 3）。</p>
<p>一开始最难以理解的是维度扩充那里，即：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">obj_ids[:, <span class="literal">None</span>, <span class="literal">None</span>]</span><br></pre></td></tr></table></figure>
<p>这里扩充是为了满足广播的条件，一开始的obj_ids维度为一维，我们需要将obj_ids中的每一个元素都与mask中的每一个元素进行比较一番（当然最简单的方法可以使用循环实现，但是效率低下），为了实现并行处理，需要将（0,1,2,3）中的每一个元素扩充为二维的形式，即分别为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[[[<span class="number">0</span>]]</span><br><span class="line"> </span><br><span class="line"> [[<span class="number">1</span>]]</span><br><span class="line"> </span><br><span class="line"> [[<span class="number">2</span>]]</span><br><span class="line"> </span><br><span class="line"> [[<span class="number">3</span>]]]</span><br></pre></td></tr></table></figure>
<p>然后在进行比较的过程中就可以自动使用广播机制来进行加速计算：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line"> [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line"> [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line"> [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line"> [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]]</span><br><span class="line"></span><br><span class="line">[[<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>], </span><br><span class="line"> [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>], </span><br><span class="line"> [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>], </span><br><span class="line"> [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>], </span><br><span class="line"> [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]]</span><br><span class="line"></span><br><span class="line">[[<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>], </span><br><span class="line"> [<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>], </span><br><span class="line"> [<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>], </span><br><span class="line"> [<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>], </span><br><span class="line"> [<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>]]</span><br><span class="line"></span><br><span class="line">[[<span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>], </span><br><span class="line"> [<span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>], </span><br><span class="line"> [<span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>], </span><br><span class="line"> [<span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>], </span><br><span class="line"> [<span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>]]</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
        <tag>cv</tag>
        <tag>numpy</tag>
      </tags>
  </entry>
  <entry>
    <title>学习链接</title>
    <url>/2021/08/23/%E5%B8%B8%E7%94%A8%E9%93%BE%E6%8E%A5/%E5%AD%A6%E4%B9%A0%E9%93%BE%E6%8E%A5/</url>
    <content><![CDATA[<h1 id="深度学习"><a href="#深度学习" class="headerlink" title="深度学习"></a>深度学习</h1><span id="more"></span>
<h2 id="1-bilibli"><a href="#1-bilibli" class="headerlink" title="1. bilibli"></a>1. bilibli</h2><h3 id="同济子豪兄"><a href="#同济子豪兄" class="headerlink" title="同济子豪兄"></a>同济子豪兄</h3><p><a href="https://search.bilibili.com/all?keyword=%E5%90%8C%E6%B5%8E%E5%AD%90%E8%B1%AA%E5%85%84&amp;from_source=websuggest_search">主页</a></p>
<p><a href="https://www.bilibili.com/video/BV1K7411W7So">精讲CS231N斯坦福计算机视觉公开课</a></p>
<h3 id="其他up主"><a href="#其他up主" class="headerlink" title="其他up主"></a>其他up主</h3><p><a href="https://www.bilibili.com/video/BV1nJ411z7fe?from=search&amp;seid=1219562638128911509">最新斯坦福李飞飞cs231n计算机视觉课程</a></p>
<h2 id="2-GitHub"><a href="#2-GitHub" class="headerlink" title="2. GitHub"></a>2. GitHub</h2><h3 id="李沐"><a href="#李沐" class="headerlink" title="李沐"></a>李沐</h3><p><a href="https://github.com/d2l-ai">动手学深度学习</a></p>
<p><a href="https://d2l.ai/index.html">dive into deep learning</a></p>
<p><a href="https://discuss.d2l.ai/">论坛</a></p>
<h2 id="3-Federated-learning"><a href="#3-Federated-learning" class="headerlink" title="3. Federated learning"></a>3. Federated learning</h2><p><a href="https://github.com/FedML-AI/FedML">github.com/FedML-AI/FedML</a></p>
<p><a href="http://doc.fedml.ai/#/intro">FedML文档</a></p>
<p><a href="https://github.com/TsingZ0/PFL-Non-IID">github.com/TsingZ0/PFL-Non-IID</a></p>
<p><a href="https://www.bilibili.com/video/BV1jK411N7gS/">FedML联邦机器学习框架视频教学全集 fedml.ai</a></p>
<p><a href="https://github.com/FederatedAI/FATE">github.com/FederatedAI/FATE</a></p>
<p><a href="https://blog.csdn.net/weixin_45439861/article/details/100670390">只看这一篇就够：快速了解联邦学习技术及应用实践</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/65403693">联邦学习的研究及应用</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/97854070#:~:text=Communication-Efficient%20Learning%20of%20Deep%20Networks,from%20Decentralized%20Data%20Federated%20Averaging%E7%AE%97%E6%B3%95%E6%80%BB%E5%85%B1%E6%9C%89%E4%B8%89%E4%B8%AA%E5%9F%BA%E6%9C%AC%E7%9A%84%E5%8F%82%E6%95%B0%EF%BC%8CC%EF%BC%880%E5%88%B01%EF%BC%89%E6%8E%A7%E5%88%B6%E6%9C%89%E5%A4%9A%E5%B0%91%E6%AF%94%E4%BE%8B%E7%9A%84%E7%9A%84%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%8F%82%E4%B8%8E%E4%BC%98%E5%8C%96%EF%BC%8CE%E6%8E%A7%E5%88%B6%E6%AF%8F%E4%B8%80%E8%BD%AE%E5%A4%9A%E5%B0%91%E8%BD%AESGD%E9%9C%80%E8%A6%81%E5%9C%A8%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%BF%90%E8%A1%8C%EF%BC%8CB%E6%98%AF%E6%AF%8F%E4%B8%80%E8%BD%AE%E7%9A%84Mini-Batch%E7%9A%84%E6%95%B0%E7%9B%AE%E5%A4%A7%E5%B0%8F%E3%80%82">2019联邦学习综述</a></p>
<p><a href="https://www.birentech.com/news/104.html">联邦学习模型在医学图像处理领域中的应用实例分析</a></p>
<p><a href="https://blog.csdn.net/lgzlgz3102/article/details/117433511">联邦学习在视觉领域的应用</a></p>
<p><a href="https://cn.fedai.org/cases/computer-vision-platform-powered-by-federated-learning/">基于联邦学习的计算机视觉平台</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/65403693">【技术观点】联邦学习的研究及应用</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/97854070#:~:text=Communication-Efficient%20Learning%20of%20Deep%20Networks,from%20Decentralized%20Data%20Federated%20Averaging%E7%AE%97%E6%B3%95%E6%80%BB%E5%85%B1%E6%9C%89%E4%B8%89%E4%B8%AA%E5%9F%BA%E6%9C%AC%E7%9A%84%E5%8F%82%E6%95%B0%EF%BC%8CC%EF%BC%880%E5%88%B01%EF%BC%89%E6%8E%A7%E5%88%B6%E6%9C%89%E5%A4%9A%E5%B0%91%E6%AF%94%E4%BE%8B%E7%9A%84%E7%9A%84%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%8F%82%E4%B8%8E%E4%BC%98%E5%8C%96%EF%BC%8CE%E6%8E%A7%E5%88%B6%E6%AF%8F%E4%B8%80%E8%BD%AE%E5%A4%9A%E5%B0%91%E8%BD%AESGD%E9%9C%80%E8%A6%81%E5%9C%A8%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%BF%90%E8%A1%8C%EF%BC%8CB%E6%98%AF%E6%AF%8F%E4%B8%80%E8%BD%AE%E7%9A%84Mini-Batch%E7%9A%84%E6%95%B0%E7%9B%AE%E5%A4%A7%E5%B0%8F%E3%80%82">2019联邦学习综述</a></p>
<h2 id="4-Meta-learning"><a href="#4-Meta-learning" class="headerlink" title="4. Meta learning"></a>4. Meta learning</h2><p><a href="https://easyai.tech/ai-definition/meta-learning/">easyai</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/136975128">一文入门元学习（Meta-Learning）（附代码）</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/181709693#:~:text=MAML%EF%BC%8C%E5%85%A8%E7%A7%B0%E5%91%BC%E5%8F%AB%E5%81%9A%20Model-Agnostic%20Meta-Learning%20%EF%BC%8C%E6%84%8F%E6%80%9D%E5%B0%B1%E6%98%AF%20%E6%A8%A1%E5%9E%8B%E6%97%A0%E5%85%B3%E7%9A%84%E5%85%83%E5%AD%A6%E4%B9%A0%E3%80%82,%E6%89%80%E4%BB%A5MAML%E5%8F%AF%20%E5%B9%B6%E4%B8%8D%E6%98%AF%E4%B8%80%E4%B8%AA%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%A8%A1%E5%9E%8B%20%EF%BC%8C%E5%80%92%E6%98%AF%E6%9B%B4%E5%83%8F%E4%B8%80%E7%A7%8D%20%E8%AE%AD%E7%BB%83%E6%8A%80%E5%B7%A7%20%E3%80%82">[meta-learning] 对MAML的深度解析</a></p>
<p><a href="https://github.com/sudharsan13296/Hands-On-Meta-Learning-With-Python">github.com/sudharsan13296/Hands-On-Meta-Learning-With-Python</a></p>
<p><a href="https://github.com/floodsung/Meta-Learning-Papers">github.com/floodsung/Meta-Learning-Papers</a></p>
<p><a href="https://github.com/sudharsan13296/Awesome-Meta-Learning">github.com/sudharsan13296/Awesome-Meta-Learning</a></p>
<p><a href="https://www.pianshen.com/article/7537868304/">小样本学习（Few-shot Learning）与元学习(meta-learning)初步</a></p>
<p><a href="https://blog.csdn.net/sdu_hao/article/details/104449203">元学习与小样本学习 | (1) 元学习(Meta Learning)概述</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/70044607">元学习（Meta Learning）最全论文、视频、书籍资源整理</a></p>
<h2 id="5-paddlepaddle"><a href="#5-paddlepaddle" class="headerlink" title="5. paddlepaddle"></a>5. paddlepaddle</h2><p><a href="https://aistudio.baidu.com/aistudio/lhycourse">李宏毅教程</a></p>
<h2 id="6-人体姿态估计"><a href="#6-人体姿态估计" class="headerlink" title="6. 人体姿态估计"></a>6. 人体姿态估计</h2><p><a href="https://zhuanlan.zhihu.com/p/270935572">人体姿态估计论文笔记-CPN</a></p>
<p><a href="https://www.pianshen.com/article/5362139895/">『算法学习』CPN：Cascaded Pyramid Network for Multi-Person Pose Estimation</a></p>
<p><a href="https://www.cnblogs.com/hellcat/p/10138036.html">『关键点检测』CPN：Cascaded Pyramid Network for Multi-Person Pose Estimation</a></p>
<p><a href="https://blog.csdn.net/xu_fu_yong/article/details/93169030">CPN:Cascaded Pyramid Network for Multi-Person Pose Estimation_及CPN实现</a></p>
<p><a href="https://www.aiuai.cn/aifarm446.html">论文阅读 - Cascaded Pyramid Network for Multi-Person Pose Estimation</a></p>
<h2 id="7-目标检测"><a href="#7-目标检测" class="headerlink" title="7. 目标检测"></a>7. 目标检测</h2><p><a href="https://zhuanlan.zhihu.com/p/24916786">图解yolo</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/35325884">目标检测|YOLOv2原理与实现(附YOLOv3)</a></p>
<p><a href="https://blog.csdn.net/zijin0802034/article/details/77097894">YOLO9000: Better, Faster, Stronger</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/47575929">YOLOv2 / YOLO9000 深入理解</a></p>
<p><a href="https://www.jianshu.com/p/d13ae1055302">yolov3深入理解</a></p>
<p><a href="https://www.jianshu.com/p/043966013dde">yolov3详解</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/63024247">锚框：Anchor box综述</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/145842317">捋一捋pytorch官方FasterRCNN代码</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzA4MjY4NTk0NQ==&amp;mid=2247493955&amp;idx=1&amp;sn=82133ce8bbbd1872199a5a50f2a37f71&amp;chksm=9f8353d5a8f4dac3d0d8c2d618952d0d010450c82d4efb178a49e4b80192680bf98c2787e1f7&amp;mpshare=1&amp;scene=23&amp;srcid=0407AjRmMHbhPklvpx9iNi5C&amp;sharer_sharetime=1617772180171&amp;sharer_shareid=8c69c1f41758aecb75107bb31071c464#rd">Towards Open World Object Detection -CVPR2021 Oral（开放世界中的目标检测）</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/42553957">Cascade R-CNN 详细解读</a></p>
<h2 id="8-transformer"><a href="#8-transformer" class="headerlink" title="8. transformer"></a>8. transformer</h2><p><a href="https://zhuanlan.zhihu.com/p/61440116">计算机视觉中attention机制的理解</a></p>
<p><a href="https://www.jianshu.com/p/9b87b945151e">transformer模型讲解</a></p>
<p><a href="http://jalammar.github.io/illustrated-transformer/">The Illustrated Transformer</a></p>
<h2 id="9-CAM"><a href="#9-CAM" class="headerlink" title="9. CAM"></a>9. CAM</h2><p><a href="https://zhuanlan.zhihu.com/p/75894080">PyTorch的hook及其在Grad-CAM中的应用</a></p>
<h2 id="10-GNN"><a href="#10-GNN" class="headerlink" title="10. GNN"></a>10. GNN</h2><p><a href="https://developer.huaweicloud.com/hero/forum.php?mod=viewthread&amp;tid=109580">2021年必火的图神经网络到底是什么？</a></p>
<p><a href="https://jonathan-hui.medium.com/applications-of-graph-neural-networks-gnn-d487fd5ed17d">Applications of Graph Neural Networks (GNN)</a></p>
<p><a href="https://github.com/graphdeeplearning/benchmarking-gnns">github.com/graphdeeplearning/benchmarking-gnns</a></p>
<p><a href="https://github.com/graphdeeplearning/benchmarking-gnns/blob/master/docs/02_download_datasets.md">datasets</a></p>
<p><a href="https://github.com/thunlp/GNNPapers">GNNPapers</a></p>
<p><a href="https://github.com/thunlp/GNNPapers#computer-vision">GNNPapers#computer-vision</a></p>
<h2 id="6-杂项"><a href="#6-杂项" class="headerlink" title="6. 杂项"></a>6. 杂项</h2><p><a href="https://zhuanlan.zhihu.com/p/50142573">L1正则化引起稀疏解的多种解释</a></p>
<p><a href="https://www.geeksforgeeks.org/how-l1-regularization-brings-sparsity/">How L1 Regularization brings Sparsity</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/105152354">自编码器</a></p>
<p><a href="https://blog.csdn.net/qq_21611223/article/details/115458913">全局平均池化能否完全代替全连接</a></p>
<p><a href="https://www.cnblogs.com/silence-cho/p/10926248.html">opencv-python学习基础知识</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/83131026">PyTorch中的损失函数—L1Loss /L2Loss/SmoothL1Loss</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/142755610">IoU、GIoU、DIoU、CIoU</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/25110150">聊一聊深度学习的weight initialization</a></p>
<p><a href="https://www.zhihu.com/question/315611053">了解/从事机器学习/深度学习系统相关的研究需要什么样的知识结构？</a></p>
<p><a href="https://www.jiqizhixin.com/articles/2018-06-20-4">这是一份通俗易懂的知识图谱技术与应用指南</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzU2NTc5MjIwOA==&amp;mid=2247517502&amp;idx=2&amp;sn=5066c1e5cc46414736b4028e89328edd&amp;chksm=fcb49981cbc310978f2c3f15d15858ffc49afa0757a03d76941e2b586c61af94e51f97e5cf76&amp;mpshare=1&amp;scene=23&amp;srcid=0803pT8dWxbEbZULsblTrW5k&amp;sharer_sharetime=1627987544216&amp;sharer_shareid=8c69c1f41758aecb75107bb31071c464#rd">新突破！Swin-UNet：基于纯 Transformer 结构的医学图像分割网络</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzU2NTc5MjIwOA==&amp;mid=2247517502&amp;idx=3&amp;sn=504f3f8bef04f3219dc8f926b786e1bc&amp;chksm=fcb49981cbc3109752ba674e677359f739abe086becca116c4563dfc25caee609ec98554295e&amp;mpshare=1&amp;scene=23&amp;srcid=0803MqpZnMReJaAMRXuyEdaH&amp;sharer_sharetime=1627987652283&amp;sharer_shareid=8c69c1f41758aecb75107bb31071c464#rd">港中文等提出：开放世界实体分割</a></p>
<p><a href="https://blog.csdn.net/qq_30638831/article/details/83625627">空洞卷积</a></p>
<p><a href="https://www.jianshu.com/p/2b968e7a1715">感受野</a></p>
<p><a href="https://blog.csdn.net/litt1e/article/details/105817224">深入理解Batch Normalization原理与作用</a></p>
<p><a href="https://blog.csdn.net/Li_yi_chao/article/details/80756414">数据标准化</a></p>
<p><a href="https://blog.csdn.net/u010417185/article/details/79533539">深度学习中Batch size对训练效果的影响</a></p>
<p><a href="https://www.zhihu.com/question/32673260">深度学习中的batch的大小对学习效果有何影响？</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/64864995">学习率和batchsize如何影响模型的性能？</a></p>
<h1 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h1><p><a href="https://www.bilibili.com/video/BV1dW411M7xL?p=45&amp;spm_id_from=pageDriver">尚硅谷linux教程</a></p>
<h1 id="stanford"><a href="#stanford" class="headerlink" title="stanford"></a>stanford</h1><p><a href="https://c.d2l.ai/stanford-cs329p/">practical machine learning</a></p>
<h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><p><a href="https://labuladong.github.io/algo/3/23/57/">labuladong</a></p>
<p><a href="https://mp.weixin.qq.com/s/qwaYOFIksFVqZtA_nisl6g">编程熊</a></p>
<p><a href="https://codetop.cc/home">codetop</a></p>
<h1 id="stackoverflow"><a href="#stackoverflow" class="headerlink" title="stackoverflow"></a>stackoverflow</h1><p><a href="https://stackoverflow.com/questions/57189925/sys-modules-name-classname-what-does-it-actually-do">sys.modules[<strong>name</strong>] = _classname(). What does it actually do?</a></p>
<p><a href="https://stackoverflow.com/questions/448271/what-is-init-py-for?rq=1">What is <strong>init</strong>.py for?</a></p>
<p><a href="https://stackoverflow.com/questions/17020115/how-to-use-setattr-correctly-avoiding-infinite-recursion">How to use <strong>setattr</strong> correctly, avoiding infinite recursion</a></p>
<p><a href="https://stackoverflow.com/questions/16981921/relative-imports-in-python-3">Relative imports in Python 3</a></p>
]]></content>
      <categories>
        <category>常用链接</category>
      </categories>
      <tags>
        <tag>常用链接</tag>
      </tags>
  </entry>
  <entry>
    <title>王争数据结构与算法学习笔记-冒泡、插入、选择排序</title>
    <url>/2021/08/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%8E%8B%E4%BA%89%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%86%92%E6%B3%A1%E3%80%81%E6%8F%92%E5%85%A5%E3%80%81%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<p>插入排序和冒泡排序的时间复杂度相同，都是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>​，在实际的软件开发里，为什么我们更倾向于使用插入排序算法而不是冒泡排序算法呢？</p>
<span id="more"></span>
<p>冒泡排序和插入排序不论如何优化，元素的交换次数是一个固定的值，即原始数据的<strong>逆序度</strong>。但是从代码的实现角度来看，冒泡排序的数据交换要比插入排序的数据移动复杂，冒泡排序需要3个赋值操作，而插入排序只要1个。比如如下的代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 冒泡排序中的数据交换操作</span></span><br><span class="line"><span class="keyword">if</span> (a[i] &gt; a[i+<span class="number">1</span>]) &#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = a[i];</span><br><span class="line">    a[i] = a[i + <span class="number">1</span>];</span><br><span class="line">    a[i + <span class="number">1</span>] = tmp;</span><br><span class="line">    flag = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入排序中的数据移动操作</span></span><br><span class="line"><span class="keyword">if</span> (a[i] &gt; value) &#123;</span><br><span class="line">    a[i+<span class="number">1</span>] = a[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假设执行一个赋值语句的时间粗略记为1个单位时间，然后使用冒泡和插入对同一个逆序度为k的数组进行排序。用冒泡排序，需要k次交换操作，每次需要3次赋值语句，所以交换操作总耗时为3k单位时间，而插入排序中数据移动操作只需要k个单位时间。</p>
<p>虽然冒泡排序和插入排序在时间复杂度上是一样的，都是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>​，但是如果我们希望把性能优化做到极致，那肯定首选插入排序。</p>
<table>
<thead>
<tr>
<th></th>
<th>是原地排序？</th>
<th>是否稳定？</th>
<th>最好    最坏    平均</th>
</tr>
</thead>
<tbody>
<tr>
<td>冒泡排序</td>
<td>是</td>
<td>是</td>
<td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>​  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>​ <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>​</td>
</tr>
<tr>
<td>插入排序</td>
<td>是</td>
<td>是</td>
<td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>​  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>​ <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>​</td>
</tr>
<tr>
<td>选择排序</td>
<td>是</td>
<td>否</td>
<td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>​ <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>​ <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>​</td>
</tr>
</tbody>
</table>
<p>三种时间复杂度均为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>的排序算法中，冒泡、选择排序可能就纯粹停留在理论层面，学习的目的也是为了开拓思维，实际开发用的不多，但是插入排序还是很有用的。</p>
<p>如果将上述的三个算法使用链表来实现，需要确定一个前提：在交换数据的时候，是交换结点的位置还是交换两个结点的value值？如果是<strong>交换结点的值</strong>，那么对于冒泡排序、选择排序的时间复杂度和空间复杂度没有明显变化，而插入排序不涉及交换元素，插入元素的时候由于链表的特性，时间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>​​，但是排序完毕之后需要倒置链表；如果是<strong>交换结点的位置</strong>，对于冒泡排序和选择排序，交换元素操作相比于数组更加复杂，而插入排序的分析和交换结点的值的情况下的分析类似。</p>
<h1>如何分析一个“排序算法”？</h1>
<h2 id="排序算法的执行效率">排序算法的执行效率</h2>
<ol>
<li>
<p><strong>最好情况、最坏情况、平均情况时间复杂度</strong></p>
<p>有序度不同的数据，对于排序的执行时间有影响，我们要知道排序算法在不同数据下的性能表现。</p>
</li>
<li>
<p><strong>时间复杂度的系数、常数、低阶</strong></p>
<p>在实际的软件开发中，我们的排序可能是10个、100个、1000个这样规模很小的数据，所以在同一阶时间复杂度的排序算法性能对比的时候，就要将系数、常数、低阶也考虑进来。</p>
</li>
<li>
<p><strong>比较次数和交换（或移动）次数</strong></p>
<p>基于比较的排序算法的执行过程，会涉及两种操作，一种是元素的比较大小，另一种是元素交换或移动。所以，如果我们在分析排序算法的执行效率的时候，应该把比较次数和交换（或移动）次数也考虑进去。</p>
</li>
</ol>
<h2 id="排序算法的稳定性">排序算法的稳定性</h2>
<p>很多数据结构示例中，我们排序都用的是整数来举例，但是在真正的软件开发中，我们要排序的往往不是单纯的整数，而是一组对象，我们需要按照对象的某个属性来排序。</p>
<p>比如说，我们现在要给电商交易系统中的“订单”排序。订单有两个属性，一个是下单时间，另一个是订单金额。如果我们现在有 10 万条订单数据，我们希望按照金额从小到大对订单数据排序。对于金额相同的订单，我们希望按照下单时间从早到晚有序。这样一个排序需求，我们可以使用稳定排序算法，首先按照<strong>下单时间</strong>对订单排序，然后使用稳定排序算法，按照<strong>订单金额</strong>重新排序。</p>
<h1>冒泡排序</h1>
<p>如何分析冒泡排序的平均时间复杂度？</p>
<p>对于包含n个数据的数组，这n个数据有n!中排列方式，同的排列方式，冒泡排序执行的时间不同，如果用概率论方法定量分析平均时间复杂度，涉及的数学推理和计算就会很复杂。可以通过“<strong>有序度</strong>”和“<strong>逆序度</strong>”这两个概念来进行分析。</p>
<p>有序度是数组中具有有序关系的元素对的个数。如：2，4，3，1，5，6这组数据的有序度为11，因为其有序元素对的个数为11个，分别是：</p>
<p>(2,4)  (2,3)  (2,5)  (2,6)  (4,5)  (4,6)  (3,5)  (3,6)  (1,5)  (1,6)  (5,6)</p>
<p>同理，对于一个倒序排列的数组，比如 6，5，4，3，2，1，<strong>有序度</strong>是 0；对于一个完全有序的数组，比如 1，2，3，4，5，6，有序度就是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>∗</mo><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">n * (n-1)/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mord">/</span><span class="mord">2</span></span></span></span>，也就是 15。我们把这种完全有序的数组的有序度叫作<strong>满有序度</strong>。<strong>逆序度=满有序度-有序度</strong>。</p>
<p>冒泡排序包含两个操作原子，<strong>比较</strong>和<strong>交换</strong>。每交换依次，有序度就加1，不管算法怎么改，交换次数总是确定的，即<strong>逆序度</strong>，也就是<strong>n*(n-1) / 2-初始有序度</strong>。</p>
<p>对于包含n个数据的数组进行冒泡排序，最坏的情况下，初始状态有序度是0，所以要进行<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>∗</mo><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">n * (n-1)/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mord">/</span><span class="mord">2</span></span></span></span>，最好的情况下，初始状态的有序度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>∗</mo><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">n * (n-1)/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mord">/</span><span class="mord">2</span></span></span></span>，就不需要进行交换，我们可以取中间值<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>∗</mo><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">n * (n-1)/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mord">/</span><span class="mord">2</span></span></span></span>，来表示初始有许多有既不是很高也不是很低的平均情况。</p>
<p>换句话说，平均情况下，需要 n*(n-1)/4 次交换操作，比较操作肯定要比交换操作多，而复杂度的上限是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>​​，所以平均情况下的时间复杂度就是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>​​。</p>
<h1>插入排序</h1>
<p>插入排序的移动操作次数总是固定的，等于<strong>逆序度</strong>，比如初始序列为：4、5、6、1、3、2。数据移动的个数总和为10=3+3+4.</p>
<p>插入排序最好的情况下的时间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>，最坏的情况下时间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>。</p>
<h1>选择排序</h1>
<p>选择排序每一趟都会从无序序列中寻找最小或者最大值然后插入有序序列中，其最好、最坏的时间复杂度都是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，选择排序不是稳定的算法，比如5,8,5,2,9，使用选择排序的话，最终第一个5就会替换到2的位置。</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>王争数据结构与算法学习笔记-递归</title>
    <url>/2021/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%8E%8B%E4%BA%89%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E9%80%92%E5%BD%92/</url>
    <content><![CDATA[<p>递归不需要我们去从最高层到最底层屡清楚，我们只需要考虑的是当前层与上一层之间的关系，将这种关系表示出来，然后将终止递归的条件确定清楚即可。至于一层一层往下调交给计算机来处理吧！试图想搞清楚计算机每一步都是怎么执行的，这样就很容易被绕进去。</p>
<span id="more"></span>
<p>现在很多 App 都有推荐注册返佣金的这个功能，用户 A 推荐用户 B 来注册，用户 B 又推荐了用户 C 来注册。我们可以说，用户 C 的“最终推荐人”为用户 A，用户 B 的“最终推荐人”也为用户 A，而用户 A 没有“最终推荐人”。一般来说，我们会通过数据库来记录这种推荐关系。在数据库表中，我们可以记录两列数据，其中 actor_id 表示用户 id，referrer_id 表示推荐人 id。那么，给定一个用户 ID，如何查找这个用户的“最终推荐人”？</p>
<p>可以使用如下的解决方案：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">findRootReferrerId</span><span class="params">(<span class="keyword">long</span> actorId)</span> </span>&#123;</span><br><span class="line">  Long referrerId = select referrer_id from [table] where actor_id = actorId;</span><br><span class="line">  <span class="keyword">if</span> (referrerId == <span class="keyword">null</span>) <span class="keyword">return</span> actorId;</span><br><span class="line">  <span class="keyword">return</span> findRootReferrerId(referrerId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不过在实际项目中，上面的代码并不能工作：</p>
<p>第一，如果递归很深，可能会有堆栈溢出的问题。</p>
<p>第二，如果数据库里存在脏数据，我们还需要处理由此产生的无限递归问题。比如 demo 环境下数据库中，测试工程师为了方便测试，会人为地插入一些数据，就会出现脏数据。如果 A 的推荐人是 B，B 的推荐人是 C，C 的推荐人是 A，这样就会发生死循环。这个问题可以限制递归深度或者尾递归解决，不过还可以用一个更高级的解决方法：自动检测A-B-C-A这种“环”的存在。</p>
<h1>递归注意点</h1>
<h2 id="递归代码要警惕堆栈溢出">递归代码要警惕堆栈溢出</h2>
<p>在实际的软件开发中，编写递归代码时，我们会遇到很多问题，比如堆栈溢出。而堆栈溢出会造成<code>系统性崩溃</code>，后果会非常严重。</p>
<p>函数调用会使用栈来保存临时变量。每调用一个函数，都会将临时变量封装为<code>栈帧</code>压入内存栈，等函数执行完成返回时，才出栈。<code>系统栈</code>或者<code>虚拟机栈</code>空间一般都不大。如果递归求解的数据规模很大，调用层次很深，一直压入栈，就会有<code>堆栈溢出</code>的风险。</p>
<p><code>如何避免堆栈溢出呢？</code></p>
<!-- more -->
<ol>
<li>
<p>可以通过在代码中限制递归调用的最大深度的方式来解决这个问题。递归调用超过一定深度（比如 1000）之后，我们就不继续往下再递归了，直接返回报错。如下伪代码所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 全局变量，表示递归的深度</span></span><br><span class="line"><span class="keyword">int</span> depth = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    ++depth;</span><br><span class="line">    <span class="keyword">if</span> (depth &gt; <span class="number">1000</span>) <span class="keyword">throw</span> exception;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">f</span>(n - <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但这种做法并不能完全解决问题，因为最大允许的递归深度跟当前线程剩余的栈空间大小有关，事先无法计算。如果实时计算，代码过于复杂，就会影响代码的可读性。所以，如果最大深度比较小，比如 10、50，就可以用这种方法，否则这种方法并不是很实用。</p>
</li>
<li>
<p>使用<strong>尾递归</strong>的方式。（参考：<a href="https://segmentfault.com/a/1190000022879214">https://segmentfault.com/a/1190000022879214</a> ）</p>
<p><strong>在函数中return一个函数后，当前函数在栈内的调用记录会被删除，当前函数的执行上下文会从调用栈弹出</strong>。一般的递归在函数体中断点能够看到在栈内会创建大量的执行上下文并且不销毁（这就是造成栈溢出的原因）；而尾递归是在栈内增加函数执行上下文，然后在该函数返回函数时，销毁当前函数执行上下文，创建返回的函数的执行上下文。所以尾递归中只有一个活跃的执行上下文。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 函数0是尾递归</span></span><br><span class="line"><span class="function">function <span class="title">a</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> r = <span class="built_in">c</span>()</span><br><span class="line">    <span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数1是尾递归</span></span><br><span class="line">function <span class="built_in">a</span>()&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">c</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数2不是尾递归</span></span><br><span class="line">function <span class="built_in">a</span>()&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">c</span>() * <span class="number">20</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数3不是尾递归</span></span><br><span class="line">function <span class="built_in">a</span>()&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">c</span>() || <span class="built_in">b</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面对于判断是否为尾递归都是自己在safari实际测试之后的结果。针对上面测试的结果总结一下：函数2不是尾递归，是因为c()调用后还需要进一步计算。函数3不是尾递归，是因为c()调用之后还有判断的动作以及可能的对于c的调用。而函数0和函数1是尾递归是因为返回的是一个函数或者一个已经计算好的值，而不需要再做多余的判断和计算。</p>
<p>下面使用尾递归来优化如下的累加项代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fn</span><span class="params">(n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> n + <span class="built_in">fn</span>(n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>尾递归代码(针对数组里面所有项的累加递归)：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fn</span><span class="params">(arr, sum = <span class="number">0</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr.length === <span class="number">0</span>) <span class="keyword">return</span> sum;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">fn</span>(arr.<span class="built_in">slice</span>(<span class="number">1</span>), arr[<span class="number">0</span>] + sum);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">fn</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])</span><br></pre></td></tr></table></figure>
<p>尾递归也有自己的一些缺陷。如尾递归是一个隐式行为，如果代码存在死循环尾递归调用，爆栈后难以被开发者察觉；堆栈信息会丢失，造成调试困难。还有目前各大浏览器厂商对尾递归的支持和兼容性不太好。所以在尾递归目前还不被各大浏览器支持的情况下，可以对递归的一些重复内容做优化。</p>
</li>
</ol>
<h2 id="递归代码要警惕重复计算">递归代码要警惕重复计算</h2>
<p>使用递归算法实现斐波那契数列代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (N == <span class="number">1</span> || N == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">fib</span>(N - <span class="number">1</span>) + <span class="built_in">fib</span>(N - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>将n=20的递归树画出来，如下图所示（图取自https://labuladong.github.io/algo/3/23/57/）：</p>
<p><img src="/2021/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%8E%8B%E4%BA%89%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E9%80%92%E5%BD%92/%E9%80%92%E5%BD%92%E6%A0%91.png" alt="递归树"></p>
<p>比如计算<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mn>19</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(19)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord">1</span><span class="mord">9</span><span class="mclose">)</span></span></span></span>​就需要计算<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mn>17</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(17)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord">1</span><span class="mord">7</span><span class="mclose">)</span></span></span></span>​和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mn>18</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(18)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord">1</span><span class="mord">8</span><span class="mclose">)</span></span></span></span>​，而计算<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mn>18</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(18)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord">1</span><span class="mord">8</span><span class="mclose">)</span></span></span></span>​需要计算<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mn>17</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(17)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord">1</span><span class="mord">7</span><span class="mclose">)</span></span></span></span>​和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mn>16</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(16)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord">1</span><span class="mord">6</span><span class="mclose">)</span></span></span></span>​，这里的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mn>17</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(17)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord">1</span><span class="mord">7</span><span class="mclose">)</span></span></span></span>被重复计算了多次，这就是重复计算的问题。</p>
<p>为了避免重复计算，可以通过一个数据结构来保存已经求解的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span>。当递归调用<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span>​的时候，先看下是否已经求解过。如果是，则直接从散列表中取值返回，不需要重复计算。</p>
<p>参考：</p>
<p><a href="https://labuladong.github.io/algo/3/23/57/">https://labuladong.github.io/algo/3/23/57/</a></p>
<p>在时间效率上，递归代码里多了很多函数调用，当这些函数调用的数量较大时，就会积聚成一个可观的时间成本。在空间复杂度上，因为递归调用一次就会在内存栈中保存一次现场数据，所以在分析递归代码空间复杂度时，需要额外考虑这部分的开销</p>
<h1>将递归代码改为非递归代码</h1>
<p>递归有利有弊，利是递归便于理解，写起来简洁；弊是空间复杂度高、有堆栈溢出的风险、存在重复计算、过多的函数调用会耗时较多时间等。所以在开发过程中，我们要根据实际情况来确定是否用递归的方式来实现。</p>
<p>因为递归本身就是借助栈来实现的，只不过我们使用的栈是系统或者虚拟机本身提供的，我们没有感知罢了。如果我们自己在内存堆上实现栈，手动模拟入栈、出栈过程，这样任何递归代码都可以改写成看上去不是递归代码的样子。</p>
<p><code>数据规模较大的情况最好使用非递归来实现。</code></p>
<h1>思考</h1>
<p>我们平时调试代码喜欢使用 IDE 的单步跟踪功能，像规模比较大、递归层次很深的递归代码，几乎无法使用这种调试方式。对于递归代码，有什么好的调试方法呢？</p>
<blockquote>
<p>1.打印日志发现，递归值。<br>
2.结合条件断点进行调试。</p>
</blockquote>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>王争数据结构与算法学习笔记-队列</title>
    <url>/2021/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%8E%8B%E4%BA%89%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<p>CPU的资源有限，任务处理速度与线程的个数不是线性相关，过多的线程反而会导致CPU的频繁切换，处理性能下降。所以，线程池的大小一般都是综合考虑要处理任务的特点和硬件环境来实现设置的。</p>
<span id="more"></span>
<blockquote>
<p>一般有两种处理策略。第一种是非阻塞的处理方式，直接拒绝任务请求；另一种是阻塞的处理方式，将请求排队，等到有空闲线程时，取出排队的请求继续处理。那么如何处理排队的请求呢？</p>
<p>我们希望公平地处理每个排队的请求，先进者先服务，所以队列这种数据结构很适合来存储排队请求。队列有基于链表和基于数组这两种实现方式。这两种实现方式对于排队请求又有什么区别呢？</p>
<p>基于链表的实现方式，可以实现一个支持无限排队的无界队列（unbounded queue），但是可能会导致过多的请求排队等待，请求处理的响应时间过长。所以，针对响应时间比较敏感的系统，基于链表实现的无限排队的线程池是不合适的。</p>
<p>而基于数组实现的有界队列（bounded queue），队列的大小有限，所以线程池中排队的请求超过队列大小时，接下来的请求就会被拒绝，这种方式对响应时间敏感的系统来说，就相对更加合理。这种方式的不好的地方就是：如果某一时刻任务太多，会造成任务的丢失。不过，设置一个合理的队列大小，也是非常有讲究的。队列太大导致等待的请求太多，请求得不到及时的响应，用户体验就会下降；队列太小会导致无法充分利用系统资源、发挥最大性能。当队列阻塞时，队列所在的服务端可以发给客户端一个 500 或者 503 的状态码，然后客户端收到此状态码后可以一直尝试重发请求，直至请求被处理。当然这并不是最高效的处理方式。</p>
<p>除了前面讲到队列应用在线程池请求排队的场景之外，队列可以应用在任何有限资源池中，用于排队请求，比如数据库连接池等。<code>实际上，对于大部分资源有限的场景，当没有空闲资源时，基本上都可以通过“队列”这种数据结构来实现请求排队。</code></p>
</blockquote>
<h1>具有某些额外特性的队列</h1>
<p>循环队列</p>
<p>阻塞队列</p>
<p>并发队列</p>
<p>高性能队列 Disruptor、Linux 环形缓存，都用到了循环并发队列；Java concurrent 并发包利用 ArrayBlockingQueue 来实现公平锁。</p>
<h1>顺序队列和链式队列</h1>
<p>使用<code>数组</code>实现的队列是<code>顺序队列</code>，顺序队列的删除操作都是删除队列中的第一个元素，如果每一次删除都需要搬移数据的话，时间复杂度将变成<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>，所以我们可以等到无法入队之后一起搬移从而得到优化。</p>
<p>具体而言，实现<code>顺序队列</code>的时候我们定义了两个指针：tail指针和head指针，如果删除了元素，head指针加一；如果插入了元素，tail指针加一，一旦tail指针移动到了数组的最后，再次有新的元素入队时，我们就将整体head-tail之间的数据搬移到数组中以0索引开头的位置。</p>
<p>这种实现思路，出队操作的时间复杂度仍然为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>​，但是入队操作就需要具体分析一下了，因为入队操作可能会导致整体数据的移动。假设预先定义的数组长度为n，那么在前n次入队操作都不会导致数据的搬移，因为即便是有出队，也只是移动队头指针head，而队尾指针会随着入队的数据增加而右移。当第n+1次入队操作的时候，需要首先将所有的数据移动<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn><mo>−</mo><mi>h</mi><mi>e</mi><mi>a</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">n-1-head</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">h</span><span class="mord mathdefault">e</span><span class="mord mathdefault">a</span><span class="mord mathdefault">d</span></span></span></span>格，即一共移动<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo>−</mo><mi>h</mi><mi>e</mi><mi>a</mi><mi>d</mi><mo stretchy="false">)</mo><mo>∗</mo><mo stretchy="false">(</mo><mi>t</mi><mi>a</mi><mi>i</mi><mi>l</mi><mo>+</mo><mn>1</mn><mo>−</mo><mi>h</mi><mi>e</mi><mi>a</mi><mi>d</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(n-1-head)*(tail+1-head)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">h</span><span class="mord mathdefault">e</span><span class="mord mathdefault">a</span><span class="mord mathdefault">d</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">h</span><span class="mord mathdefault">e</span><span class="mord mathdefault">a</span><span class="mord mathdefault">d</span><span class="mclose">)</span></span></span></span>​格，借助王争老师的手绘图表示如下（强烈建议购买王争老师在极客时间的<code>数据结构与算法之美</code>原作）：</p>
<p><img src="/2021/08/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%8E%8B%E4%BA%89%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E9%98%9F%E5%88%97/%E9%A1%BA%E5%BA%8F%E9%98%9F%E5%88%97.png" alt="王争老师的手绘图"></p>
<p>对于这种情况下的时间复杂度可以使用摊还分析法来分析，当<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>a</mi><mi>i</mi><mi>l</mi><mo>=</mo><mo>=</mo><mi>s</mi><mi>i</mi><mi>z</mi><mi>e</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">tail == size-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.74285em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mord mathdefault">e</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>​时，执行：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = head; i &lt; size; i++) &#123;</span><br><span class="line">    queue[i - head] = queue[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 搬完之后更新head和tail</span></span><br><span class="line">tail -= head;</span><br><span class="line">head = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>移动一个元素的时间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>​，那么将所有的移动时间均摊到每一个节点的话，总体的时间复杂度就是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>​​。</p>
<h1>循环队列</h1>
<p>在上面讲到的顺序队列中，我们出队之后不马上搬移数据，而是等到队尾指针到达数组最后的时候才移动，这样可以减少很多移动数据而花费的时间，但是最后还是移动了，那么我们能否避免移动数据呢？</p>
<p>答案是可以的，我们可以使用循环队列的实现方式来避免数据的移动。在顺序队列中，判断队列的状态代码如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断队列空</span></span><br><span class="line"><span class="keyword">if</span> (head == tail) &#123;&#125;</span><br><span class="line"><span class="comment">// 判断队列满(无法插入数据，而不是需要移动数据的条件)</span></span><br><span class="line"><span class="keyword">if</span> (tail - head + <span class="number">1</span>== size) &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>到了循环队列，我们判断队列的状态代码如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断队列空</span></span><br><span class="line"><span class="keyword">if</span> (head == tail) &#123;&#125;</span><br><span class="line"><span class="comment">// 判断队列满</span></span><br><span class="line"><span class="keyword">if</span> ((tail + <span class="number">1</span>) % size == head) &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>判断队列空容易理解，但是判断队列满为什么需要模运算呢？我们考虑两种情况：</p>
<ol>
<li>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>a</mi><mi>i</mi><mi>l</mi><mo>&lt;</mo><mi>h</mi><mi>e</mi><mi>a</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">tail &lt; head</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">h</span><span class="mord mathdefault">e</span><span class="mord mathdefault">a</span><span class="mord mathdefault">d</span></span></span></span></p>
<p>这种情况如果<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>a</mi><mi>i</mi><mi>l</mi></mrow><annotation encoding="application/x-tex">tail</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span></span></span></span>再加一个就和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mi>e</mi><mi>a</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">head</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">h</span><span class="mord mathdefault">e</span><span class="mord mathdefault">a</span><span class="mord mathdefault">d</span></span></span></span>重合。</p>
</li>
<li>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>a</mi><mi>i</mi><mi>l</mi><mo>&gt;</mo><mi>h</mi><mi>e</mi><mi>a</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">tail &gt; head</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">h</span><span class="mord mathdefault">e</span><span class="mord mathdefault">a</span><span class="mord mathdefault">d</span></span></span></span></p>
<p>这种情况下，如果<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>a</mi><mi>i</mi><mi>l</mi></mrow><annotation encoding="application/x-tex">tail</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span></span></span></span>的索引值为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>i</mi><mi>z</mi><mi>e</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">size-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.74285em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mord mathdefault">e</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，而<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mi>e</mi><mi>a</mi><mi>d</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">head=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">h</span><span class="mord mathdefault">e</span><span class="mord mathdefault">a</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>，此时其实队列已经满了，但是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>a</mi><mi>i</mi><mi>l</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">tail+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>就超过了数组的范围，而我们需要的是和对头指针比较，而且两者刚好相差了一个队列的长度，这个时候就用模运算来实现。</p>
</li>
</ol>
<p>其实想到这里我们会发现，我们可以用判断语句来代替模运算，这样容易理解，但是代码工程量大的时候就会降低效率，所以与其说是可以用判断语句来代替模运算，不如说模运算可以用来优化这里的判断语句，代码优化需要从编程的点点滴滴做起。</p>
<p>基于数组的循环队列比链式队列应用更加广泛，原因：</p>
<ol>
<li>
<p>CAS（Compare And Swap）比较并替换，是线程并发运行时用到的一种技术，基于数组可以比较原来的head/tail索引，实现线程安全；</p>
</li>
<li>
<p>基于数组的循环队列，利用CAS（Compare And Swap）原子操作. 可以实现一个非常高效的<code>并发队列</code>；</p>
</li>
<li>
<p>数据操作O(1)复杂度，不用搬移数据。</p>
</li>
</ol>
<h1>阻塞队列和并发队列</h1>
<p><code>阻塞队列</code>其实就是在队列基础上增加了阻塞操作。简单来说，就是在队列为空的时候，从队头取数据会被阻塞。因为此时还没有数据可取，直到队列中有了数据才能返回；如果队列已经满了，那么插入数据的操作就会被阻塞，直到队列中有空闲位置后再插入数据，然后再返回。这一功能是否与操作系统的<code>临界区管理</code>中的<code>PV操作</code>似曾相识呢？这其实可以实现一个“生产者-消费者”模型。</p>
<p>这种基于阻塞队列实现的“生产者 - 消费者模型”，可以有效地协调生产和消费的速度。当“生产者”生产数据的速度过快，“消费者”来不及消费时，存储数据的队列很快就会满了。这个时候，生产者就阻塞等待，直到“消费者”消费了数据，“生产者”才会被唤醒继续“生产”。</p>
<p>基于阻塞队列，我们还可以通过协调“生产者”和“消费者”的个数，来提高数据的处理效率。比如前面的例子，我们可以多配置几个“消费者”，来应对一个“生产者”。</p>
<p>在多线程情况下，会有多个线程同时操作队列，这个时候就会存在线程安全问题，那如何实现一个线程安全的队列呢？</p>
<p>阻塞队列可能多个数据同时出队列，线程不安全，可以对入队或者出队加上锁，这样线程安全的队列，叫做<code>并发队列</code>。最简单直接的实现方式是直接在 enqueue()、dequeue() 方法上加锁，但是锁粒度大并发度会比较低，同一时刻仅允许一个存或者取操作。如何实现一个高效的并发队列：</p>
<ol>
<li>基于数组的循环队列(避免数据搬移) ;</li>
<li>CAS原子操作（避免真正的去OS底层申请锁资源）。</li>
</ol>
<p>可以参考这篇文章来了解一下CAS：</p>
<p><a href="https://zhuanlan.zhihu.com/p/85727736">https://zhuanlan.zhihu.com/p/85727736</a></p>
<h1>思考</h1>
<ol>
<li>
<p>除了线程池这种池结构会用到队列排队请求，还有哪些类似的池结构或者场景中会用到队列的排队请求呢？</p>
<blockquote>
<p>临界区管理的PV操作；</p>
<p>先进先出页面替换算法；</p>
<p>作业调度中的作业后备队列；</p>
<p>作业调度、进程调度算法（如先来先服务算法、时间片轮转算法、多级反馈队列算法等）中的就绪队列的实现；</p>
<p>分布式应用中的消息队列，如 kafka 也是一种队列；</p>
<p>考虑使用CAS实现无锁队列，则在入队前，获取tail位置，入队时比较tail是否发生变化，如果否，则允许入队，反之，本次入队失败。出队则是获取head位置，进行CAS；</p>
</blockquote>
</li>
<li>
<p>关于如何实现无锁并发队列，网上有非常多的讨论。如何看待？</p>
<blockquote>
<p>可以使用 CAS + 数组的方式实现.</p>
</blockquote>
</li>
<li>
<p>在循环队列中，判断队列是否满，可以判断<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>t</mi><mi>a</mi><mi>i</mi><mi>l</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mi mathvariant="normal">%</mi><mi>s</mi><mi>i</mi><mi>z</mi><mi>e</mi><mo>=</mo><mo>=</mo><mi>h</mi><mi>e</mi><mi>a</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">(tail + 1)\%size == head</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mord">%</span><span class="mord mathdefault">s</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mord mathdefault">e</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">h</span><span class="mord mathdefault">e</span><span class="mord mathdefault">a</span><span class="mord mathdefault">d</span></span></span></span>是否成立，还有一种说法是创建一个变量来存放当前队列的非空余部分的大小，每一次将其与size比较即可，如何看待这种思路？</p>
<blockquote>
<p>创建一个额外的变量，需要在并行开发的时候进行维护，从这个角度来讲，前者更优。</p>
</blockquote>
</li>
</ol>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>深度学习必读书单</title>
    <url>/2021/08/21/%E5%BF%85%E8%AF%BB%E4%B9%A6%E5%8D%95/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<ol>
<li>
<p><a href="https://book.douban.com/subject/34988786/">智能计算系统</a></p>
<span id="more"></span>
<p><img src="/2021/08/21/%E5%BF%85%E8%AF%BB%E4%B9%A6%E5%8D%95/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E6%99%BA%E8%83%BD%E8%AE%A1%E7%AE%97%E7%B3%BB%E7%BB%9F.png" alt="智能计算系统"></p>
</li>
</ol>
]]></content>
      <categories>
        <category>必读书单</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
        <tag>必读书单</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机内功必读书单</title>
    <url>/2021/08/21/%E5%BF%85%E8%AF%BB%E4%B9%A6%E5%8D%95/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%86%85%E5%8A%9F/</url>
    <content><![CDATA[<h1>OS</h1>
<span id="more"></span>
<ol>
<li>
<p><a href="https://book.douban.com/subject/35208251/">现代操作系统：原理与实现</a></p>
<p><img src="/2021/08/21/%E5%BF%85%E8%AF%BB%E4%B9%A6%E5%8D%95/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%86%85%E5%8A%9F/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%9A%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0.png" alt="现代操作系统：原理与实现"></p>
</li>
</ol>
<h1>Database</h1>
<ol>
<li>
<p><a href="https://book.douban.com/subject/4838430/">数据库系统实现</a></p>
<p><img src="/2021/08/21/%E5%BF%85%E8%AF%BB%E4%B9%A6%E5%8D%95/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%86%85%E5%8A%9F/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0.png" alt="数据库系统实现"></p>
</li>
<li>
<p><a href="https://book.douban.com/subject/30329536/">数据密集型应用系统设计</a></p>
<p><img src="/2021/08/21/%E5%BF%85%E8%AF%BB%E4%B9%A6%E5%8D%95/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%86%85%E5%8A%9F/%E6%95%B0%E6%8D%AE%E5%AF%86%E9%9B%86%E5%9E%8B%E5%BA%94%E7%94%A8%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1.png" alt="数据密集型应用系统设计"></p>
</li>
<li>
<p><a href="https://book.douban.com/subject/1390650/">现代操作系统</a></p>
<p><img src="/2021/08/21/%E5%BF%85%E8%AF%BB%E4%B9%A6%E5%8D%95/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%86%85%E5%8A%9F/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.png" alt="现代操作系统"></p>
</li>
</ol>
<h1>计组</h1>
<ol>
<li>
<p><a href="https://book.douban.com/subject/10441748/">计算机组成与设计</a></p>
<p><img src="/2021/08/21/%E5%BF%85%E8%AF%BB%E4%B9%A6%E5%8D%95/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%86%85%E5%8A%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E8%AE%BE%E8%AE%A1.png" alt="计算机组成与设计"></p>
</li>
<li>
<p><a href="https://book.douban.com/subject/7006537/">计算机体系结构</a></p>
<p><img src="/2021/08/21/%E5%BF%85%E8%AF%BB%E4%B9%A6%E5%8D%95/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%86%85%E5%8A%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.png" alt="计算机体系结构"></p>
</li>
<li>
<p><a href="https://book.douban.com/subject/5333562/">深入理解计算机系统</a></p>
<p><img src="/2021/08/21/%E5%BF%85%E8%AF%BB%E4%B9%A6%E5%8D%95/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%86%85%E5%8A%9F/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.png" alt="深入理解计算机系统"></p>
</li>
</ol>
<h1>编译原理</h1>
<ol>
<li>
<p><a href="https://book.douban.com/subject/1148282/">计算机程序的构造和解释</a></p>
<p><img src="/2021/08/21/%E5%BF%85%E8%AF%BB%E4%B9%A6%E5%8D%95/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%86%85%E5%8A%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9E%84%E9%80%A0%E5%92%8C%E8%A7%A3%E9%87%8A.png" alt="计算机程序的构造和解释"></p>
</li>
</ol>
<h1>Others</h1>
<ol>
<li>
<p><a href="https://book.douban.com/subject/1024570/">编码的奥秘</a></p>
<p><img src="/2021/08/21/%E5%BF%85%E8%AF%BB%E4%B9%A6%E5%8D%95/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%86%85%E5%8A%9F/%E7%BC%96%E7%A0%81%E7%9A%84%E5%A5%A5%E7%A7%98.png" alt="编码的奥秘"></p>
</li>
</ol>
]]></content>
      <categories>
        <category>必读书单</category>
      </categories>
      <tags>
        <tag>必读书单</tag>
        <tag>计算机内功</tag>
      </tags>
  </entry>
  <entry>
    <title>CAM的实现</title>
    <url>/2021/08/19/cv/CAM/</url>
    <content><![CDATA[<p><img src="/2021/08/19/cv/CAM/%E4%B8%8D%E5%90%8CCAM%E7%89%88%E6%9C%AC.png" alt="不同CAM版本"></p>
<p><a href="https://github.com/jacobgil/pytorch-grad-cam">https://github.com/jacobgil/pytorch-grad-cam</a></p>
]]></content>
      <categories>
        <category>cv</category>
      </categories>
      <tags>
        <tag>CAM</tag>
        <tag>深度学习</tag>
        <tag>cv</tag>
      </tags>
  </entry>
  <entry>
    <title>王争数据结构与算法学习笔记-复杂度分析</title>
    <url>/2021/08/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%8E%8B%E4%BA%89%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<blockquote>
<p>我们使用时间复杂度和空间复杂度来衡量算法代码的执行效率，那么为什么要这么麻烦需要自己去衡量一遍呢？把代码跑一遍，通过统计、监控，就能得到算法执行的时间和占用的内存大小。为什么还要做时间、空间复杂度分析呢？这种分析方法能比我实实在在跑一遍得到的数据更准确吗？</p>
<span id="more"></span>
</blockquote>
<p>这种评估算法执行效率的方法是正确的。很多数据结构和算法书籍还给这种方法起了一个名字，叫<font color="red">事后统计法</font>。但是，这种统计方法有非常大的局限性。</p>
<h2 id="大o-表示法">大O 表示法</h2>
<p>公式：</p>
<p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T(n)=O(f(n))
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></span></p>
<p>代码分析示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> cal(<span class="built_in">int</span> n) &#123;</span><br><span class="line">  <span class="built_in">int</span> <span class="built_in">sum</span> = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">int</span> i = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">int</span> j = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (; i &lt;= n; ++i) &#123;</span><br><span class="line">    j = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; j &lt;= n; ++j) &#123;</span><br><span class="line">      <span class="built_in">sum</span> = <span class="built_in">sum</span> +  i * j;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假设每一个语句的执行时间为一个单位时间<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">t_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>​​​​那么，这段代码总的执行时间为：</p>
<p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><mn>3</mn><mo>+</mo><mn>2</mn><mi>n</mi><mo>+</mo><mn>2</mn><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T(n)=O(3+2n+2n^2)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.1141079999999999em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></p>
<p>这里的3指的是2~4行，这里的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mi>n</mi></mrow><annotation encoding="application/x-tex">2n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord mathdefault">n</span></span></span></span>指的是5、6行，这里的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><msup><mi>n</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">2n^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>指的是7、8行。即便我们不知道这里的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">t_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>是多少，但是我们可以确定的是所有代码的执行时间 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span> 与每行代码的执行次数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>​​ 成正比。<br>
大 O 时间复杂度实际上并不具体表示代码真正的执行时间，而是表示代码执行时间随数据规模增长的<font color="red">变化趋势</font>，所以，也叫作<font color="red">渐进时间复杂度</font>，简称<font color="red">时间复杂度。</font></p>
<p>当 n 很大时，可以把它想象成 10000、100000。而公式中的低阶、常量、系数三部分并不左右增长趋势，所以都可以忽略。我们只需要记录一个最大量级就可以了，如果用大 O 表示法表示上例的时间复杂度，就可以记为：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mn>2</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T(n) = O(n2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord">2</span><span class="mclose">)</span></span></span></span>​。几种常见的时间复杂度：</p>
<ul>
<li>常量阶：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></li>
<li>对数阶：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(lgn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></li>
<li>线性阶：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></li>
<li>线性对数阶：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>l</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nlgn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>次方阶：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>x</mi><mi>k</mi></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(x^k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.099108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></li>
<li>指数阶：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mn>2</mn><mi>n</mi></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(2^n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></li>
<li>阶乘阶：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mo stretchy="false">!</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(!n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mclose">!</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></li>
</ul>
<p>这几类可以分为<font color="red">多项式量级</font>和<font color="red">非多项式量级</font>，其中非多项式量级只有最后两种。时间复杂度为非多项式量级的算法问题叫作 <font color="red">NP（Non-Deterministic Polynomial，非确定多项式）问题</font>。</p>
<h2 id="空间复杂度">空间复杂度</h2>
<p>时间复杂度的全称是 <font color="red">渐进时间复杂度</font>，表示算法的执行时间与数据规模之间的 <font color="red">增长关系</font>。类比一下， <font color="red">空间复杂度</font>全称就是 <font color="red">渐进空间复杂度（asymptotic space complexity）</font>，表示算法的存储空间与数据规模之间的 <font color="red">增长关系</font>。例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">void <span class="built_in">print</span>(<span class="built_in">int</span> n) &#123;</span><br><span class="line">  <span class="built_in">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">int</span>[] a = new <span class="built_in">int</span>[n];</span><br><span class="line">  <span class="keyword">for</span> (i; i &lt;n; ++i) &#123;</span><br><span class="line">    a[i] = i * i;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = n-<span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">    <span class="built_in">print</span> out a[i]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第 2 行代码中，申请了一个空间存储变量 i，但是它是常量阶的，跟数据规模<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>​ 没有关系，所以可以忽略。第 3 行申请了一个大小为  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>​ 的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mi>n</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">int</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span></span></span></span>​ 类型数组，除此之外，剩下的代码都没有占用更多的空间，所以整段代码的空间复杂度就是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>​。常见的空间复杂度就是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>​、<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>​、<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mn>2</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord">2</span><span class="mclose">)</span></span></span></span>​，像 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(lgn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>​、<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>l</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nlgn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>​​ 这样的对数阶复杂度平时都用不到。</p>
<h2 id="最好-最坏-平均-均摊时间复杂度">最好、最坏、平均、均摊时间复杂度</h2>
<p>看看这段代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">// n表示数组array的长度</span><br><span class="line"><span class="built_in">int</span> find(<span class="built_in">int</span>[] array, <span class="built_in">int</span> n, <span class="built_in">int</span> x) &#123;</span><br><span class="line">  <span class="built_in">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">int</span> pos = -<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (array[i] == x) &#123;</span><br><span class="line">       pos = i;</span><br><span class="line">       <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> pos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码可能需要查找的元素在数组内，可能不在，最好的时间复杂度就是第一次搜索就找到结果；最坏的时间复杂度是将数组遍历之后还没找到，或者说就是数组的最后一个元素。下面着重分析平均时间复杂度和均摊时间复杂度。</p>
<ul>
<li>
<p>平均时间复杂度：<br>
要查找的变量 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>​ 在数组中的位置，有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>​ 种情况：在数组的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mtext>～</mtext><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">0～n-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord">0</span><span class="mord cjk_fallback">～</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>​ 位置中和不在数组中。我们把每种情况下，查找需要遍历的元素个数累加起来，然后再除以 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>​​​，就可以得到需要遍历的元素个数的平均值，即：</p>
<p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mn>1</mn><mo>+</mo><mn>2</mn><mo>+</mo><mn>3</mn><mo>+</mo><mo separator="true">⋅</mo><mo separator="true">⋅</mo><mo separator="true">⋅</mo><mo>+</mo><mi>n</mi><mo>+</mo><mi>n</mi></mrow><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></mfrac><mo>=</mo><mfrac><mrow><mi>n</mi><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mn>3</mn><mo stretchy="false">)</mo></mrow><mrow><mn>2</mn><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{1+2+3+···+n+n}{n+1}=\frac{n(n+3)}{2(n+1)}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.09077em;vertical-align:-0.7693300000000001em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">3</span><span class="mord">+</span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">+</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.7693300000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.363em;vertical-align:-0.936em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.427em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">3</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
</li>
</ul>
<p>时间复杂度的大 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi></mrow><annotation encoding="application/x-tex">O</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span></span></span></span>​ 标记法中，可以省略掉系数、低阶、常量，所以，把刚刚这个公式简化之后，得到的平均时间复杂度就是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>​。</p>
<p>这样分析有问题，因为这<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>​种情况出现的概率不一定是一样的，所以，要查找的变量 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>​，要么在数组里，要么就不在数组里。假设在数组中与不在数组中的概率都为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mn>1</mn><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac{1}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>​。另外，要查找的数据出现在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mtext>～</mtext><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">0～n-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord">0</span><span class="mord cjk_fallback">～</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>​ 这 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>​ 个位置的概率为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mn>1</mn><mi>n</mi></mfrac></mrow><annotation encoding="application/x-tex">\frac{1}{n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>​。所以要查找的数据出现在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mtext>～</mtext><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">0～n-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord">0</span><span class="mord cjk_fallback">～</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>​ 中任意位置的概率就是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mn>1</mn><mrow><mn>2</mn><mi>n</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{1}{2n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mathdefault mtight">n</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>​​​​​。这样时间复杂度就为：</p>
<p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>∗</mo><mfrac><mn>1</mn><mrow><mn>2</mn><mi>n</mi></mrow></mfrac><mo>+</mo><mn>2</mn><mo>∗</mo><mfrac><mn>1</mn><mrow><mn>2</mn><mi>n</mi></mrow></mfrac><mo>+</mo><mn>3</mn><mo>∗</mo><mfrac><mn>1</mn><mrow><mn>2</mn><mi>n</mi></mrow></mfrac><mo>+</mo><mo separator="true">⋅</mo><mo separator="true">⋅</mo><mo separator="true">⋅</mo><mo>+</mo><mi>n</mi><mo>∗</mo><mfrac><mn>1</mn><mrow><mn>2</mn><mi>n</mi></mrow></mfrac><mo>+</mo><mi>n</mi><mo>∗</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><mo>=</mo><mfrac><mrow><mn>3</mn><mi>n</mi><mo>+</mo><mn>1</mn></mrow><mn>4</mn></mfrac></mrow><annotation encoding="application/x-tex">1*\frac{1}{2n}+2*\frac{1}{2n}+3*\frac{1}{2n}+···+n*\frac{1}{2n}+n*\frac{1}{2}=\frac{3n+1}{4}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.00744em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span><span class="mord mathdefault">n</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.00744em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span><span class="mord mathdefault">n</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.00744em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span><span class="mord mathdefault">n</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord">+</span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">+</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.00744em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span><span class="mord mathdefault">n</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.00744em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.00744em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">4</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">3</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<p>这个值就是<font color="red">加权平均值</font>，也叫作<font color="red">期望值</font>，所以<font color="red">平均时间复杂度</font>的全称应该叫<font color="red">加权平均时间复杂度</font>或者<font color="red">期望时间复杂度</font>。使用大<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi></mrow><annotation encoding="application/x-tex">O</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span></span></span></span>​表示法，这段代码的加权平均时间复杂度仍然是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>​​。</p>
<h2 id="均摊时间复杂度-amortized-time-complexity">均摊时间复杂度（amortized time complexity）</h2>
<p>例如如下代码段：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// array表示一个长度为n的数组</span></span><br><span class="line"><span class="comment">// 代码中的array.length就等于n</span></span><br><span class="line"><span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (count == array.length) &#123;</span><br><span class="line">      <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; ++i) &#123;</span><br><span class="line">         sum = sum + array[i];</span><br><span class="line">      &#125;</span><br><span class="line">      array[<span class="number">0</span>] = sum;</span><br><span class="line">      count = <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   array[count] = val;</span><br><span class="line">   ++count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码实现了一个往数组中插入数据的功能。当数组满了之后，也就是代码中的 count == array.length 时，我们用 for 循环遍历数组求和，并清空数组，将求和之后的 sum 值放到数组的第一个位置，然后再将新的数据插入。但如果数组一开始就有空闲空间，则直接将数据插入数组。</p>
<p>在看均摊时间复杂度之前，可以使用平均时间复杂度来尝试着分析一下，这段代码所描述的插入数据的情况有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>​中情况，其中有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>​种情况是有空闲的位置可以插入的，第<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>​种情况是数组已经满了，这<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>​种情况出现的概率都是一样的，为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mn>1</mn><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{1}{n+1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2484389999999999em;vertical-align:-0.403331em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.403331em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>​​​。这样使用平均时间复杂度来分析的话就是：</p>
<p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>∗</mo><mfrac><mn>1</mn><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></mfrac><mo>+</mo><mn>1</mn><mo>∗</mo><mfrac><mn>1</mn><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></mfrac><mo>+</mo><mo separator="true">⋅</mo><mo separator="true">⋅</mo><mo separator="true">⋅</mo><mo>+</mo><mi>n</mi><mo>∗</mo><mfrac><mn>1</mn><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></mfrac><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">1*\frac{1}{n+1}+1*\frac{1}{n+1}+···+n*\frac{1}{n+1}=O(1)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.09077em;vertical-align:-0.7693300000000001em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.7693300000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.09077em;vertical-align:-0.7693300000000001em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.7693300000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord">+</span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">+</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.09077em;vertical-align:-0.7693300000000001em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.7693300000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span></p>
<p>其实分析一下代码的逻辑特点，是有规律的，即：一个 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>​ 插入之后，紧跟着 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>​ 个 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>​ 的插入操作，循环往复。这种类似的情况概括起来就是：周期性出现一个特殊的复杂度的情况，往往遇到这样的情况就可以考虑使用<font color="red">摊还分析法</font>:<font color="gree">每一次 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>​ 的插入操作，都会跟着 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>​ 次 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>​ 的插入操作，所以把耗时多的那次操作均摊到接下来的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>​ 次耗时少的操作上，均摊下来，这一组连续的操作的均摊时间复杂度就是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>​​</font>。这就是均摊分析的大致思路。下面用一段话来概括使用均摊分析的情况：</p>
<blockquote>
<p>对一个数据结构进行一组连续操作中，大部分情况下时间复杂度都很低，只有个别情况下时间复杂度比较高，而且这些操作之间存在前后连贯的时序关系，这个时候，我们就可以将这一组操作放在一块儿分析，看是否能将较高时间复杂度那次操作的耗时，平摊到其他那些时间复杂度比较低的操作上。而且，在能够应用均摊时间复杂度分析的场合，一般均摊时间复杂度就等于最好情况时间复杂度。</p>
</blockquote>
<h2 id="习题">习题</h2>
<p>分析如下代码的时间复杂度：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 全局变量，大小为10的数组array，长度len，下标i。</span></span><br><span class="line"><span class="keyword">int</span> array[] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>]; </span><br><span class="line"><span class="keyword">int</span> len = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 往数组中添加一个元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> element)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (i &gt;= len) &#123; <span class="comment">// 数组空间不够了</span></span><br><span class="line">     <span class="comment">// 重新申请一个2倍大小的数组空间</span></span><br><span class="line">     <span class="keyword">int</span> new_array[] = <span class="keyword">new</span> <span class="keyword">int</span>[len*<span class="number">2</span>];</span><br><span class="line">     <span class="comment">// 把原来array数组中的数据依次copy到new_array</span></span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; ++j) &#123;</span><br><span class="line">       new_array[j] = array[j];</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// new_array复制给array，array现在大小就是2倍len了</span></span><br><span class="line">     array = new_array;</span><br><span class="line">     len = <span class="number">2</span> * len;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 将element放到下标为i的位置，下标i加一</span></span><br><span class="line">   array[i] = element;</span><br><span class="line">   ++i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码的功能容易看出来，这里就不细说了，下面分析最好、平均、加权平均、最坏和均摊时间复杂度：</p>
<ul>
<li>
<p>最好时间复杂度：<br>
插入数据的时候有空间，那么使用大<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi></mrow><annotation encoding="application/x-tex">O</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span></span></span></span>​表示法就为：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>​</p>
</li>
<li>
<p>最坏时间复杂度：<br>
插入数据的时候没有空间，需要重新申请一个长度为原来长度两倍的数组，假设需要执行的常量时间的语句条数为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span>，那么使用大<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi></mrow><annotation encoding="application/x-tex">O</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span></span></span></span>​​表示法为：</p>
<p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>+</mo><mi>b</mi><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">n+b=O(n)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></span></p>
</li>
<li>
<p>平均时间复杂度：<br>
每一种情况认为概率相同，那么使用大<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi></mrow><annotation encoding="application/x-tex">O</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span></span></span></span>​表示法为：</p>
<p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>∗</mo><mfrac><mn>1</mn><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></mfrac><mo>+</mo><mn>1</mn><mo>∗</mo><mfrac><mn>1</mn><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></mfrac><mo>+</mo><mo separator="true">⋅</mo><mo separator="true">⋅</mo><mo separator="true">⋅</mo><mo>+</mo><mi>n</mi><mo>∗</mo><mfrac><mn>1</mn><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></mfrac><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">1*\frac{1}{n+1}+1*\frac{1}{n+1}+···+n*\frac{1}{n+1}=O(1)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.09077em;vertical-align:-0.7693300000000001em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.7693300000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.09077em;vertical-align:-0.7693300000000001em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.7693300000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord">+</span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">+</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.09077em;vertical-align:-0.7693300000000001em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.7693300000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span></p>
</li>
<li>
<p>加权平均复杂度：<br>
每一次插入的时候要么有空间，要么没有剩余的空间，设两种可能性均为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mn>1</mn><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac{1}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>，而且在有剩余空间的情况下，插入哪一个位置的概率也一样，使用大<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi></mrow><annotation encoding="application/x-tex">O</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span></span></span></span>​表示法即：</p>
<p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mn>1</mn><mn>2</mn></mfrac><mo>∗</mo><mfrac><mn>1</mn><mi>n</mi></mfrac><mo>+</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><mo>∗</mo><mfrac><mn>1</mn><mi>n</mi></mfrac><mo>+</mo><mo separator="true">⋅</mo><mo separator="true">⋅</mo><mo separator="true">⋅</mo><mo>+</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><mo>∗</mo><mi>n</mi><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\frac{1}{2}*\frac{1}{n}+\frac{1}{2}*\frac{1}{n}+···+\frac{1}{2}*n=O(1)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.00744em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.00744em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">n</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.00744em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.00744em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">n</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord">+</span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">+</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span></p>
</li>
</ul>
<p>将最后一种情况均摊到其他的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>​种情况中，那么每一种情况的复杂度均为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>​。</p>
<ul>
<li>
<p>均摊时间复杂度：<br>
每一次插入的时候要么有空间，要么没有剩余的空间，设两种可能性均为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mn>1</mn><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac{1}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>​​，而且在有剩余空间的情况下，插入哪一个位置的概率也一样，即：</p>
<p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mn>1</mn><mn>2</mn></mfrac><mo>∗</mo><mfrac><mn>1</mn><mi>n</mi></mfrac><mo>+</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><mo>∗</mo><mfrac><mn>1</mn><mi>n</mi></mfrac><mo>+</mo><mo separator="true">⋅</mo><mo separator="true">⋅</mo><mo separator="true">⋅</mo><mo>+</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><mo>∗</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">\frac{1}{2}*\frac{1}{n}+\frac{1}{2}*\frac{1}{n}+···+\frac{1}{2}*n
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.00744em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.00744em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">n</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.00744em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.00744em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">n</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord">+</span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">+</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span></span></p>
<p>将最后一种情况均摊到其他的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>​​种情况中，那么每一种情况的复杂度均为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>​​​​。</p>
</li>
</ul>
<p>在王争的课程中的复杂度分析的后面留了一道思考题，题目如下：</p>
<blockquote>
<p>有人说，我们项目之前都会进行性能测试，再做代码的时间复杂度、空间复杂度分析，是不是多此一举呢？而且，每段代码都分析一下时间复杂度、空间复杂度，是不是很浪费时间呢？</p>
</blockquote>
<p>有一个回复非常的深刻：</p>
<blockquote>
<p>由于做一个性能测试测试结果会受到数据规模测试机器等外界因素的影响，所以性能测试不是很具有代表性，但是时间复杂度和空间复杂度分析是比较客观的，不会受到外界因素的影响，只有先做了复杂度分析我们才能确实最优方案，最后得到最优解才开始做性能测试。 渐进式时间，空间复杂度分析与性能基准测试并不冲突，而是相辅相成的，但是一个低阶的时间复杂度程序有极大的可能性会优于一个高阶的时间复杂度程序，所以在实际编程中，时刻关心理论时间，空间度模型是有助于产出效率高的程序的，同时，因为渐进式时间，空间复杂度分析只是提供一个粗略的分析模型，因此也不会浪费太多时间，重点在于在编程时，要具有这种复杂度分析的思维。</p>
</blockquote>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>王争数据结构与算法学习笔记-栈</title>
    <url>/2021/08/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%8E%8B%E4%BA%89%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%A0%88/</url>
    <content><![CDATA[<p>浏览器的前进后退功能的实现使用到了栈这种数据结构。</p>
<p>当依次访问了页面a，b，c，然后后退的时候又可以重新返回到页面b、a，访问的过程属于入栈的功能，后退的过程是出栈的功能。</p>
<span id="more"></span>
<h3 id="理解-栈">理解“栈”</h3>
<p><code>栈是一种操作受限的线性表，只允许在一端进行插入和删除操作。</code></p>
<h3 id="为什么需要-栈-？">为什么需要“栈”？</h3>
<p>为何需要单独设计一个数据结构，而不是直接使用链表或者数组来代替呢？</p>
<p>数据结构是对于不同应用场景的抽象，数组和链表用于实现栈的功能，暴露了过多的端口，使用起来不可控，容易出错。</p>
<h3 id="栈的复杂度？">栈的复杂度？</h3>
<p>不论是链式栈还是顺序栈，其时间复杂度均为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>（针对 入栈 和 出栈 操作），空间复杂度也为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>。</p>
<p>空间复杂度不是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>吗？</p>
<p>我们所说的空间复杂度指的是<code>除去本来需要的、用于存储数据的存储空间之外，算法运行起来所需要的额外空间。</code>栈所需要的额外空间为个位数，所以大<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi></mrow><annotation encoding="application/x-tex">O</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span></span></span></span>表示法表示空间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>。</p>
<h3 id="支持动态扩容的顺序栈">支持动态扩容的顺序栈</h3>
<p>对于数组实现的栈，如果数据量超过数组一开始申请的空间就会受限，对于链表实现的栈，每一个结点多出一个“next”指针，内存消耗过多，所以为了解决这个问题，我们需要设计一个支持动态扩容的栈。</p>
<p>对于动态扩容的数组而言，当剩余的容量不够的时候，再申请一块更大的空间，将原来的数据拷贝到新数组中，就实现了动态扩充。所以要实现动态扩容的顺序栈就需要在一个动态扩容的数组上操作。</p>
<p>那么支持动态扩容的顺序栈的时间复杂度和空间复杂度如何分析呢？</p>
<p>对于出栈操作来说，不会涉及到数据的转移操作，所以时间复杂度仍然为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>，对于插入操作就不一样了，如果剩余的空间可以容下需要插入的数据，则时间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>，如果空间不够，则需要申请一块新的内存，并将之前的数据全部转移到新的数组中，这就涉及到移动数据所花费的时间了，这样一来时间复杂度就是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>。</p>
<p>所以对于入栈操作来讲，最好的情况下时间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>，最坏的时间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>，接下来给定下面几点假设来分析平均时间复杂度：</p>
<ol>
<li>栈空间不够时，申请原来数组长度的两倍；</li>
<li>假设只有入栈操作没有出栈操作；</li>
<li>不涉及内存搬移的入栈操作为simple-push操作，时间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>。</li>
</ol>
<p>这里的平均时间复杂度的分析使用均摊时间复杂度。对于均摊时间复杂度，在之前的<a href="https://blog.abovewater.top/2021/08/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%8E%8B%E4%BA%89%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/#more">时间空间复杂度分析</a>中有讲到。对于需要重新申请数组空间，并将数据转移到新数组中的操作场景而言，假设数组的长度为n，那么前n个数据入栈的时间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>​，而第n+1个数据入栈的时候栈满，需要转移数据到新的数组中，时间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>。此时容量为2n的新栈剩余的容量为n-1，所以剩余n-1个数据入栈的时间复杂度均为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>。最后，将第n+1个数据上的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>时间复杂度给均摊到其他的结点，所以均摊时间复杂度就变成了<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>。</p>
<p><code>均摊时间复杂度一般都等于最好情况下的时间复杂度。</code></p>
<h3 id="栈在函数调用中的应用">栈在函数调用中的应用</h3>
<p>操作系统给每个线程分配了一块独立的内存空间，这块内存被组织成“栈”, 用来存储函数调用时的临时变量。每进入一个函数，就会将临时变量作为一个栈帧入栈，当被调用函数执行完成，返回之后，将这个函数对应的栈帧出栈。</p>
<h3 id="栈在表达式求值中的应用">栈在表达式求值中的应用</h3>
<h3 id="栈在括号匹配中的应用">栈在括号匹配中的应用</h3>
<h3 id="思考">思考</h3>
<ol>
<li>
<p>为什么函数要调用栈来保存临时变量呢？使用其他的数据结构不行吗？</p>
<blockquote>
<p>我们不一定非要用栈来保存临时变量，只不过如果这个函数调用符合后进先出的特性，用栈这种数据结构来实现，是最顺理成章的选择。从调用函数进入被调用函数，对于数据来说，变化的是什么呢？是作用域。所以根本上，只要能保证每进入一个新的函数，都是一个新的作用域就可以。而要实现这个，用栈就非常方便。在进入被调用函数的时候，分配一段栈空间给这个函数的变量，在函数结束的时候，将栈顶复位，正好回到调用函数的作用域内。</p>
</blockquote>
</li>
<li>
<p>JVM内存管理有个“堆栈”的概念。栈内存用来存储局部变量和方法调用，堆内存用来存储java中的对象。那JVM中的栈与我们说的数据结构栈是不是一回事呢？如果不是，那它为什么叫作栈呢？</p>
<blockquote>
<p>内存中的堆栈和数据结构中的栈不是一个概念，内存中的堆栈是真实存在的物理区，数据结构中的堆栈是抽象的数据存储结构。</p>
<p>内存空间在逻辑上分为三个部分：代码区、静态数据区和动态数据区，动态数据区又分为栈区和堆区。</p>
<p>代码区：存储方法体的二进制代码。高级调度（作业调度）、中级调度（内存调度）、低级调度（进程调度）控制代码区执行代码的切换。</p>
<p>静态数据区：存储全局变量、静态变量、常量，常量包括final修饰的常量和String常量。系统自动分配和回收。</p>
<p>栈区：存储运行方法的形参、局部变量、返回值。由系统自动分配和回收。</p>
<p>堆区：new一个对象的引用或地址存储在栈区，指向该对象存储在堆区中的真实数据。</p>
<p>由于在JVM中的栈实现了先进后出的逻辑功能，所以叫做“栈”也可以理解。</p>
</blockquote>
</li>
<li>
<p>内存中的堆栈？</p>
<blockquote>
<p>堆是一个内存空间，这个内存控件可以由程序员分配和释放，当然部分语言自带 GC（ Garbage Collection 垃圾回收），部分堆内存可以由 GC 回收。这里千万要注意，这里说的堆和 数据结构里面说的堆不是同一个概念。堆是程序在运行的时候请求操作系统分配给自己内存。由于从操作系统管理的内存分配，所以在分配和销毁时都要占用时间，因此用堆的效率相对栈来说略低。但是堆的优点在于，编译器不必知道要从堆里分配多少内存空间，也不必知道存储的数据要在堆里停留多长的时间，因此用堆保存数据时会得到更大的灵活性。因此，为达到这种灵活性，在堆里分配存储空间时会花掉相对更长的时间，这也是效率低于栈的原因。</p>
<p>栈是由编译器自动分配和释放的，存放函数的参数值，局部变量的值等。也请注意，这里说的栈 不是数据结构中的栈。栈的优势是，存取速度比堆要快，仅次于寄存器，栈数据可以共享。但缺点是，存在栈中的数据大小与生存期必须是确定的，缺乏灵活性。</p>
<p>在C#中，数据类型有两大类型 —— <code>值类型</code> 和 <code>引用类型</code>，内置值类型指的是 int、float、bool、double 等等，引用类型大概我们学 C 语言的时候学到的指针类型。值类型变量声明后，不管是否已经赋值，编译器为其分配内存。然而引用类型当声明一个变量时，只在栈中分配一小片内存用于容纳一个地址，而此时并没有为其分配堆上的内存空间。当使用 new 创建一个类的实例时，这时候会分配堆上的空间，并把堆上空间的地址保存到栈上分配的小片空间中。说通俗一点，堆上存放的是我们声明出来的实例对象，当我们需要访问这个实例对象的时候，我们找到它的方法是先找到变量对应在栈上的内存，然后通过栈上存放的数据，我们才能找到其真正的实例在堆的什么位置。</p>
<p>即使在堆上面，现代化的高级语言也会有一些桎梏让你并不能随意的，随时随地的释放你认为可以释放的内存，很多语法概念中都蕴含了“栈”的概念。</p>
<p>例如，一个C++的对象X，他有数据成员a和b, 现在我知道我不再使用X.a了，但是我还会使用X.b，有没有办法去“浅释放”X.a所占的sizeof(X.a)的内存呢？抱歉不行，你只能先释放X，在释放X的过程中去释放X.a和X.b（不能只释放一个）。而且这和X在堆还是在栈上分配没有任何关系。</p>
<p>换而言之，面向对象语言中的“对象”，从他的成员的构建过程中蕴含了“栈的概念”，所以他的释放依然受制于栈的先入后出的规则影响。类似于默认生成的析构函数总是先调用对象的析构函数再去遍历调用成员的析构函数一样，只是可以把这个栈看成分叉栈，或者树的先序遍历。</p>
<p>Reference:</p>
<p><a href="https://zhuanlan.zhihu.com/p/45597548">https://zhuanlan.zhihu.com/p/45597548</a></p>
<p><a href="https://www.zhihu.com/question/281940376/answer/424990646">https://www.zhihu.com/question/281940376/answer/424990646</a></p>
</blockquote>
</li>
<li>
<p>什么是装箱什么是拆箱？</p>
<blockquote>
<p>装箱实际上是将值类型转换为引用类型，而拆箱是将引用类型转换为值类型。再说的透彻点，实际上装箱拆箱就是栈内存和堆内存的来回拷贝和赋值，这不仅仅浪费性能，而且还会造成没必要的 GC。因此，能避免 “装箱”、“拆箱” 操作的就尽量避免。</p>
<p>Reference: <a href="https://zhuanlan.zhihu.com/p/45597548">https://zhuanlan.zhihu.com/p/45597548</a></p>
</blockquote>
</li>
</ol>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>王争数据结构与算法学习笔记-链表</title>
    <url>/2021/08/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%8E%8B%E4%BA%89%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="链表实现lru">链表实现LRU</h2>
<span id="more"></span>
<p>在操作系统中常见的缓存淘汰策略有：先进先出策略 FIFO（First In，First Out）、最少使用策略 LFU（Least Frequently Used）、最近最少使用策略 LRU（Least Recently Used）。</p>
<p>使用链表实现LRU如下：<br>
创建一个链表来维护CPU缓存，链表中的每一个结点距离头结点的距离用于衡量该结点中存放的数据被访问的时间点距离当前时间点的时长，所以链表的表尾表示最早访问的数据。这样一来需要分几种情况来讨论：</p>
<ul>
<li>遍历链表，如果找到了当前需要访问的数据，就将该结点移到链表的表头。</li>
<li>遍历链表，如果没有找到当前需要访问的数据，就需要将该数据插入链表的表头，但是可能CPU缓存在此时已经满了，所以需要分情况考虑：
<ul>
<li>如果CPU缓存没有满，将该数据插入链表即可。</li>
<li>如果CPU缓存满了，将链表的表尾结点删除（最早访问到的数据），然后将新数据插入链表的表头。</li>
</ul>
</li>
</ul>
<p>这样就实现了LRU缓存。因为不管缓存有没有满，都需要遍历一遍链表，所以这种基于链表的实现思路，缓存访问的时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>​。</p>
<h2 id="数组实现lru">数组实现LRU</h2>
<ol>
<li>
<p>将数组的首元素作为最新访问的数据，数组末尾元素作为最早访问的数据。这样每一次需要遍历数组寻找数据，时间复杂度为O(n)，如果找到了，需要将该数据移到数组首部，最坏的情况是O(n)，最好的情况是O(1);如果不在数组中，当CPU缓存满的时候需要删除数组末尾的数据，这里删除可以采用直接覆盖的方式，移动前面n-1个数据，然后在数组首部插入新数据，时间复杂度为O(n);如果在数组中，移动数据，插入新数据，时间复杂度为O(n)。根据加法原则，时间复杂度为O(2n+1)=O(n)；</p>
</li>
<li>
<p>将数组的尾部元素作为最新访问的数据，数组首部为最早访问的数据。这样每一次需要遍历数组寻找数据，时间复杂度为O(n)，如果找到了，需要将该数据移到数组尾部，最坏的情况是O(n)，最好的情况是O(1);如果不在数组中，当CPU缓存满的时候需要删除数组首部的数据，这里删除可以采用直接覆盖的方式，移动后面n-1个数据，然后在数组尾部插入新数据，时间复杂度为O(n);如果在数组中，移动数据，插入新数据，时间复杂度为O(n)。根据加法原则，时间复杂度还是O(2n+1)=O(n)；</p>
</li>
<li>
<p>前两种方法其实思路差不多，只是头部和尾部谁用来存放最早访问的数据。这两种方法都有比较大的缺点，即存在大量移动数组元素的情况，这样的效率很低，为了减少移动的次数，可以使用两个指针new，old来分别指向最新访问的数据、最早访问的数据，一开始数组内元素不断扩充，也就是CPU缓存使用率不断上升的过程，此过程中old指针不断往下标大的方向移动，当CPU缓存满的时候，再次访问数据且恰好不在缓存中时，需要删除元素，删除可以采用直接覆盖的方式，old指针向左移动，指向下标为n-2的位置，然后插入新元素，由于此时只有下标为n-1的位置是空的，所以new指针指向n-1的位置，当再有新元素需要存入缓存时，使用同样的方式来避免大量移动数组中的数据。使用这种方法同样需要先遍历数组，确定是否需要插入数据，时间复杂度为O(n)，而插入删除的时间复杂度为O(1)，总的来说时间复杂度为O(n+1)=O(n)。</p>
</li>
</ol>
<h2 id="使用单链表实现回文数的判断">使用单链表实现回文数的判断</h2>
<p>回文数需要首先确定中间的元素，然后判断两边的元素是否都对应相等，在确定链表长度的时候，可以使用快慢指针来实现，慢指针每一次移动一个结点，快指针每一次移动两个结点，当快指针到达链表尾的时候，慢指针就到达中间了，此时仅仅花了遍历全部链表元素的一半的时间。在慢指针前进的过程中，同时修改其 next 指针，使得链表前半部分反序。最后比较中点两侧的链表是否相等，从而判断是否为回文数。</p>
<p>这里需要避免一个误区，不是快指针跨度越大越好，比如这里快指针跨度为慢指针的100倍，就容易出现一个问题，快指针从某一步开始就跳出链表了，但是也不清楚到底具体链表尾多远，所以需要一个额外的指针来存储快指针上一次存放的地址，当某一次快指针跳出链表的时候，通过这个额外的指针可以回到链表中。回来了还不然，还没有确定链表中间结点，所以，需要重新移动快指针来确定此时与尾结点的距离，然后还要移动相应倍数的慢指针，最终才能确定中间结点，这一过程是比较繁琐的，而且容易出错，所以快慢指针方法的“快指针”不能太“快”。</p>
<h2 id="双链表和单链表的删除操作">双链表和单链表的删除操作</h2>
<p><code>删除给定指针指向的结点</code>: 这种情况是已经找到了要删除的元素,我们只需要执行删除操作即可.</p>
<p><code>针对单链表而言</code>: 单链表如果要删除一个结点q.必须要知道这个结点的前驱结点是谁,修改前驱结点的指针指向即可.单链表找某个结点的前驱结点,只能从头开始遍历. 临界值 p-&gt;next == q;说明p就是q的前驱结点.所以在单链表中,找这个前驱结点的平均时间复杂度为O(n),然后执行删除操作的时间复杂度为O(1). 根据时间复杂度分析的加法法则: 删除给定指针指向的结点 --&gt; 单链表的总的时间复杂度为O(n).</p>
<p><code>针对双链表而言</code>: 双链表要删除一个结点q.也必须得知道这个结点的前驱结点和后继结点. 修改前驱结点的后继指针next和后继结点的前驱指针prev即可.而针对双链表而言,找q的前驱结点和q的后继结点的时间复杂度都为O(1).而执行删除操作(修改指针指向)的时间复杂度也为O(1). 根据时间复杂度分析的加法法则: 删除给定指针指向的结点 --&gt; 双链表的总的时间复杂度为O(1).</p>
<h2 id="cpu缓存技术">CPU缓存技术</h2>
<p>缓存实际上就是利用了空间换时间的设计思想。如果我们把数据存储在硬盘上，会比较节省内存，但每次查找数据都要询问一次硬盘，会比较慢。但如果我们通过缓存技术，事先将数据加载在内存中，虽然会比较耗费内存空间，但是每次数据查询的速度就大大提高了。数据库索引操作、MapReduce，是典型的空间换时间。</p>
<h2 id="数组与链表的区别">数组与链表的区别</h2>
<table>
<thead>
<tr>
<th style="text-align:center">时间复杂度</th>
<th style="text-align:center">数组</th>
<th style="text-align:center">链表</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">插入|删除</td>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></td>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></td>
</tr>
<tr>
<td style="text-align:center">随机访问</td>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></td>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></td>
</tr>
</tbody>
</table>
<ol>
<li>
<p>数组简单易用，在实现上使用的是连续的内存空间，可以借助 <code>CPU 的缓存机制</code>，预读数组中的数据，所以访问效率更高。而链表在内存中并不是连续存储，所以对 CPU 缓存不友好，没办法有效预读。</p>
</li>
<li>
<p>数组的缺点是<code>大小固定</code>，一经声明就要占用整块连续内存空间。如果声明的数组过大，系统可能没有足够的连续内存空间分配给它，导致“内存不足（out of memory）”。如果声明的数组过小，则可能出现不够用的情况。这时只能再申请一个更大的内存空间，把原数组拷贝进去，非常费时。链表本身没有大小的限制，天然地支持动态扩容。</p>
</li>
<li>
<p>如果你的代码对<code>内存的使用非常苛刻</code>，那数组就更适合你。因为链表中的每个结点都需要消耗额外的存储空间去存储一份指向下一个结点的指针，所以内存消耗会翻倍。而且，对链表进行频繁的插入、删除操作，还会导致频繁的内存申请和释放，容易造成<code>内存碎片</code>，如果是 Java 语言，就有可能会导致频繁的 GC（Garbage Collection，垃圾回收）。</p>
</li>
<li>
<p><code>对内存要求方面</code>: 数组对内存的要求更高。因为数组需要一块连续内存空间来存放数据。（可能出现的问题就是:内存总的剩余空间足够，但是申请容量较大的数组时申请失败） 链表对内存的要求较低，是因为链表不需要连续的内存空间，只要内存剩余空间足够，无论是否连续，用链表来申请空间一定会成功。</p>
</li>
<li>
<p>链表虽然方便，但是<code>内存开销比数组大了将近一倍</code>，假设存储100个整数，数组400个字节的存储空间足够了。但是如果用链表存储100个整数，链表得需要1200个字节的存储空间(C/C++)，因为链表中的每个节点不止要存储数据，还要存储地址，内存的利用率就比数组低太多了。</p>
</li>
<li>
<p>由此还可以得出:如果<code>内存容量本身就很小，要存储的数据也比较多</code>。选择<code>数组</code>来存储数据更好，如果内存空间充足，那我们在存储数据的时候到底选择链表还是数组。这个就视具体的业务场景而定了。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>王争数据结构与算法学习笔记-数组</title>
    <url>/2021/08/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%8E%8B%E4%BA%89%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<blockquote>
<p>数组看起来简单基础，但是很多人没有理解这个数据结构的精髓。<code>数组（Array）是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据</code>。数组在逻辑上是一种线性表数据结构. 数组在物理上是一种顺序的存储结构。 数组定义的关键词:</p>
<span id="more"></span>
<p>1.连续的内存空间</p>
<p>2.相同类型的数据.</p>
<p><code>线性表</code>: 数据排成像一条线一样的结构.每个线性表上的数据最多只有前和后两个方向.<br>
<code>非线性表</code>: 数据之间并不是简单的前后关系. 线性表数据结构包括: 数组,链表,队列,栈. 非线性表数据结构包括: 二叉树,堆,图 。</p>
<blockquote>
<p>1.数组的查找操作时间复杂度并不是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>。即便是排好的数组，用二分查找，时间复杂度也是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(lgn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>。正确表述：数组支持随机访问，根据下标随机访问的时间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>​</p>
<p>2.连续的内存空间和相同类型的数据：正是因为这两个限制，它才有了一个堪称“杀手锏”的特性：“随机访问”。这两个限制也让数组的很多操作变得非常低效，比如要想在数组中删除、插入一个数据，为了保证连续性，就需要做大量的数据搬移工作。</p>
</blockquote>
</blockquote>
<h2 id="数组是如何实现根据下标随机访问数组元素">数组是如何实现根据下标随机访问数组元素</h2>
<p>拿一个长度为 10 的 int 类型的数组 int[] a = new int[10]来举例。计算机给数组 a[10]，分配了一块连续内存空间 1000～1039，其中，内存块的首地址为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mi>a</mi><mi>s</mi><msub><mi>e</mi><mrow><mi>a</mi><mi>d</mi><mi>d</mi><mi>r</mi><mi>e</mi><mi>s</mi><mi>s</mi></mrow></msub></mrow><annotation encoding="application/x-tex">base_{address}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord mathdefault">b</span><span class="mord mathdefault">a</span><span class="mord mathdefault">s</span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">d</span><span class="mord mathdefault mtight">d</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>​​ = 1000。</p>
<p><font color="gree">【注】此处使用的Java语言定义int类型，Java基本类型的整型分4中：byte、short、int、long，长度分别为1、2、4、8，所以此处int数组的每个值长度为4，所以分配的内存长度是10×4=40，此处内存分配从1000-1039共40个字节长度。</font></p>
<p>计算机会给每个内存单元分配一个地址，计算机通过地址来访问内存中的数据。当计算机需要随机访问数组中的某个元素时，它会首先通过下面的寻址公式，计算出该元素存储的内存地址：</p>
<p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo stretchy="false">[</mo><mi>i</mi><msub><mo stretchy="false">]</mo><mrow><mi>a</mi><mi>d</mi><mi>d</mi><mi>r</mi><mi>e</mi><mi>s</mi><mi>s</mi></mrow></msub><mo>=</mo><mi>b</mi><mi>a</mi><mi>s</mi><msub><mi>e</mi><mrow><mi>a</mi><mi>d</mi><mi>d</mi><mi>r</mi><mi>e</mi><mi>s</mi><mi>s</mi></mrow></msub><mo>+</mo><mi>i</mi><mo>∗</mo><mi>d</mi><mi>a</mi><mi>t</mi><msub><mi>a</mi><mrow><mi>t</mi><mi>y</mi><mi>p</mi><mi>e</mi><mi>S</mi><mi>i</mi><mi>z</mi><mi>e</mi></mrow></msub></mrow><annotation encoding="application/x-tex">a[i]_{address} = base_{address} + i * data_{typeSize}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">d</span><span class="mord mathdefault mtight">d</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord mathdefault">b</span><span class="mord mathdefault">a</span><span class="mord mathdefault">s</span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">d</span><span class="mord mathdefault mtight">d</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.328331em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">t</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span><span class="mord mathdefault mtight">p</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight" style="margin-right:0.05764em;">S</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight" style="margin-right:0.04398em;">z</span><span class="mord mathdefault mtight">e</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span></span></p>
<p>对于 m * n 的数组，a[i][j] (i &lt; m,j &lt; n)的地址为：</p>
<p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo stretchy="false">[</mo><mi>i</mi><msub><mo stretchy="false">]</mo><mrow><mi>a</mi><mi>d</mi><mi>d</mi><mi>r</mi><mi>e</mi><mi>s</mi><mi>s</mi></mrow></msub><mo>=</mo><mi>b</mi><mi>a</mi><mi>s</mi><msub><mi>e</mi><mrow><mi>a</mi><mi>d</mi><mi>d</mi><mi>r</mi><mi>e</mi><mi>s</mi><mi>s</mi></mrow></msub><mo>+</mo><mo stretchy="false">(</mo><mi>i</mi><mo>∗</mo><mi>n</mi><mo>+</mo><mi>j</mi><mo stretchy="false">)</mo><mo>∗</mo><mi>d</mi><mi>a</mi><mi>t</mi><msub><mi>a</mi><mrow><mi>t</mi><mi>y</mi><mi>p</mi><mi>e</mi><mi>S</mi><mi>i</mi><mi>z</mi><mi>e</mi></mrow></msub></mrow><annotation encoding="application/x-tex">a[i]_{address} = base_{address} + (i*n+j) * data_{typeSize}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">d</span><span class="mord mathdefault mtight">d</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord mathdefault">b</span><span class="mord mathdefault">a</span><span class="mord mathdefault">s</span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">d</span><span class="mord mathdefault mtight">d</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.328331em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">t</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span><span class="mord mathdefault mtight">p</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight" style="margin-right:0.05764em;">S</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight" style="margin-right:0.04398em;">z</span><span class="mord mathdefault mtight">e</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span></span></p>
<p><font color="red">【注】数组和链表的区别？很多人都回答说，“链表适合插入、删除，时间复杂度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>；数组适合查找，查找时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>”。这种表述是不准确的。数组是适合查找操作，但是查找的时间复杂度并不为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>。即便是排好序的数组，用二分查找，时间复杂度也是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(lgn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>。所以，正确的表述应该是，数组支持随机访问，根据下标随机访问的时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>。</font></p>
<h2 id="低效的-插入-和-删除">低效的“插入”和“删除”</h2>
<ul>
<li>
<p>插入<br>
插入的位置不同,会导致针对同一段代码,我们的时间复杂度有量级的差距.</p>
<p>1.我们插入的位置位于数组的最后一位:不需要移动任何元素,最好时间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>​.</p>
<p>2.我们插入的位置位于数组的第一位,需要移动n个元素,最坏时间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>​.</p>
<p>3.平均时间复杂度.先把概率算清, 插入到任一位置的可能性都是一样的.<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>​个位置.所以插入到每一个位置的概率都是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mn>1</mn><mi>n</mi></mfrac></mrow><annotation encoding="application/x-tex">\frac{1}{n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>​. 插入到数组的第一个位置需要移动<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>​个元素. 插入到数组的第二个位置需要移动<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>​​​​​个元素，以此类推，插入到数组中的最后一个位置，需要移动1个元素.</p>
</li>
</ul>
<p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo>+</mo><mi>n</mi><mo>−</mo><mn>2</mn><mo>+</mo><mo separator="true">⋅</mo><mo separator="true">⋅</mo><mo separator="true">⋅</mo><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><mi>n</mi></mfrac><mo>=</mo><mfrac><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow><mn>2</mn></mfrac><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\frac{(n+n-1+n-2+···+1)}{n}=\frac{n+1}{2}=O(n)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.113em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.427em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">n</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">2</span><span class="mord">+</span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">+</span><span class="mord">1</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.00744em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></span></p>
<p>所以: 数组插入操作的平均时间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>​​​​.</p>
<p><font color="gree">如果数组中的数据是有序的，我们在某个位置插入一个新的元素时，就必须按照刚才的方法搬移<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>​之后的数据。但是，如果数组中存储的数据并没有任何规律，数组只是被当作一个存储数据的集合。在这种情况下，如果要将某个数据插入到第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>​ 个位置，为了避免大规模的数据搬移，我们还有一个简单的办法就是，直接将第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>​ 位的数据搬移到数组元素的最后，把新的元素直接放入第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>​​​​ 个位置。</font></p>
<ul>
<li>删除<br>
在不一定非得追求数组中数据的连续性的情况下。如果将多次删除操作集中在一起执行，删除的效率会提高很多，即：可以先记录下已经删除的数据。每次的删除操作并不是真正地搬移数据，只是记录数据已经被删除。当数组没有更多空间存储数据时，我们再触发执行一次真正的删除操作，这样就大大减少了删除操作导致的数据搬移。类似于Java的垃圾回收核心算法。</li>
</ul>
<h2 id="警惕数组的访问越界问题">警惕数组的访问越界问题</h2>
<p>看看这段C语言代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> arr[<span class="number">3</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(; i&lt;=<span class="number">3</span>; i++)&#123;</span><br><span class="line">        arr[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;hello world\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码的运行结果并非是打印三行“hello world”，而是会无限打印“hello world”，</p>
<p>因为数组大小为 3，a[0]，a[1]，a[2]，而for 循环的结束条件错写为了 i&lt;=3 而非 i&lt;3，所以当 i=3 时，数组 a[3]访问越界。</p>
<p>在 C 语言中，只要不是访问受限的内存，所有的内存空间都是可以自由访问的。</p>
<p>a[3]会被定位到某块不属于数组的内存地址上，而这个地址正好是存储变量 i 的内存地址，那么 a[3]=0 就相当于 i=0，所以就会导致代码无限循环。</p>
<p>数组越界在 C 语言中是一种未决行为，并没有规定数组访问越界时编译器应该如何处理。因为，访问数组的本质就是访问一段连续内存，只要数组通过偏移计算得到的内存地址是可用的，那么程序就可能不会报任何错误。</p>
<p><font color="gree">【注】：关于运行这段C程序会不会出现死循环，结果和编译器的实现有关，gcc有一个编译选项（-fno-stack-protector）用于关闭堆栈保护功能。默认情况下启动了堆栈保护，不管i声明在前还是在后，i都会在数组之后压栈，只会循环4次；如果关闭堆栈保护功能，则会出现死循环。请参考：<a href="https://www.ibm.com/developerworks/cn/linux/l-cn-gccstack/index.html">https://www.ibm.com/developerworks/cn/linux/l-cn-gccstack/index.html</a></font></p>
<p><font color="red">【注】：函数体内的局部变量存在栈上，且是连续压栈。在Linux进程的内存布局中，栈区在高地址空间，从高向低增长。变量i和arr在相邻地址，且i比arr的地址大，所以arr越界正好访问到i。当然，前提是i和arr元素同类型，否则那段代码仍是未决行为。</font></p>
<h2 id="容器能否完全替代数组？">容器能否完全替代数组？</h2>
<p>针对数组类型，很多语言都提供了容器类，比如 Java 中的 ArrayList、C++ STL 中的 vector。</p>
<p>容器的底层都是数组，只不过对于Java中的容器而言，Vector是线程安全的，但是效率太低。ArrayList是非线程安全的，效率高。Vector是java早期版本使用的容器，而ArrayList则是java近期版本使用的容器，ArrayList的出现就是为了取代Vector的。平时使用的list等语言中的数据类型属于对其进行的封装，也称为容器，容器会帮助开发者自动实现一些功能去实现对数组的操作在项目开发中。</p>
<p>对于业务开发，直接使用容器就足够了，省时省力。做一些非常底层的开发，比如开发网络框架，性能的优化需要做到极致，这个时候数组就会优于容器，成为首选。</p>
<h2 id="why大多数编程语言数组下标从0开始？">why大多数编程语言数组下标从0开始？</h2>
<p>从数组存储的内存模型上来看，“下标”最确切的定义应该是“偏移（offset）”。如果用 a 来表示数组的首地址，a[0]就是偏移为 0 的位置，也就是首地址，a[k]就表示偏移 k 个 type_size 的位置，所以计算 a[k]的内存地址：</p>
<p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo stretchy="false">[</mo><mi>i</mi><msub><mo stretchy="false">]</mo><mrow><mi>a</mi><mi>d</mi><mi>d</mi><mi>r</mi><mi>e</mi><mi>s</mi><mi>s</mi></mrow></msub><mo>=</mo><mi>b</mi><mi>a</mi><mi>s</mi><msub><mi>e</mi><mrow><mi>a</mi><mi>d</mi><mi>d</mi><mi>r</mi><mi>e</mi><mi>s</mi><mi>s</mi></mrow></msub><mo>+</mo><mi>i</mi><mo>∗</mo><mi>d</mi><mi>a</mi><mi>t</mi><msub><mi>a</mi><mrow><mi>t</mi><mi>y</mi><mi>p</mi><mi>e</mi><mi>S</mi><mi>i</mi><mi>z</mi><mi>e</mi></mrow></msub></mrow><annotation encoding="application/x-tex">a[i]_{address} = base_{address} + i * data_{typeSize}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">d</span><span class="mord mathdefault mtight">d</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord mathdefault">b</span><span class="mord mathdefault">a</span><span class="mord mathdefault">s</span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">d</span><span class="mord mathdefault mtight">d</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.328331em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">t</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span><span class="mord mathdefault mtight">p</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight" style="margin-right:0.05764em;">S</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight" style="margin-right:0.04398em;">z</span><span class="mord mathdefault mtight">e</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span></span></p>
<p>但是如果数组从 1 开始计数：</p>
<p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo stretchy="false">[</mo><mi>i</mi><msub><mo stretchy="false">]</mo><mrow><mi>a</mi><mi>d</mi><mi>d</mi><mi>r</mi><mi>e</mi><mi>s</mi><mi>s</mi></mrow></msub><mo>=</mo><mi>b</mi><mi>a</mi><mi>s</mi><msub><mi>e</mi><mrow><mi>a</mi><mi>d</mi><mi>d</mi><mi>r</mi><mi>e</mi><mi>s</mi><mi>s</mi></mrow></msub><mo>+</mo><mo stretchy="false">(</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>∗</mo><mi>d</mi><mi>a</mi><mi>t</mi><msub><mi>a</mi><mrow><mi>t</mi><mi>y</mi><mi>p</mi><mi>e</mi><mi>S</mi><mi>i</mi><mi>z</mi><mi>e</mi></mrow></msub></mrow><annotation encoding="application/x-tex">a[i]_{address} = base_{address} + (i-1) * data_{typeSize}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">d</span><span class="mord mathdefault mtight">d</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord mathdefault">b</span><span class="mord mathdefault">a</span><span class="mord mathdefault">s</span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">d</span><span class="mord mathdefault mtight">d</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.328331em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">t</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span><span class="mord mathdefault mtight">p</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight" style="margin-right:0.05764em;">S</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight" style="margin-right:0.04398em;">z</span><span class="mord mathdefault mtight">e</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span></span></p>
<p>从 1 开始编号，每次随机访问数组元素都多了一次减法运算，对于 CPU 来说，就是多了一次减法指令。数组作为非常基础的数据结构，通过下标随机访问数组元素又是其非常基础的编程操作，效率的优化就要尽可能做到极致。所以为了减少一次减法操作，数组选择了从 0 开始编号，而不是从 1 开始。</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>刷算法---2021.08</title>
    <url>/2021/08/14/%E5%88%B7%E7%AE%97%E6%B3%95/%E5%88%B7%E7%AE%97%E6%B3%95-2021-08/</url>
    <content><![CDATA[<blockquote>
<p>从2021年8月中旬开始刷题。</p>
<span id="more"></span>
</blockquote>
<blockquote>
<p>本文将记录我在2021年8月中所刷过的题目，题目量不多，但是每一道保证理解透彻。</p>
</blockquote>
<h1>力扣26题：删除有序数组中的重复项</h1>
<p>题目链接：<a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/">点击这里</a></p>
<p><img src="/2021/08/14/%E5%88%B7%E7%AE%97%E6%B3%95/%E5%88%B7%E7%AE%97%E6%B3%95-2021-08/leetcode26.png" alt="AC"></p>
<blockquote>
<p>首先看清楚题目，这道题目说了是一个有序的数组，那么重复的元素必定是连续的，就连续这一特点我们可以摒弃平常用的字典计数的方法或者使用set的方法，而采用更加简便的方法。</p>
</blockquote>
<ul>
<li><font color="gree">思路1：双指针(时间复杂度O(n)，空间复杂度O(1))</font></li>
</ul>
<p>假设两个指针p和q，p在左边，q在右边，如果<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>p</mi><mo stretchy="false">]</mo><mo>=</mo><mo>=</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>q</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">nums[p]==nums[q]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">p</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mclose">]</span></span></span></span>，即两指针指向的元素值相等了，那么q指针右移一个单位，再次判断俩指针指向的值是否相等，如果还是相等，q指针继续移动；如果不相等，p指针移动一个单位，且<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>p</mi><mo stretchy="false">]</mo><mo>=</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>q</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">nums[p] = nums[q]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">p</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mclose">]</span></span></span></span>。</p>
<p>那么何时跳出循环呢？如果q到达了nums最后一个元素，那么说明了所有的元素都遍历了一遍，那么此时p所指向的就是不重复的元素的最后一个。</p>
<p>将上述过程写成伪代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">p=<span class="number">0</span>, q=<span class="number">1</span>, r=<span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> q &lt; nums.size():</span><br><span class="line">    <span class="keyword">if</span> nums[p] == nums[q]:</span><br><span class="line">        q++</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        p++</span><br><span class="line">        nums[p] = nums[q]</span><br><span class="line"><span class="keyword">return</span> p</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里需要注意的是，如果直接返回p结果是错的，因为测试的方式是p在nums中所对应的元素是不访问的，</span></span><br><span class="line"><span class="comment"># 所以需要返回p+1</span></span><br></pre></td></tr></table></figure>
<p>可以自行举个例子来将上述过程推演一遍：<br>
nums = 0, 0, 1, 1, 1, 2, 2, 3, 3, 4。</p>
<p>完整代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> p = <span class="number">0</span>, q = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (q &lt; nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[p] == nums[q]) &#123;</span><br><span class="line">                q++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                p++;</span><br><span class="line">                nums[p] = nums[q];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代码看起来不够简洁？将一些语句合并之后得到如下的版本：</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> p = <span class="number">0</span>, q = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> q = <span class="number">1</span>; q &lt; nums.<span class="built_in">size</span>(); q++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[p] != nums[q]) </span><br><span class="line">                nums[++p] = nums[q];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li><font color="gree">思路2：使用STL(时间复杂度O(n)，空间复杂度O(1))</font></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">distance</span>(nums.<span class="built_in">begin</span>(), </span><br><span class="line">        <span class="built_in">removeDuplicates</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), nums.<span class="built_in">begin</span>()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>  InIt, <span class="keyword">typename</span> OutIt&gt;</span></span><br><span class="line"><span class="function">    OutIt <span class="title">removeDuplicates</span><span class="params">(InIt first, InIt last, OutIt output)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (first != last) &#123;</span><br><span class="line">            *output++ = *first;</span><br><span class="line">            first = <span class="built_in">upper_bound</span>(first, last, *first);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li><font color="gree">思路3：通用解法，将原问题的「最多保留 1 位」修改为「最多保留 k 位」。</font></li>
</ul>
<p>假设我们使用的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo>=</mo><mo stretchy="false">[</mo><mn>1</mn><mo separator="true">,</mo><mn>1</mn><mo separator="true">,</mo><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mn>3</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">nums=[1, 1, 1, 2, 2, 3]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">3</span><span class="mclose">]</span></span></span></span><br>
我们仍然使用双指针法。这样的思路：</p>
<p>既然需要保留K个相同的数字，我们就用一个变量r来存储当前数字的相同的个数。一开始p指针指向index=0，q指针指向index=1，首先判断<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>p</mi><mo stretchy="false">]</mo><mo>=</mo><mo>=</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>q</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">nums[p]==nums[q]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">p</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mclose">]</span></span></span></span>是否成立，如果是的，我们需要判断计数器r的值是否超出了K的限定范围，如果超出了，那么只用q继续往后走，如果没有超出，我们让与p相距r个位置的数值=nums[q]，即：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>p</mi><mo>+</mo><mi>r</mi><mo stretchy="false">]</mo><mo>=</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>q</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">nums[p+r] = nums[q]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">p</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mclose">]</span></span></span></span>；如果不成立，即此时<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>p</mi><mo stretchy="false">]</mo><mo stretchy="false">!</mo><mo>=</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>q</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">nums[p]!=nums[q]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">p</span><span class="mclose">]</span><span class="mclose">!</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mclose">]</span></span></span></span>，假设刚刚在遍历数字1，那么此时意味着此时数字1已经遍历完了，所以<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>q</mi><mo stretchy="false">]</mo><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">nums[q]=2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span>，这个时候我们要将p指针指向这个新的数字的开端，即p=q。</p>
<p>这样写有什么问题？</p>
<p>如果p和q之间相差很多呢，比如1， 1， 1， 1， 1， 1，2，此时p指向第三个1，而q指向2，能将p直接指向q的2吗？显然不能！但是想起来我们用了一个计数器r，这就容易想到我们可以使用计数器来实现p指针的新指向：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo>+</mo><mo>=</mo><mi>r</mi></mrow><annotation encoding="application/x-tex">p += r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7777700000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mord">+</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span></span></span></span>。然后是一个新的数字了，所以计数器r需要更新为1，新的数字还要移动过来给p：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>p</mi><mo stretchy="false">]</mo><mo>=</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>q</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">nums[p] = nums[q]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">p</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mclose">]</span></span></span></span>，这就是一个完整的循环需要做的事情。循环结束的标志？和K为1的时候一样，当q超出nums长度即停止。</p>
<p>综合上述流程的伪代码为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">k=<span class="number">2</span>, p = <span class="number">0</span>, q = <span class="number">1</span>, r = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> q &lt; nums.size():</span><br><span class="line">	<span class="keyword">if</span> nums[p] == nums[q]:</span><br><span class="line">		nums[p + r] = nums[q]</span><br><span class="line">		r++, q++</span><br><span class="line">	<span class="keyword">else</span>:</span><br><span class="line">		p += r, r = <span class="number">1</span></span><br><span class="line">		nums[p] = nums[q]</span><br><span class="line">		q++</span><br></pre></td></tr></table></figure>
<p>使用C++来实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">2</span>, r = <span class="number">1</span>, p = <span class="number">0</span>, q = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (; q &lt; nums.<span class="built_in">size</span>(); q++) &#123;</span><br><span class="line">           <span class="keyword">if</span> (nums[p] == nums[q]) &#123;</span><br><span class="line">               <span class="keyword">if</span> (r &lt; k) &#123;</span><br><span class="line">                   nums[p + r] = nums[q];</span><br><span class="line">                   r++;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span> &#123;</span><br><span class="line">               p += r;</span><br><span class="line">               r = <span class="number">1</span>;</span><br><span class="line">               nums[p] = nums[q];</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>问题来了，将这段C++代码拿去运行发现只能通过部分案例，什么问题？仔细分析代码之后发现，如果在退出循环之前，进入的是else分支，那么p将得到更新：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo>+</mo><mo>=</mo><mi>r</mi></mrow><annotation encoding="application/x-tex">p+=r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7777700000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mord">+</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span></span></span></span>，如果经过的是if分支，p无法得到更新，直接退出循环！所以这里逻辑需要更改，可以直接在if分支中让每一次p+r吗?不行，因为r是不断增加的。我的解决方式是，每一次都让p更新一下，而不是到了最后一次性加上r，即在每一次遇到与nums[p]相同数字的时候，如果r&lt;k就马上更新p：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (nums[p] == nums[q]) &#123;</span><br><span class="line">    <span class="keyword">if</span> (r &lt; k) &#123;</span><br><span class="line">        r++;</span><br><span class="line">        nums[++p] = nums[q];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样就可以将else分支中的p+=r去掉：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//  p += r;</span></span><br><span class="line">    r = <span class="number">1</span>;</span><br><span class="line">    nums[++p] = nums[q];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完整的代码为：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">2</span>, r = <span class="number">1</span>, p = <span class="number">0</span>, q = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (; q &lt; nums.<span class="built_in">size</span>(); q++) &#123;</span><br><span class="line">           <span class="keyword">if</span> (nums[p] == nums[q]) &#123;</span><br><span class="line">               <span class="keyword">if</span> (r &lt; k) &#123;</span><br><span class="line">                   r++;</span><br><span class="line">                   nums[++p] = nums[q];</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//               p += r;</span></span><br><span class="line">               r = <span class="number">1</span>;</span><br><span class="line">               nums[++p] = nums[q];</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这个搞定之后，可以顺便去把这道题给AC掉：<br>
<a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array-ii/">80. 删除有序数组中的重复项 II</a></p>
<h1>力扣33题.搜索旋转排序数组</h1>
<p>题目链接：<a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array/">点击这里</a></p>
<p><img src="/2021/08/14/%E5%88%B7%E7%AE%97%E6%B3%95/%E5%88%B7%E7%AE%97%E6%B3%95-2021-08/leetcode33.png" alt="AC"></p>
<blockquote>
<p>这道题如果不去考虑时间复杂度的限制将是非常容易的遍历问题，但是本题的进阶方案是：设计一个时间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>的解决方案。</p>
<p>想到时间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(logn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>很容易思考到二分查找法，但是本题只是两部分有序的，所以直接用原本的二分查找行不通，需要进行修改，思路如下：</p>
</blockquote>
<p>假设输入的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo>=</mo><mrow><mn>4</mn><mo separator="true">,</mo><mn>5</mn><mo separator="true">,</mo><mn>6</mn><mo separator="true">,</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mn>3</mn></mrow></mrow><annotation encoding="application/x-tex">nums={4,5,6,0,1,2,3}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">6</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">3</span></span></span></span></span>。</p>
<p>初始<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>e</mi><mi>f</mi><mi>t</mi><mo>=</mo><mn>0</mn><mo separator="true">,</mo><mi>r</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mo>=</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mi mathvariant="normal">.</mi><mi>s</mi><mi>i</mi><mi>z</mi><mi>e</mi><mo stretchy="false">(</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">left=0,right=nums.size()</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mord">.</span><span class="mord mathdefault">s</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mord mathdefault">e</span><span class="mopen">(</span><span class="mclose">)</span></span></span></span>，每一次循环中，取<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi>i</mi><mi>d</mi><mo>=</mo><mo stretchy="false">(</mo><mi>l</mi><mi>e</mi><mi>f</mi><mi>t</mi><mo>+</mo><mi>r</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">mid=(left+right)/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mord mathdefault">t</span><span class="mclose">)</span><span class="mord">/</span><span class="mord">2</span></span></span></span>，将序列最左端的值和target比较，有两种情况需要重点考虑：1. <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mo stretchy="false">[</mo><mi>l</mi><mi>e</mi><mi>f</mi><mi>t</mi><mo stretchy="false">]</mo><mo>&gt;</mo><mi>t</mi><mi>a</mi><mi>r</mi><mi>g</mi><mi>e</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">num[left]&gt;target</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">t</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.80952em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">e</span><span class="mord mathdefault">t</span></span></span></span>，2. <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mo stretchy="false">[</mo><mi>l</mi><mi>e</mi><mi>f</mi><mi>t</mi><mo stretchy="false">]</mo><mo>&lt;</mo><mi>t</mi><mi>a</mi><mi>r</mi><mi>g</mi><mi>e</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">num[left]&lt;target</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">t</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.80952em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">e</span><span class="mord mathdefault">t</span></span></span></span>，等于的话直接结束程序。</p>
<p>如果 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mo stretchy="false">[</mo><mi>l</mi><mi>e</mi><mi>f</mi><mi>t</mi><mo stretchy="false">]</mo><mo>&gt;</mo><mi>t</mi><mi>a</mi><mi>r</mi><mi>g</mi><mi>e</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">num[left]&gt;target</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">t</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.80952em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">e</span><span class="mord mathdefault">t</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>m</mi><mi>i</mi><mi>d</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">nums[mid]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mclose">]</span></span></span></span>有3种情况，一种是比target大，一种是比它小，最后就是相等。</p>
<ul>
<li>如果<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>m</mi><mi>i</mi><mi>d</mi><mo stretchy="false">]</mo><mo>&gt;</mo><mi>t</mi><mi>a</mi><mi>r</mi><mi>g</mi><mi>e</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">nums[mid]&gt;target</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.80952em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">e</span><span class="mord mathdefault">t</span></span></span></span>​，还有两种情况，一种是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>m</mi><mi>i</mi><mi>d</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">nums[mid]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mclose">]</span></span></span></span>​在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">nums</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span></span></span></span>​的最小值的左边，那么此时有：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>m</mi><mi>i</mi><mi>d</mi><mo stretchy="false">]</mo><mo>&lt;</mo><mi>t</mi><mi>a</mi><mi>r</mi><mi>g</mi><mi>e</mi><mi>t</mi><mo>&lt;</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>r</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">nums[mid]&lt;target&lt;nums[right]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.80952em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">e</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mord mathdefault">t</span><span class="mclose">]</span></span></span></span>​，所以更新<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>e</mi><mi>f</mi><mi>t</mi><mo>=</mo><mi>m</mi><mi>i</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">left=mid</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span></span></span></span>​；一种是在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">nums</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span></span></span></span>​的最小值的右边，这种情况下，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>m</mi><mi>i</mi><mi>d</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">nums[mid]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mclose">]</span></span></span></span>​和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>r</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">nums[right]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mord mathdefault">t</span><span class="mclose">]</span></span></span></span>​均大于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>a</mi><mi>r</mi><mi>g</mi><mi>e</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">target</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80952em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">e</span><span class="mord mathdefault">t</span></span></span></span>​，所以需要更新<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>e</mi><mi>f</mi><mi>t</mi><mo>=</mo><mi>l</mi><mi>e</mi><mi>f</mi><mi>t</mi><mo separator="true">,</mo><mi>r</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mo>=</mo><mi>m</mi><mi>i</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">left=left,right=mid</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">t</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span></span></span></span>​。</li>
<li>如果<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>m</mi><mi>i</mi><mi>d</mi><mo stretchy="false">]</mo><mo>&lt;</mo><mi>t</mi><mi>a</mi><mi>r</mi><mi>g</mi><mi>e</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">nums[mid]&lt;target</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.80952em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">e</span><span class="mord mathdefault">t</span></span></span></span>，只有一种情况，更新为：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>e</mi><mi>f</mi><mi>t</mi><mo>=</mo><mi>m</mi><mi>i</mi><mi>d</mi><mo separator="true">,</mo><mi>r</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mo>=</mo><mi>r</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">left=mid,right=right</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mord mathdefault">t</span></span></span></span>。</li>
<li>如果<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>m</mi><mi>i</mi><mi>d</mi><mo stretchy="false">]</mo><mo>=</mo><mo>=</mo><mi>t</mi><mi>a</mi><mi>r</mi><mi>g</mi><mi>e</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">nums[mid]==target</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.80952em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">e</span><span class="mord mathdefault">t</span></span></span></span>，找到目标值。</li>
</ul>
<p>如果 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mo stretchy="false">[</mo><mi>l</mi><mi>e</mi><mi>f</mi><mi>t</mi><mo stretchy="false">]</mo><mo>&lt;</mo><mi>t</mi><mi>a</mi><mi>r</mi><mi>g</mi><mi>e</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">num[left]&lt;target</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">t</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.80952em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">e</span><span class="mord mathdefault">t</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi>i</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">mid</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span></span></span></span>同样有3中情况，即<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>m</mi><mi>i</mi><mi>d</mi><mo stretchy="false">]</mo><mo>&gt;</mo><mi>t</mi><mi>a</mi><mi>r</mi><mi>g</mi><mi>e</mi><mi>t</mi><mo separator="true">,</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>m</mi><mi>i</mi><mi>d</mi><mo stretchy="false">]</mo><mo>&lt;</mo><mi>t</mi><mi>a</mi><mi>r</mi><mi>g</mi><mi>e</mi><mi>t</mi><mo separator="true">,</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>m</mi><mi>i</mi><mi>d</mi><mo stretchy="false">]</mo><mo>=</mo><mo>=</mo><mi>t</mi><mi>a</mi><mi>r</mi><mi>g</mi><mi>e</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">nums[mid]&gt;target, nums[mid]&lt;target, nums[mid]==target</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">e</span><span class="mord mathdefault">t</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">e</span><span class="mord mathdefault">t</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.80952em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">e</span><span class="mord mathdefault">t</span></span></span></span>。</p>
<ul>
<li>如果<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>m</mi><mi>i</mi><mi>d</mi><mo stretchy="false">]</mo><mo>&gt;</mo><mi>t</mi><mi>a</mi><mi>r</mi><mi>g</mi><mi>e</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">nums[mid]&gt;target</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.80952em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">e</span><span class="mord mathdefault">t</span></span></span></span>，只有一种情况，即：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>l</mi><mi>e</mi><mi>f</mi><mi>t</mi><mo stretchy="false">]</mo><mo>&lt;</mo><mi>t</mi><mi>a</mi><mi>r</mi><mi>g</mi><mi>e</mi><mi>t</mi><mo>&lt;</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>m</mi><mi>i</mi><mi>d</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">nums[left]&lt;target&lt;nums[mid]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">t</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.80952em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">e</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mclose">]</span></span></span></span>，更新为：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>e</mi><mi>f</mi><mi>t</mi><mo>=</mo><mi>l</mi><mi>e</mi><mi>f</mi><mi>t</mi><mo separator="true">,</mo><mi>r</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mo>=</mo><mi>m</mi><mi>i</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">left=left, right=mid</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">t</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span></span></span></span></li>
<li>如果<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>m</mi><mi>i</mi><mi>d</mi><mo stretchy="false">]</mo><mo>&lt;</mo><mi>t</mi><mi>a</mi><mi>r</mi><mi>g</mi><mi>e</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">nums[mid]&lt;target</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.80952em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">e</span><span class="mord mathdefault">t</span></span></span></span>​​​，有两种情况，一种是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>m</mi><mi>i</mi><mi>d</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">nums[mid]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mclose">]</span></span></span></span>​​​在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">nums</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span></span></span></span>​​​最小值的左边，那么此时有：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>l</mi><mi>e</mi><mi>f</mi><mi>t</mi><mo stretchy="false">]</mo><mo>&lt;</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>m</mi><mi>i</mi><mi>d</mi><mo stretchy="false">]</mo><mo>&lt;</mo><mi>t</mi><mi>a</mi><mi>r</mi><mi>g</mi><mi>e</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">nums[left]&lt;nums[mid]&lt;target</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">t</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.80952em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">e</span><span class="mord mathdefault">t</span></span></span></span>​​​，这种情况下，需要更新：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>e</mi><mi>f</mi><mi>t</mi><mo>=</mo><mi>m</mi><mi>i</mi><mi>d</mi><mo separator="true">,</mo><mi>r</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mo>=</mo><mi>r</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">left=mid,right=right</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mord mathdefault">t</span></span></span></span>​​​；另一种是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>m</mi><mi>i</mi><mi>d</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">nums[mid]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mclose">]</span></span></span></span>​​​在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">nums</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span></span></span></span>​​​最小值的右边，此时有：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>l</mi><mi>e</mi><mi>f</mi><mi>t</mi><mo stretchy="false">]</mo><mo>&lt;</mo><mi>t</mi><mi>a</mi><mi>r</mi><mi>g</mi><mi>e</mi><mi>t</mi><mo>&lt;</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>m</mi><mi>i</mi><mi>d</mi><mo stretchy="false">]</mo><mo>&lt;</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>r</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">nums[left]&lt;target&lt;nums[mid]&lt;nums[right]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">t</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.80952em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">e</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mord mathdefault">t</span><span class="mclose">]</span></span></span></span>​​​，所以更新<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>e</mi><mi>f</mi><mi>t</mi><mo>=</mo><mi>l</mi><mi>e</mi><mi>f</mi><mi>t</mi><mtext>，</mtext><mi>r</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mo>=</mo><mi>m</mi><mi>i</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">left=left，right=mid</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">t</span><span class="mord cjk_fallback">，</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span></span></span></span>​​​。</li>
<li>如果<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>m</mi><mi>i</mi><mi>d</mi><mo stretchy="false">]</mo><mo>=</mo><mo>=</mo><mi>t</mi><mi>a</mi><mi>r</mi><mi>g</mi><mi>e</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">nums[mid]==target</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.80952em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">e</span><span class="mord mathdefault">t</span></span></span></span>​，找到目标值。</li>
</ul>
<p>将上述思路使用代码实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> mid;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right)</span><br><span class="line">        &#123;</span><br><span class="line">            mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[left] &gt; target)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[mid] &gt; target)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (nums[mid] &gt;= nums[left]) <span class="comment">// mid在最小值的左边</span></span><br><span class="line">                        left = mid;</span><br><span class="line">                    <span class="keyword">else</span>                         <span class="comment">// mid在最小值的右边</span></span><br><span class="line">                        right = mid;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target)</span><br><span class="line">                    left = mid;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[left] &lt; target)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[mid] &gt; target)</span><br><span class="line">                    right = mid;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (nums[mid] &gt;= nums[left])  <span class="comment">// mid在最小值的左边</span></span><br><span class="line">                        left = mid;</span><br><span class="line">                    <span class="keyword">else</span>                          <span class="comment">// mid在最小值的右边</span></span><br><span class="line">                        right = mid;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这段代码并不能通过所有的实例，准确的说，很多实例都无法通过，一旦进入类似这样的情况：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>2</mn><mo separator="true">,</mo><mn>3</mn><mo stretchy="false">]</mo><mtext>，</mtext><mi>l</mi><mi>e</mi><mi>f</mi><mi>t</mi><mo>=</mo><mn>0</mn><mo separator="true">,</mo><mi>r</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mo>=</mo><mn>1</mn><mo separator="true">,</mo><mi>t</mi><mi>a</mi><mi>r</mi><mi>g</mi><mi>e</mi><mi>t</mi><mo>=</mo><mn>4</mn></mrow><annotation encoding="application/x-tex">[2, 3]，left=0, right=1,target=4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">3</span><span class="mclose">]</span><span class="mord cjk_fallback">，</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">e</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span></span></span></span>​，这种情况下，取<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi>i</mi><mi>d</mi><mo>=</mo><mo stretchy="false">(</mo><mn>0</mn><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">mid=(0+1)/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mord">/</span><span class="mord">2</span></span></span></span>，取整，得到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi>i</mi><mi>d</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">mid=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>，就会一直循环下去。</p>
<p>其实<font color="red">在二分法中，仅仅使用左右区间索引值之和的一半很容易出现这种循环，需要走出循环，一定需要通过加减来变化索引的值</font></p>
<p>比如我知道了<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>m</mi><mi>i</mi><mi>d</mi><mo stretchy="false">]</mo><mo>&lt;</mo><mi>t</mi><mi>a</mi><mi>r</mi><mi>g</mi><mi>e</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">nums[mid]&lt;target</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.80952em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">e</span><span class="mord mathdefault">t</span></span></span></span>​，就取<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>e</mi><mi>f</mi><mi>t</mi><mo>=</mo><mi>m</mi><mi>i</mi><mi>d</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">left=mid+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>​，而不是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>e</mi><mi>f</mi><mi>t</mi><mo>=</mo><mi>m</mi><mi>i</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">left=mid</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span></span></span></span>。通过加减1走出循环将上述代码改为如下代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> mid;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right)</span><br><span class="line">        &#123;</span><br><span class="line">            mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[left] &gt; target)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[mid] &gt; target)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (nums[mid] &gt;= nums[left]) <span class="comment">// mid在最小值的左边</span></span><br><span class="line">                        left = mid + <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">else</span>                         <span class="comment">// mid在最小值的右边</span></span><br><span class="line">                        right = mid - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target)</span><br><span class="line">                    left = mid + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[left] &lt; target)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[mid] &gt; target)</span><br><span class="line">                    right = mid - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (nums[mid] &gt;= nums[left])  <span class="comment">// mid在最小值的左边</span></span><br><span class="line">                        left = mid + <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">else</span>                          <span class="comment">// mid在最小值的右边</span></span><br><span class="line">                        right = mid - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>刷算法</category>
      </categories>
      <tags>
        <tag>刷算法</tag>
      </tags>
  </entry>
</search>
